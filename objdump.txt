254-254100


./build/kernel-x86_64.bin:     file format elf64-x86-64


Disassembly of section .text:

0000000000100760 <isr_stub>:
  100760:	50                   	push   %rax
  100761:	53                   	push   %rbx
  100762:	51                   	push   %rcx
  100763:	52                   	push   %rdx
  100764:	57                   	push   %rdi
  100765:	56                   	push   %rsi
  100766:	55                   	push   %rbp
  100767:	41 50                	push   %r8
  100769:	41 51                	push   %r9
  10076b:	41 52                	push   %r10
  10076d:	41 53                	push   %r11
  10076f:	41 54                	push   %r12
  100771:	41 55                	push   %r13
  100773:	41 56                	push   %r14
  100775:	41 57                	push   %r15
  100777:	fc                   	cld    
  100778:	48 c7 04 25 00 80 0b 	movq   $0x2f4b2f4f,0xb8000
  10077f:	00 4f 2f 4b 2f 
  100784:	41 5f                	pop    %r15
  100786:	41 5e                	pop    %r14
  100788:	41 5d                	pop    %r13
  10078a:	41 5c                	pop    %r12
  10078c:	41 5b                	pop    %r11
  10078e:	41 5a                	pop    %r10
  100790:	41 59                	pop    %r9
  100792:	41 58                	pop    %r8
  100794:	5d                   	pop    %rbp
  100795:	5e                   	pop    %rsi
  100796:	5f                   	pop    %rdi
  100797:	5a                   	pop    %rdx
  100798:	59                   	pop    %rcx
  100799:	5b                   	pop    %rbx
  10079a:	58                   	pop    %rax
  10079b:	48 cf                	iretq  
  10079d:	90                   	nop
  10079e:	90                   	nop
  10079f:	90                   	nop

00000000001007a0 <isr_except_stub>:
  1007a0:	66 87 db             	xchg   %bx,%bx
  1007a3:	50                   	push   %rax
  1007a4:	53                   	push   %rbx
  1007a5:	51                   	push   %rcx
  1007a6:	52                   	push   %rdx
  1007a7:	57                   	push   %rdi
  1007a8:	56                   	push   %rsi
  1007a9:	55                   	push   %rbp
  1007aa:	41 50                	push   %r8
  1007ac:	41 51                	push   %r9
  1007ae:	41 52                	push   %r10
  1007b0:	41 53                	push   %r11
  1007b2:	41 54                	push   %r12
  1007b4:	41 55                	push   %r13
  1007b6:	41 56                	push   %r14
  1007b8:	41 57                	push   %r15
  1007ba:	fc                   	cld    
  1007bb:	48 89 e7             	mov    %rsp,%rdi
  1007be:	48 c7 04 25 00 80 0b 	movq   $0x2f4b2f4f,0xb8000
  1007c5:	00 4f 2f 4b 2f 
  1007ca:	41 5f                	pop    %r15
  1007cc:	41 5e                	pop    %r14
  1007ce:	41 5d                	pop    %r13
  1007d0:	41 5c                	pop    %r12
  1007d2:	41 5b                	pop    %r11
  1007d4:	41 5a                	pop    %r10
  1007d6:	41 59                	pop    %r9
  1007d8:	41 58                	pop    %r8
  1007da:	5d                   	pop    %rbp
  1007db:	5e                   	pop    %rsi
  1007dc:	5f                   	pop    %rdi
  1007dd:	5a                   	pop    %rdx
  1007de:	59                   	pop    %rcx
  1007df:	5b                   	pop    %rbx
  1007e0:	58                   	pop    %rax
  1007e1:	48 cf                	iretq  
  1007e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ea:	00 00 00 
  1007ed:	0f 1f 00             	nopl   (%rax)

00000000001007f0 <long_mode_start>:
  1007f0:	48 b8 4f 2f 4b 2f 41 	movabs $0x2f592f412f4b2f4f,%rax
  1007f7:	2f 59 2f 
  1007fa:	48 89 04 25 00 80 0b 	mov    %rax,0xb8000
  100801:	00 
  100802:	e8 a9 37 00 00       	callq  103fb0 <kernel_main>

0000000000100807 <halt>:
  100807:	f4                   	hlt    
  100808:	eb fd                	jmp    100807 <halt>
  10080a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000100810 <start>:
  100810:	bc 00 d0 10 00       	mov    $0x10d000,%esp
  100815:	e8 23 00 00 00       	callq  10083d <check_multiboot>
  10081a:	e8 2a 00 00 00       	callq  100849 <check_cpuid>
  10081f:	e8 3d 00 00 00       	callq  100861 <check_long_mode>
  100824:	e8 7e 00 00 00       	callq  1008a7 <set_up_paging>
  100829:	e8 b5 00 00 00       	callq  1008e3 <set_paging>
  10082e:	0f 01 15 26 00 10 00 	lgdt   0x100026(%rip)        # 20085b <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE+0xf3857>
  100835:	ea                   	(bad)  
  100836:	f0 07                	lock (bad) 
  100838:	10 00                	adc    %al,(%rax)
  10083a:	08 00                	or     %al,(%rax)
  10083c:	f4                   	hlt    

000000000010083d <check_multiboot>:
  10083d:	3d 89 62 d7 36       	cmp    $0x36d76289,%eax
  100842:	75 01                	jne    100845 <check_multiboot.no_multiboot>
  100844:	c3                   	retq   

0000000000100845 <check_multiboot.no_multiboot>:
  100845:	b0 30                	mov    $0x30,%al
  100847:	eb 3a                	jmp    100883 <error>

0000000000100849 <check_cpuid>:
  100849:	9c                   	pushfq 
  10084a:	58                   	pop    %rax
  10084b:	89 c1                	mov    %eax,%ecx
  10084d:	35 00 00 20 00       	xor    $0x200000,%eax
  100852:	50                   	push   %rax
  100853:	9d                   	popfq  
  100854:	9c                   	pushfq 
  100855:	58                   	pop    %rax
  100856:	51                   	push   %rcx
  100857:	9d                   	popfq  
  100858:	39 c8                	cmp    %ecx,%eax
  10085a:	74 01                	je     10085d <check_cpuid.cpuid_err>
  10085c:	c3                   	retq   

000000000010085d <check_cpuid.cpuid_err>:
  10085d:	b0 31                	mov    $0x31,%al
  10085f:	eb 22                	jmp    100883 <error>

0000000000100861 <check_long_mode>:
  100861:	b8 00 00 00 80       	mov    $0x80000000,%eax
  100866:	0f a2                	cpuid  
  100868:	3d 01 00 00 80       	cmp    $0x80000001,%eax
  10086d:	72 10                	jb     10087f <check_long_mode.no_support>
  10086f:	b8 01 00 00 80       	mov    $0x80000001,%eax
  100874:	0f a2                	cpuid  
  100876:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
  10087c:	74 01                	je     10087f <check_long_mode.no_support>
  10087e:	c3                   	retq   

000000000010087f <check_long_mode.no_support>:
  10087f:	b0 32                	mov    $0x32,%al
  100881:	eb 00                	jmp    100883 <error>

0000000000100883 <error>:
  100883:	c7 05 00 80 0b 00 45 	movl   $0x4f524f45,0xb8000(%rip)        # 1b888d <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE+0xab889>
  10088a:	4f 52 4f 
  10088d:	c7 05 04 80 0b 00 52 	movl   $0x4f3a4f52,0xb8004(%rip)        # 1b889b <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE+0xab897>
  100894:	4f 3a 4f 
  100897:	c7 05 08 80 0b 00 20 	movl   $0x4f204f20,0xb8008(%rip)        # 1b88a9 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE+0xab8a5>
  10089e:	4f 20 4f 
  1008a1:	a2                   	.byte 0xa2
  1008a2:	0a                   	.byte 0xa
  1008a3:	80 0b 00             	orb    $0x0,(%rbx)
  1008a6:	f4                   	hlt    

00000000001008a7 <set_up_paging>:
  1008a7:	b8 00 70 10 00       	mov    $0x107000,%eax
  1008ac:	83 c8 03             	or     $0x3,%eax
  1008af:	a3 00 60 10 00 b8 00 	movabs %eax,0x108000b800106000
  1008b6:	80 10 
  1008b8:	00 83 c8 03 a3 00    	add    %al,0xa303c8(%rbx)
  1008be:	70 10                	jo     1008d0 <set_up_paging.map_p2_table+0xa>
  1008c0:	00 b9 00 00 00 00    	add    %bh,0x0(%rcx)

00000000001008c6 <set_up_paging.map_p2_table>:
  1008c6:	b8 00 00 20 00       	mov    $0x200000,%eax
  1008cb:	f7 e1                	mul    %ecx
  1008cd:	0d 83 00 00 00       	or     $0x83,%eax
  1008d2:	89 04 cd 00 80 10 00 	mov    %eax,0x108000(,%rcx,8)
  1008d9:	41 81 f9 00 02 00 00 	cmp    $0x200,%r9d
  1008e0:	75 e4                	jne    1008c6 <set_up_paging.map_p2_table>
  1008e2:	c3                   	retq   

00000000001008e3 <set_paging>:
  1008e3:	b8 00 60 10 00       	mov    $0x106000,%eax
  1008e8:	0f 22 d8             	mov    %rax,%cr3
  1008eb:	0f 20 e0             	mov    %cr4,%rax
  1008ee:	83 c8 20             	or     $0x20,%eax
  1008f1:	0f 22 e0             	mov    %rax,%cr4
  1008f4:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
  1008f9:	0f 32                	rdmsr  
  1008fb:	0d 00 01 00 00       	or     $0x100,%eax
  100900:	0f 30                	wrmsr  
  100902:	0f 20 c0             	mov    %cr0,%rax
  100905:	0d 00 00 00 80       	or     $0x80000000,%eax
  10090a:	0f 22 c0             	mov    %rax,%cr0
  10090d:	c3                   	retq   

Disassembly of section .text._ZN101_$LT$core..ops..range..RangeTo$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17h24ad8ca6cfa12c21E:

0000000000100910 <_ZN101_$LT$core..ops..range..RangeTo$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17h24ad8ca6cfa12c21E>:
    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {
        (0..self.end).get_unchecked(slice)
    }

    #[inline]
    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {
  100910:	55                   	push   %rbp
  100911:	48 89 e5             	mov    %rsp,%rbp
  100914:	48 83 ec 70          	sub    $0x70,%rsp
  100918:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  10091c:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
  100920:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  100924:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  100928:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
  10092c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  100930:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  100934:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  100938:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  10093c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  100940:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  100944:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
        (0..self.end).get_unchecked_mut(slice)
  100948:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  10094c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  100953:	00 
  100954:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  100958:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  10095c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  100960:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  100964:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  100968:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  10096c:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
  100970:	48 89 c7             	mov    %rax,%rdi
  100973:	e8 d8 1f 00 00       	callq  102950 <_ZN99_$LT$core..ops..range..Range$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hcf7274c356591f08E>
  100978:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  10097c:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    }
  100980:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  100984:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  100988:	48 83 c4 70          	add    $0x70,%rsp
  10098c:	5d                   	pop    %rbp
  10098d:	c3                   	retq   

Disassembly of section .text._ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E:

0000000000100990 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E>:
    ///
    /// assert_eq!(maybe_some_len, Some(13));
    /// ```
    #[inline]
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {
  100990:	55                   	push   %rbp
  100991:	48 89 e5             	mov    %rsp,%rbp
  100994:	48 83 ec 50          	sub    $0x50,%rsp
  100998:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  10099c:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  1009a0:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  1009a4:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  1009a8:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  1009ac:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  1009b0:	c6 45 fe 01          	movb   $0x1,-0x2(%rbp)
        match self {
            Some(x) => Some(f(x)),
  1009b4:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  1009b8:	48 85 ff             	test   %rdi,%rdi
  1009bb:	75 08                	jne    1009c5 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x35>
  1009bd:	eb 00                	jmp    1009bf <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x2f>
            None => None,
  1009bf:	c6 45 d0 00          	movb   $0x0,-0x30(%rbp)
    /// assert_eq!(maybe_some_len, Some(13));
    /// ```
    #[inline]
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {
        match self {
  1009c3:	eb 2e                	jmp    1009f3 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x63>
            Some(x) => Some(f(x)),
  1009c5:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  1009c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1009cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  1009d1:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  1009d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1009d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  1009dd:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  1009e1:	e8 3a 1a 00 00       	callq  102420 <_ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned28_$u7b$$u7b$closure$u7d$$u7d$17h84971d7ba5c3a3c4E>
  1009e6:	88 45 bf             	mov    %al,-0x41(%rbp)
  1009e9:	c6 45 d0 01          	movb   $0x1,-0x30(%rbp)
  1009ed:	8a 45 bf             	mov    -0x41(%rbp),%al
  1009f0:	88 45 d1             	mov    %al,-0x2f(%rbp)
            None => None,
        }
    }
  1009f3:	f6 45 fe 01          	testb  $0x1,-0x2(%rbp)
  1009f7:	75 0b                	jne    100a04 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x74>
  1009f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1009fd:	48 85 c0             	test   %rax,%rax
  100a00:	75 12                	jne    100a14 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x84>
  100a02:	eb 1c                	jmp    100a20 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x90>
  100a04:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  100a08:	eb ef                	jmp    1009f9 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x69>
  100a0a:	66 8b 45 d0          	mov    -0x30(%rbp),%ax
  100a0e:	48 83 c4 50          	add    $0x50,%rsp
  100a12:	5d                   	pop    %rbp
  100a13:	c3                   	retq   
  100a14:	f6 45 ff 01          	testb  $0x1,-0x1(%rbp)
  100a18:	74 f0                	je     100a0a <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x7a>
  100a1a:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  100a1e:	eb ea                	jmp    100a0a <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x7a>
  100a20:	eb e8                	jmp    100a0a <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E+0x7a>

Disassembly of section .text._ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE:

0000000000100a30 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE>:
    ///
    /// assert_eq!(maybe_some_len, Some(13));
    /// ```
    #[inline]
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {
  100a30:	55                   	push   %rbp
  100a31:	48 89 e5             	mov    %rsp,%rbp
  100a34:	48 83 ec 40          	sub    $0x40,%rsp
  100a38:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  100a3c:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  100a40:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  100a44:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  100a48:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  100a4c:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  100a50:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  100a54:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  100a58:	c6 45 fe 01          	movb   $0x1,-0x2(%rbp)
        match self {
            Some(x) => Some(f(x)),
  100a5c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  100a5f:	85 c0                	test   %eax,%eax
  100a61:	75 0b                	jne    100a6e <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x3e>
  100a63:	eb 00                	jmp    100a65 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x35>
            None => None,
  100a65:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    /// assert_eq!(maybe_some_len, Some(13));
    /// ```
    #[inline]
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {
        match self {
  100a6c:	eb 2c                	jmp    100a9a <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x6a>
            Some(x) => Some(f(x)),
  100a6e:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  100a72:	8b 45 ec             	mov    -0x14(%rbp),%eax
  100a75:	89 45 f4             	mov    %eax,-0xc(%rbp)
  100a78:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  100a7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  100a7f:	89 45 f8             	mov    %eax,-0x8(%rbp)
  100a82:	8b 7d f8             	mov    -0x8(%rbp),%edi
  100a85:	e8 d6 1b 00 00       	callq  102660 <_ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17h87b813b206527ea1E>
  100a8a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  100a8d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  100a94:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  100a97:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            None => None,
        }
    }
  100a9a:	f6 45 fe 01          	testb  $0x1,-0x2(%rbp)
  100a9e:	75 0d                	jne    100aad <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x7d>
  100aa0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  100aa3:	83 e8 01             	sub    $0x1,%eax
  100aa6:	89 45 c0             	mov    %eax,-0x40(%rbp)
  100aa9:	74 12                	je     100abd <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x8d>
  100aab:	eb 1c                	jmp    100ac9 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x99>
  100aad:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  100ab1:	eb ed                	jmp    100aa0 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x70>
  100ab3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  100ab7:	48 83 c4 40          	add    $0x40,%rsp
  100abb:	5d                   	pop    %rbp
  100abc:	c3                   	retq   
  100abd:	f6 45 ff 01          	testb  $0x1,-0x1(%rbp)
  100ac1:	74 f0                	je     100ab3 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x83>
  100ac3:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  100ac7:	eb ea                	jmp    100ab3 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x83>
  100ac9:	eb e8                	jmp    100ab3 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE+0x83>

Disassembly of section .text._ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5bytes17h5a544d0b11cea8d4E:

0000000000100ad0 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5bytes17h5a544d0b11cea8d4E>:
    fn chars(&self) -> Chars {
        Chars{iter: self.as_bytes().iter()}
    }

    #[inline]
    fn bytes(&self) -> Bytes {
  100ad0:	55                   	push   %rbp
  100ad1:	48 89 e5             	mov    %rsp,%rbp
  100ad4:	48 83 ec 60          	sub    $0x60,%rsp
  100ad8:	48 89 f8             	mov    %rdi,%rax
  100adb:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  100adf:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  100ae3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  100ae7:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  100aeb:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  100aef:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
        Bytes(self.as_bytes().iter().cloned())
  100af3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  100af7:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  100afb:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  100aff:	48 89 d7             	mov    %rdx,%rdi
  100b02:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  100b06:	e8 c5 00 00 00       	callq  100bd0 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$8as_bytes17h7fd06f0442d64421E>
  100b0b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  100b0f:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  100b13:	48 8d 7d f0          	lea    -0x10(%rbp),%rdi
  100b17:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  100b1b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  100b1f:	e8 4c 17 00 00       	callq  102270 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE>
  100b24:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  100b28:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  100b2c:	e8 df 14 00 00       	callq  102010 <_ZN4core4iter8iterator8Iterator6cloned17he6396dd745aa022fE>
  100b31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  100b35:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  100b39:	48 89 01             	mov    %rax,(%rcx)
  100b3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  100b40:	48 89 41 08          	mov    %rax,0x8(%rcx)
    }
  100b44:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  100b48:	48 83 c4 60          	add    $0x60,%rsp
  100b4c:	5d                   	pop    %rbp
  100b4d:	c3                   	retq   

Disassembly of section .text._ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5chars17h778cc94a820d39f6E:

0000000000100b50 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5chars17h778cc94a820d39f6E>:
    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {
        pat.is_contained_in(self)
    }

    #[inline]
    fn chars(&self) -> Chars {
  100b50:	55                   	push   %rbp
  100b51:	48 89 e5             	mov    %rsp,%rbp
  100b54:	48 83 ec 50          	sub    $0x50,%rsp
  100b58:	48 89 f8             	mov    %rdi,%rax
  100b5b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  100b5f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  100b63:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  100b67:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  100b6b:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  100b6f:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
        Chars{iter: self.as_bytes().iter()}
  100b73:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  100b77:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  100b7b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  100b7f:	48 89 d7             	mov    %rdx,%rdi
  100b82:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  100b86:	e8 45 00 00 00       	callq  100bd0 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$8as_bytes17h7fd06f0442d64421E>
  100b8b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  100b8f:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  100b93:	48 8d 7d f0          	lea    -0x10(%rbp),%rdi
  100b97:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  100b9b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  100b9f:	e8 cc 16 00 00       	callq  102270 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE>
  100ba4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  100ba8:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  100bac:	48 89 01             	mov    %rax,(%rcx)
  100baf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  100bb3:	48 89 41 08          	mov    %rax,0x8(%rcx)
    }
  100bb7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  100bbb:	48 83 c4 50          	add    $0x50,%rsp
  100bbf:	5d                   	pop    %rbp
  100bc0:	c3                   	retq   

Disassembly of section .text._ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$8as_bytes17h7fd06f0442d64421E:

0000000000100bd0 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$8as_bytes17h7fd06f0442d64421E>:
            Some(&b) => (b as i8) >= -0x40,
        }
    }

    #[inline]
    fn as_bytes(&self) -> &[u8] {
  100bd0:	55                   	push   %rbp
  100bd1:	48 89 e5             	mov    %rsp,%rbp
  100bd4:	48 83 ec 40          	sub    $0x40,%rsp
  100bd8:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  100bdc:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  100be0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  100be4:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  100be8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  100bec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        unsafe { mem::transmute(self) }
  100bf0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  100bf4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  100bf8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  100bfc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  100c00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  100c04:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  100c08:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  100c0c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    }
  100c10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  100c14:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  100c18:	48 83 c4 40          	add    $0x40,%rsp
  100c1c:	5d                   	pop    %rbp
  100c1d:	c3                   	retq   

Disassembly of section .text._ZN41_$LT$u8$u20$as$u20$core..clone..Clone$GT$5clone17h9b566f05c3348106E:

0000000000100c20 <_ZN41_$LT$u8$u20$as$u20$core..clone..Clone$GT$5clone17h9b566f05c3348106E>:
    ($t:ty) => {
        #[stable(feature = "rust1", since = "1.0.0")]
        impl Clone for $t {
            /// Returns a deep copy of the value.
            #[inline]
            fn clone(&self) -> $t { *self }
  100c20:	55                   	push   %rbp
  100c21:	48 89 e5             	mov    %rsp,%rbp
  100c24:	48 83 ec 10          	sub    $0x10,%rsp
  100c28:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  100c2c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  100c30:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  100c34:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  100c38:	8a 07                	mov    (%rdi),%al
  100c3a:	48 83 c4 10          	add    $0x10,%rsp
  100c3e:	5d                   	pop    %rbp
  100c3f:	c3                   	retq   

Disassembly of section .text._ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE:

0000000000100c40 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE>:
        let ch = self as u32;
        if (ch & 0xFFFF) == ch { 1 } else { 2 }
    }

    #[inline]
    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {
  100c40:	55                   	push   %rbp
  100c41:	48 89 e5             	mov    %rsp,%rbp
  100c44:	53                   	push   %rbx
  100c45:	48 81 ec 38 02 00 00 	sub    $0x238,%rsp
  100c4c:	89 bd dc fe ff ff    	mov    %edi,-0x124(%rbp)
  100c52:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
  100c59:	48 89 95 e8 fe ff ff 	mov    %rdx,-0x118(%rbp)
  100c60:	8b bd dc fe ff ff    	mov    -0x124(%rbp),%edi
  100c66:	89 bd f4 fe ff ff    	mov    %edi,-0x10c(%rbp)
  100c6c:	48 8b 95 e0 fe ff ff 	mov    -0x120(%rbp),%rdx
  100c73:	48 8b b5 e8 fe ff ff 	mov    -0x118(%rbp),%rsi
  100c7a:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  100c81:	48 89 b5 00 ff ff ff 	mov    %rsi,-0x100(%rbp)
        let code = self as u32;
  100c88:	8b bd f4 fe ff ff    	mov    -0x10c(%rbp),%edi
  100c8e:	89 bd 0c ff ff ff    	mov    %edi,-0xf4(%rbp)
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
  100c94:	81 bd 0c ff ff ff 80 	cmpl   $0x80,-0xf4(%rbp)
  100c9b:	00 00 00 
  100c9e:	72 14                	jb     100cb4 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x74>
  100ca0:	eb 09                	jmp    100cab <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x6b>
  100ca2:	c6 85 1d ff ff ff 01 	movb   $0x1,-0xe3(%rbp)
  100ca9:	eb 24                	jmp    100ccf <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x8f>
  100cab:	c6 85 1d ff ff ff 00 	movb   $0x0,-0xe3(%rbp)
  100cb2:	eb 1b                	jmp    100ccf <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x8f>
  100cb4:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100cbb:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100cc2:	e8 19 14 00 00       	callq  1020e0 <_ZN4core5slice8SliceExt8is_empty17h1fd878a3ea2a5070E>
  100cc7:	88 85 db fe ff ff    	mov    %al,-0x125(%rbp)
  100ccd:	eb 0b                	jmp    100cda <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x9a>
  100ccf:	f6 85 1d ff ff ff 01 	testb  $0x1,-0xe3(%rbp)
  100cd6:	75 10                	jne    100ce8 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0xa8>
  100cd8:	eb 3a                	jmp    100d14 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0xd4>
  100cda:	8a 85 db fe ff ff    	mov    -0x125(%rbp),%al
  100ce0:	34 ff                	xor    $0xff,%al
  100ce2:	a8 01                	test   $0x1,%al
  100ce4:	75 bc                	jne    100ca2 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x62>
  100ce6:	eb c3                	jmp    100cab <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x6b>
  100ce8:	31 c0                	xor    %eax,%eax
  100cea:	89 c2                	mov    %eax,%edx
                *dst.get_unchecked_mut(0) = code as u8;
  100cec:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100cf2:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100cf9:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100d00:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%rbp)
  100d06:	e8 c5 14 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100d0b:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
  100d12:	eb 0e                	jmp    100d22 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0xe2>
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
  100d14:	81 bd 0c ff ff ff 00 	cmpl   $0x800,-0xf4(%rbp)
  100d1b:	08 00 00 
  100d1e:	72 35                	jb     100d55 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x115>
  100d20:	eb 2a                	jmp    100d4c <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x10c>
    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {
        let code = self as u32;
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
                *dst.get_unchecked_mut(0) = code as u8;
  100d22:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  100d28:	88 c1                	mov    %al,%cl
  100d2a:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  100d31:	88 0a                	mov    %cl,(%rdx)
                1
  100d33:	48 c7 85 10 ff ff ff 	movq   $0x1,-0xf0(%rbp)
  100d3a:	01 00 00 00 
    #[inline]
    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {
        let code = self as u32;
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
  100d3e:	e9 07 05 00 00       	jmpq   10124a <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x60a>
                *dst.get_unchecked_mut(0) = code as u8;
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
  100d43:	c6 85 1e ff ff ff 01 	movb   $0x1,-0xe2(%rbp)
  100d4a:	eb 25                	jmp    100d71 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x131>
  100d4c:	c6 85 1e ff ff ff 00 	movb   $0x0,-0xe2(%rbp)
  100d53:	eb 1c                	jmp    100d71 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x131>
  100d55:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100d5c:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100d63:	e8 b8 14 00 00       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  100d68:	48 89 85 c0 fe ff ff 	mov    %rax,-0x140(%rbp)
  100d6f:	eb 0b                	jmp    100d7c <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x13c>
  100d71:	f6 85 1e ff ff ff 01 	testb  $0x1,-0xe2(%rbp)
  100d78:	75 11                	jne    100d8b <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x14b>
  100d7a:	eb 43                	jmp    100dbf <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x17f>
  100d7c:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  100d83:	48 83 f8 02          	cmp    $0x2,%rax
  100d87:	73 ba                	jae    100d43 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x103>
  100d89:	eb c1                	jmp    100d4c <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x10c>
  100d8b:	31 c0                	xor    %eax,%eax
  100d8d:	89 c2                	mov    %eax,%edx
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
  100d8f:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100d95:	c1 e8 06             	shr    $0x6,%eax
  100d98:	83 e0 1f             	and    $0x1f,%eax
  100d9b:	88 c1                	mov    %al,%cl
  100d9d:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100da4:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100dab:	88 8d bf fe ff ff    	mov    %cl,-0x141(%rbp)
  100db1:	e8 1a 14 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100db6:	48 89 85 b0 fe ff ff 	mov    %rax,-0x150(%rbp)
  100dbd:	eb 0e                	jmp    100dcd <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x18d>
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
                2
            } else if code < MAX_THREE_B && dst.len() >= 3  {
  100dbf:	81 bd 0c ff ff ff 00 	cmpl   $0x10000,-0xf4(%rbp)
  100dc6:	00 01 00 
  100dc9:	72 79                	jb     100e44 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x204>
  100dcb:	eb 6e                	jmp    100e3b <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x1fb>
  100dcd:	b8 01 00 00 00       	mov    $0x1,%eax
  100dd2:	89 c2                	mov    %eax,%edx
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
                *dst.get_unchecked_mut(0) = code as u8;
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
  100dd4:	8a 8d bf fe ff ff    	mov    -0x141(%rbp),%cl
  100dda:	80 c9 c0             	or     $0xc0,%cl
  100ddd:	48 8b b5 b0 fe ff ff 	mov    -0x150(%rbp),%rsi
  100de4:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
  100de6:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100dec:	83 e0 3f             	and    $0x3f,%eax
  100def:	88 c1                	mov    %al,%cl
  100df1:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100df8:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100dff:	88 8d af fe ff ff    	mov    %cl,-0x151(%rbp)
  100e05:	e8 c6 13 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100e0a:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
  100e11:	8a 85 af fe ff ff    	mov    -0x151(%rbp),%al
  100e17:	0c 80                	or     $0x80,%al
  100e19:	48 8b 8d a0 fe ff ff 	mov    -0x160(%rbp),%rcx
  100e20:	88 01                	mov    %al,(%rcx)
                2
  100e22:	48 c7 85 10 ff ff ff 	movq   $0x2,-0xf0(%rbp)
  100e29:	02 00 00 00 
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
                *dst.get_unchecked_mut(0) = code as u8;
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
  100e2d:	e9 16 04 00 00       	jmpq   101248 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x608>
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
                2
            } else if code < MAX_THREE_B && dst.len() >= 3  {
  100e32:	c6 85 1f ff ff ff 01 	movb   $0x1,-0xe1(%rbp)
  100e39:	eb 25                	jmp    100e60 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x220>
  100e3b:	c6 85 1f ff ff ff 00 	movb   $0x0,-0xe1(%rbp)
  100e42:	eb 1c                	jmp    100e60 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x220>
  100e44:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100e4b:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100e52:	e8 c9 13 00 00       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  100e57:	48 89 85 98 fe ff ff 	mov    %rax,-0x168(%rbp)
  100e5e:	eb 0b                	jmp    100e6b <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x22b>
  100e60:	f6 85 1f ff ff ff 01 	testb  $0x1,-0xe1(%rbp)
  100e67:	75 11                	jne    100e7a <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x23a>
  100e69:	eb 43                	jmp    100eae <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x26e>
  100e6b:	48 8b 85 98 fe ff ff 	mov    -0x168(%rbp),%rax
  100e72:	48 83 f8 03          	cmp    $0x3,%rax
  100e76:	73 ba                	jae    100e32 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x1f2>
  100e78:	eb c1                	jmp    100e3b <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x1fb>
  100e7a:	31 c0                	xor    %eax,%eax
  100e7c:	89 c2                	mov    %eax,%edx
                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
  100e7e:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100e84:	c1 e8 0c             	shr    $0xc,%eax
  100e87:	83 e0 0f             	and    $0xf,%eax
  100e8a:	88 c1                	mov    %al,%cl
  100e8c:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100e93:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100e9a:	88 8d 97 fe ff ff    	mov    %cl,-0x169(%rbp)
  100ea0:	e8 2b 13 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100ea5:	48 89 85 88 fe ff ff 	mov    %rax,-0x178(%rbp)
  100eac:	eb 1f                	jmp    100ecd <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x28d>
                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;
                3
            } else if dst.len() >= 4 {
  100eae:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100eb5:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100ebc:	e8 5f 13 00 00       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  100ec1:	48 89 85 80 fe ff ff 	mov    %rax,-0x180(%rbp)
  100ec8:	e9 ac 00 00 00       	jmpq   100f79 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x339>
  100ecd:	b8 01 00 00 00       	mov    $0x1,%eax
  100ed2:	89 c2                	mov    %eax,%edx
            } else if code < MAX_TWO_B && dst.len() >= 2 {
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
                2
            } else if code < MAX_THREE_B && dst.len() >= 3  {
                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
  100ed4:	8a 8d 97 fe ff ff    	mov    -0x169(%rbp),%cl
  100eda:	80 c9 e0             	or     $0xe0,%cl
  100edd:	48 8b b5 88 fe ff ff 	mov    -0x178(%rbp),%rsi
  100ee4:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
  100ee6:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100eec:	c1 e8 06             	shr    $0x6,%eax
  100eef:	83 e0 3f             	and    $0x3f,%eax
  100ef2:	88 c1                	mov    %al,%cl
  100ef4:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100efb:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100f02:	88 8d 7f fe ff ff    	mov    %cl,-0x181(%rbp)
  100f08:	e8 c3 12 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100f0d:	48 89 85 70 fe ff ff 	mov    %rax,-0x190(%rbp)
  100f14:	b8 02 00 00 00       	mov    $0x2,%eax
  100f19:	89 c2                	mov    %eax,%edx
  100f1b:	8a 8d 7f fe ff ff    	mov    -0x181(%rbp),%cl
  100f21:	80 c9 80             	or     $0x80,%cl
  100f24:	48 8b b5 70 fe ff ff 	mov    -0x190(%rbp),%rsi
  100f2b:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;
  100f2d:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100f33:	83 e0 3f             	and    $0x3f,%eax
  100f36:	88 c1                	mov    %al,%cl
  100f38:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100f3f:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100f46:	88 8d 6f fe ff ff    	mov    %cl,-0x191(%rbp)
  100f4c:	e8 7f 12 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100f51:	48 89 85 60 fe ff ff 	mov    %rax,-0x1a0(%rbp)
  100f58:	8a 85 6f fe ff ff    	mov    -0x191(%rbp),%al
  100f5e:	0c 80                	or     $0x80,%al
  100f60:	48 8b 8d 60 fe ff ff 	mov    -0x1a0(%rbp),%rcx
  100f67:	88 01                	mov    %al,(%rcx)
                3
  100f69:	48 c7 85 10 ff ff ff 	movq   $0x3,-0xf0(%rbp)
  100f70:	03 00 00 00 
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
                2
            } else if code < MAX_THREE_B && dst.len() >= 3  {
  100f74:	e9 cd 02 00 00       	jmpq   101246 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x606>
                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;
                3
            } else if dst.len() >= 4 {
  100f79:	48 8b 85 80 fe ff ff 	mov    -0x180(%rbp),%rax
  100f80:	48 83 f8 04          	cmp    $0x4,%rax
  100f84:	72 34                	jb     100fba <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x37a>
  100f86:	31 c0                	xor    %eax,%eax
  100f88:	89 c2                	mov    %eax,%edx
                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
  100f8a:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  100f90:	c1 e8 12             	shr    $0x12,%eax
  100f93:	83 e0 07             	and    $0x7,%eax
  100f96:	88 c1                	mov    %al,%cl
  100f98:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  100f9f:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  100fa6:	88 8d 5f fe ff ff    	mov    %cl,-0x1a1(%rbp)
  100fac:	e8 1f 12 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  100fb1:	48 89 85 50 fe ff ff 	mov    %rax,-0x1b0(%rbp)
  100fb8:	eb 32                	jmp    100fec <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x3ac>
  100fba:	48 8d 05 4f 47 00 00 	lea    0x474f(%rip),%rax        # 105710 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf815__STATIC_FMTSTR17h275044e95b75fb02E>
                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
                4
            } else {
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
  100fc1:	48 8b 30             	mov    (%rax),%rsi
  100fc4:	48 8b 50 08          	mov    0x8(%rax),%rdx
                    from_u32_unchecked(code).len_utf8(),
  100fc8:	8b bd 0c ff ff ff    	mov    -0xf4(%rbp),%edi
  100fce:	48 89 b5 48 fe ff ff 	mov    %rsi,-0x1b8(%rbp)
  100fd5:	48 89 95 40 fe ff ff 	mov    %rdx,-0x1c0(%rbp)
  100fdc:	e8 8f 0f 00 00       	callq  101f70 <_ZN4core4char18from_u32_unchecked17h1116433b5fe7ca01E>
  100fe1:	89 85 3c fe ff ff    	mov    %eax,-0x1c4(%rbp)
  100fe7:	e9 f3 00 00 00       	jmpq   1010df <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x49f>
  100fec:	b8 01 00 00 00       	mov    $0x1,%eax
  100ff1:	89 c2                	mov    %eax,%edx
                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;
                3
            } else if dst.len() >= 4 {
                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
  100ff3:	8a 8d 5f fe ff ff    	mov    -0x1a1(%rbp),%cl
  100ff9:	80 c9 f0             	or     $0xf0,%cl
  100ffc:	48 8b b5 50 fe ff ff 	mov    -0x1b0(%rbp),%rsi
  101003:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;
  101005:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  10100b:	c1 e8 0c             	shr    $0xc,%eax
  10100e:	83 e0 3f             	and    $0x3f,%eax
  101011:	88 c1                	mov    %al,%cl
  101013:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  10101a:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  101021:	88 8d 3b fe ff ff    	mov    %cl,-0x1c5(%rbp)
  101027:	e8 a4 11 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  10102c:	48 89 85 30 fe ff ff 	mov    %rax,-0x1d0(%rbp)
  101033:	b8 02 00 00 00       	mov    $0x2,%eax
  101038:	89 c2                	mov    %eax,%edx
  10103a:	8a 8d 3b fe ff ff    	mov    -0x1c5(%rbp),%cl
  101040:	80 c9 80             	or     $0x80,%cl
  101043:	48 8b b5 30 fe ff ff 	mov    -0x1d0(%rbp),%rsi
  10104a:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
  10104c:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  101052:	c1 e8 06             	shr    $0x6,%eax
  101055:	83 e0 3f             	and    $0x3f,%eax
  101058:	88 c1                	mov    %al,%cl
  10105a:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  101061:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  101068:	88 8d 2f fe ff ff    	mov    %cl,-0x1d1(%rbp)
  10106e:	e8 5d 11 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  101073:	48 89 85 20 fe ff ff 	mov    %rax,-0x1e0(%rbp)
  10107a:	b8 03 00 00 00       	mov    $0x3,%eax
  10107f:	89 c2                	mov    %eax,%edx
  101081:	8a 8d 2f fe ff ff    	mov    -0x1d1(%rbp),%cl
  101087:	80 c9 80             	or     $0x80,%cl
  10108a:	48 8b b5 20 fe ff ff 	mov    -0x1e0(%rbp),%rsi
  101091:	88 0e                	mov    %cl,(%rsi)
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
  101093:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  101099:	83 e0 3f             	and    $0x3f,%eax
  10109c:	88 c1                	mov    %al,%cl
  10109e:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  1010a5:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  1010ac:	88 8d 1f fe ff ff    	mov    %cl,-0x1e1(%rbp)
  1010b2:	e8 19 11 00 00       	callq  1021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>
  1010b7:	48 89 85 10 fe ff ff 	mov    %rax,-0x1f0(%rbp)
  1010be:	8a 85 1f fe ff ff    	mov    -0x1e1(%rbp),%al
  1010c4:	0c 80                	or     $0x80,%al
  1010c6:	48 8b 8d 10 fe ff ff 	mov    -0x1f0(%rbp),%rcx
  1010cd:	88 01                	mov    %al,(%rcx)
                4
  1010cf:	48 c7 85 10 ff ff ff 	movq   $0x4,-0xf0(%rbp)
  1010d6:	04 00 00 00 
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;
                2
            } else if code < MAX_THREE_B && dst.len() >= 3  {
  1010da:	e9 67 01 00 00       	jmpq   101246 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x606>
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
                4
            } else {
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
                    from_u32_unchecked(code).len_utf8(),
  1010df:	8b bd 3c fe ff ff    	mov    -0x1c4(%rbp),%edi
  1010e5:	e8 d6 01 00 00       	callq  1012c0 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E>
  1010ea:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                    code,
                    dst.len())
  1010ee:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  1010f5:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  1010fc:	e8 1f 11 00 00       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  101101:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  101105:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
  101109:	48 8d 15 10 40 00 00 	lea    0x4010(%rip),%rdx        # 105120 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E>
  101110:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  101114:	48 8d 8d 0c ff ff ff 	lea    -0xf4(%rbp),%rcx
  10111b:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
                4
            } else {
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
  10111f:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  101123:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
  101127:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                    from_u32_unchecked(code).len_utf8(),
  10112b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  10112f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                    code,
  101133:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  101137:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
                    dst.len())
  10113b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  10113f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
                4
            } else {
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
                    from_u32_unchecked(code).len_utf8(),
  101143:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
        // used inside a dead function. Just `#[allow(dead_code)]` is
        // insufficient, since the user may have
        // `#[forbid(dead_code)]` and which cannot be overridden.
        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =
            (file!(), line!(), column!());
        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)
  101147:	e8 84 03 00 00       	callq  1014d0 <_ZN4core3fmt10ArgumentV13new17hcf1b02208907f0a6E>
  10114c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  101150:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  101154:	48 89 85 08 fe ff ff 	mov    %rax,-0x1f8(%rbp)
  10115b:	48 89 8d 00 fe ff ff 	mov    %rcx,-0x200(%rbp)
  101162:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  101166:	48 8d 15 73 3d 00 00 	lea    0x3d73(%rip),%rdx        # 104ee0 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE>
                    code,
  10116d:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  101171:	e8 ea 02 00 00       	callq  101460 <_ZN4core3fmt10ArgumentV13new17h814b7fa3979677f3E>
  101176:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  10117a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  10117e:	48 89 95 f8 fd ff ff 	mov    %rdx,-0x208(%rbp)
  101185:	48 89 b5 f0 fd ff ff 	mov    %rsi,-0x210(%rbp)
  10118c:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
  101190:	48 8d 15 89 3f 00 00 	lea    0x3f89(%rip),%rdx        # 105120 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E>
                    dst.len())
  101197:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  10119b:	e8 30 03 00 00       	callq  1014d0 <_ZN4core3fmt10ArgumentV13new17hcf1b02208907f0a6E>
  1011a0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1011a4:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  1011a8:	48 89 95 e8 fd ff ff 	mov    %rdx,-0x218(%rbp)
  1011af:	48 89 b5 e0 fd ff ff 	mov    %rsi,-0x220(%rbp)
  1011b6:	48 8d bd 20 ff ff ff 	lea    -0xe0(%rbp),%rdi
  1011bd:	b8 03 00 00 00       	mov    $0x3,%eax
  1011c2:	41 89 c0             	mov    %eax,%r8d
  1011c5:	48 8d 8d 50 ff ff ff 	lea    -0xb0(%rbp),%rcx
                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;
                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;
                4
            } else {
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
  1011cc:	48 8b 95 08 fe ff ff 	mov    -0x1f8(%rbp),%rdx
  1011d3:	48 89 95 50 ff ff ff 	mov    %rdx,-0xb0(%rbp)
  1011da:	48 8b b5 00 fe ff ff 	mov    -0x200(%rbp),%rsi
  1011e1:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  1011e8:	4c 8b 8d f8 fd ff ff 	mov    -0x208(%rbp),%r9
  1011ef:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
  1011f6:	4c 8b 95 f0 fd ff ff 	mov    -0x210(%rbp),%r10
  1011fd:	4c 89 95 68 ff ff ff 	mov    %r10,-0x98(%rbp)
  101204:	4c 8b 9d e8 fd ff ff 	mov    -0x218(%rbp),%r11
  10120b:	4c 89 9d 70 ff ff ff 	mov    %r11,-0x90(%rbp)
  101212:	48 8b 9d e0 fd ff ff 	mov    -0x220(%rbp),%rbx
  101219:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
  101220:	48 8b b5 48 fe ff ff 	mov    -0x1b8(%rbp),%rsi
  101227:	48 8b 95 40 fe ff ff 	mov    -0x1c0(%rbp),%rdx
  10122e:	e8 bd 04 00 00       	callq  1016f0 <_ZN4core3fmt9Arguments6new_v117h11103d15dd9d6a08E>
  101233:	48 8d bd 20 ff ff ff 	lea    -0xe0(%rbp),%rdi
  10123a:	48 8d 35 0f 45 00 00 	lea    0x450f(%rip),%rsi        # 105750 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf818_MSG_FILE_LINE_COL17h18b295d3e951b22dE>
  101241:	e8 4a 30 00 00       	callq  104290 <_ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E>
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
                *dst.get_unchecked_mut(0) = code as u8;
                1
            } else if code < MAX_TWO_B && dst.len() >= 2 {
  101246:	eb 00                	jmp    101248 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x608>
    #[inline]
    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {
        let code = self as u32;
        unsafe {
            let len =
            if code < MAX_ONE_B && !dst.is_empty() {
  101248:	eb 00                	jmp    10124a <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE+0x60a>
                panic!("encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}",
                    from_u32_unchecked(code).len_utf8(),
                    code,
                    dst.len())
            };
            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))
  10124a:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
  101251:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
  101258:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  10125f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  101263:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  101267:	e8 f4 0e 00 00       	callq  102160 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17h76a470b3405b37a9E>
  10126c:	48 89 85 d8 fd ff ff 	mov    %rax,-0x228(%rbp)
  101273:	48 89 95 d0 fd ff ff 	mov    %rdx,-0x230(%rbp)
  10127a:	48 8b bd d8 fd ff ff 	mov    -0x228(%rbp),%rdi
  101281:	48 8b b5 d0 fd ff ff 	mov    -0x230(%rbp),%rsi
  101288:	e8 93 0c 00 00       	callq  101f20 <_ZN4core3str23from_utf8_unchecked_mut17hff78b68e1dcadaeaE>
  10128d:	48 89 85 c8 fd ff ff 	mov    %rax,-0x238(%rbp)
  101294:	48 89 95 c0 fd ff ff 	mov    %rdx,-0x240(%rbp)
        }
    }
  10129b:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  1012a2:	48 8b 95 c0 fd ff ff 	mov    -0x240(%rbp),%rdx
  1012a9:	48 81 c4 38 02 00 00 	add    $0x238,%rsp
  1012b0:	5b                   	pop    %rbx
  1012b1:	5d                   	pop    %rbp
  1012b2:	c3                   	retq   

Disassembly of section .text._ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E:

00000000001012c0 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E>:
        };
        EscapeDebug(EscapeDefault { state: init_state })
    }

    #[inline]
    fn len_utf8(self) -> usize {
  1012c0:	55                   	push   %rbp
  1012c1:	48 89 e5             	mov    %rsp,%rbp
  1012c4:	48 83 ec 18          	sub    $0x18,%rsp
  1012c8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  1012cb:	8b 7d ec             	mov    -0x14(%rbp),%edi
  1012ce:	89 7d f8             	mov    %edi,-0x8(%rbp)
        let code = self as u32;
  1012d1:	8b 7d f8             	mov    -0x8(%rbp),%edi
  1012d4:	89 7d fc             	mov    %edi,-0x4(%rbp)
        if code < MAX_ONE_B {
  1012d7:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%rbp)
  1012de:	73 0a                	jae    1012ea <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x2a>
            1
  1012e0:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  1012e7:	00 
    }

    #[inline]
    fn len_utf8(self) -> usize {
        let code = self as u32;
        if code < MAX_ONE_B {
  1012e8:	eb 32                	jmp    10131c <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x5c>
            1
        } else if code < MAX_TWO_B {
  1012ea:	81 7d fc 00 08 00 00 	cmpl   $0x800,-0x4(%rbp)
  1012f1:	73 0a                	jae    1012fd <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x3d>
            2
  1012f3:	48 c7 45 f0 02 00 00 	movq   $0x2,-0x10(%rbp)
  1012fa:	00 
    #[inline]
    fn len_utf8(self) -> usize {
        let code = self as u32;
        if code < MAX_ONE_B {
            1
        } else if code < MAX_TWO_B {
  1012fb:	eb 1d                	jmp    10131a <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x5a>
            2
        } else if code < MAX_THREE_B {
  1012fd:	81 7d fc 00 00 01 00 	cmpl   $0x10000,-0x4(%rbp)
  101304:	73 0a                	jae    101310 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x50>
            3
  101306:	48 c7 45 f0 03 00 00 	movq   $0x3,-0x10(%rbp)
  10130d:	00 
        let code = self as u32;
        if code < MAX_ONE_B {
            1
        } else if code < MAX_TWO_B {
            2
        } else if code < MAX_THREE_B {
  10130e:	eb 08                	jmp    101318 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x58>
            3
        } else {
            4
  101310:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  101317:	00 
    #[inline]
    fn len_utf8(self) -> usize {
        let code = self as u32;
        if code < MAX_ONE_B {
            1
        } else if code < MAX_TWO_B {
  101318:	eb 00                	jmp    10131a <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x5a>
    }

    #[inline]
    fn len_utf8(self) -> usize {
        let code = self as u32;
        if code < MAX_ONE_B {
  10131a:	eb 00                	jmp    10131c <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$8len_utf817h8d5951fc06070f31E+0x5c>
        } else if code < MAX_THREE_B {
            3
        } else {
            4
        }
    }
  10131c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  101320:	48 83 c4 18          	add    $0x18,%rsp
  101324:	5d                   	pop    %rbp
  101325:	c3                   	retq   

Disassembly of section .text._ZN45_$LT$u32$u20$as$u20$core..ops..arith..Add$GT$3add17h1da93cbf670b3f20E:

0000000000101330 <_ZN45_$LT$u32$u20$as$u20$core..ops..arith..Add$GT$3add17h1da93cbf670b3f20E>:
        impl Add for $t {
            type Output = $t;

            #[inline]
            #[rustc_inherit_overflow_checks]
            fn add(self, other: $t) -> $t { self + other }
  101330:	55                   	push   %rbp
  101331:	48 89 e5             	mov    %rsp,%rbp
  101334:	48 83 ec 20          	sub    $0x20,%rsp
  101338:	89 7d f0             	mov    %edi,-0x10(%rbp)
  10133b:	89 75 f4             	mov    %esi,-0xc(%rbp)
  10133e:	8b 75 f0             	mov    -0x10(%rbp),%esi
  101341:	89 75 f8             	mov    %esi,-0x8(%rbp)
  101344:	8b 75 f4             	mov    -0xc(%rbp),%esi
  101347:	89 75 fc             	mov    %esi,-0x4(%rbp)
  10134a:	8b 75 f8             	mov    -0x8(%rbp),%esi
  10134d:	03 75 fc             	add    -0x4(%rbp),%esi
  101350:	0f 92 c0             	setb   %al
  101353:	a8 01                	test   $0x1,%al
  101355:	89 75 ec             	mov    %esi,-0x14(%rbp)
  101358:	75 09                	jne    101363 <_ZN45_$LT$u32$u20$as$u20$core..ops..arith..Add$GT$3add17h1da93cbf670b3f20E+0x33>
  10135a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  10135d:	48 83 c4 20          	add    $0x20,%rsp
  101361:	5d                   	pop    %rbp
  101362:	c3                   	retq   
  101363:	48 8d 05 1e 3f 00 00 	lea    0x3f1e(%rip),%rax        # 105288 <panic_loc.2>
  10136a:	48 89 c7             	mov    %rax,%rdi
  10136d:	e8 2e 2e 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN47_$LT$u32$u20$as$u20$core..iter..range..Step$GT$7add_one17hb9c6498dc4559fb8E:

0000000000101380 <_ZN47_$LT$u32$u20$as$u20$core..iter..range..Step$GT$7add_one17hb9c6498dc4559fb8E>:
        fn replace_zero(&mut self) -> Self {
            mem::replace(self, 0)
        }

        #[inline]
        fn add_one(&self) -> Self {
  101380:	55                   	push   %rbp
  101381:	48 89 e5             	mov    %rsp,%rbp
  101384:	48 83 ec 20          	sub    $0x20,%rsp
  101388:	be 01 00 00 00       	mov    $0x1,%esi
  10138d:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  101391:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  101395:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
            Add::add(*self, 1)
  101399:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  10139d:	8b 3f                	mov    (%rdi),%edi
  10139f:	e8 8c ff ff ff       	callq  101330 <_ZN45_$LT$u32$u20$as$u20$core..ops..arith..Add$GT$3add17h1da93cbf670b3f20E>
  1013a4:	89 45 ec             	mov    %eax,-0x14(%rbp)
        }
  1013a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  1013aa:	48 83 c4 20          	add    $0x20,%rsp
  1013ae:	5d                   	pop    %rbp
  1013af:	c3                   	retq   

Disassembly of section .text._ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u32$GT$2lt17h121ef3e0591effabE:

00000000001013b0 <_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u32$GT$2lt17h121ef3e0591effabE>:
                #[inline]
                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
                #[inline]
                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }
  1013b0:	55                   	push   %rbp
  1013b1:	48 89 e5             	mov    %rsp,%rbp
  1013b4:	48 83 ec 20          	sub    $0x20,%rsp
  1013b8:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  1013bc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  1013c0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1013c4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1013c8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  1013cc:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  1013d0:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  1013d4:	8b 06                	mov    (%rsi),%eax
  1013d6:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  1013da:	3b 06                	cmp    (%rsi),%eax
  1013dc:	0f 92 c1             	setb   %cl
  1013df:	80 e1 01             	and    $0x1,%cl
  1013e2:	0f b6 c1             	movzbl %cl,%eax
  1013e5:	48 83 c4 20          	add    $0x20,%rsp
  1013e9:	5d                   	pop    %rbp
  1013ea:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt10ArgumentV13new17h09e3b96240765f15E:

00000000001013f0 <_ZN4core3fmt10ArgumentV13new17h09e3b96240765f15E>:
    }

    #[doc(hidden)]
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
  1013f0:	55                   	push   %rbp
  1013f1:	48 89 e5             	mov    %rsp,%rbp
  1013f4:	48 83 ec 50          	sub    $0x50,%rsp
  1013f8:	48 89 f8             	mov    %rdi,%rax
  1013fb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  1013ff:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  101403:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  101407:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
  10140b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  10140f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        unsafe {
            ArgumentV1 {
                formatter: mem::transmute(f),
  101413:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  101417:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  10141b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  10141f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  101423:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  101427:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
                value: mem::transmute(x)
  10142b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  10142f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  101433:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101437:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
        unsafe {
            ArgumentV1 {
  10143b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  10143f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  101443:	48 89 08             	mov    %rcx,(%rax)
  101446:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  10144a:	48 89 50 08          	mov    %rdx,0x8(%rax)
                formatter: mem::transmute(f),
                value: mem::transmute(x)
            }
        }
    }
  10144e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  101452:	48 83 c4 50          	add    $0x50,%rsp
  101456:	5d                   	pop    %rbp
  101457:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt10ArgumentV13new17h814b7fa3979677f3E:

0000000000101460 <_ZN4core3fmt10ArgumentV13new17h814b7fa3979677f3E>:
    }

    #[doc(hidden)]
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
  101460:	55                   	push   %rbp
  101461:	48 89 e5             	mov    %rsp,%rbp
  101464:	48 83 ec 50          	sub    $0x50,%rsp
  101468:	48 89 f8             	mov    %rdi,%rax
  10146b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10146f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  101473:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  101477:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
  10147b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  10147f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        unsafe {
            ArgumentV1 {
                formatter: mem::transmute(f),
  101483:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  101487:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  10148b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  10148f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  101493:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  101497:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
                value: mem::transmute(x)
  10149b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  10149f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  1014a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1014a7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
        unsafe {
            ArgumentV1 {
  1014ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1014af:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  1014b3:	48 89 08             	mov    %rcx,(%rax)
  1014b6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  1014ba:	48 89 50 08          	mov    %rdx,0x8(%rax)
                formatter: mem::transmute(f),
                value: mem::transmute(x)
            }
        }
    }
  1014be:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  1014c2:	48 83 c4 50          	add    $0x50,%rsp
  1014c6:	5d                   	pop    %rbp
  1014c7:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt10ArgumentV13new17hcf1b02208907f0a6E:

00000000001014d0 <_ZN4core3fmt10ArgumentV13new17hcf1b02208907f0a6E>:
    }

    #[doc(hidden)]
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
  1014d0:	55                   	push   %rbp
  1014d1:	48 89 e5             	mov    %rsp,%rbp
  1014d4:	48 83 ec 50          	sub    $0x50,%rsp
  1014d8:	48 89 f8             	mov    %rdi,%rax
  1014db:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  1014df:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  1014e3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  1014e7:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
  1014eb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1014ef:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        unsafe {
            ArgumentV1 {
                formatter: mem::transmute(f),
  1014f3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1014f7:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  1014fb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1014ff:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  101503:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  101507:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
                value: mem::transmute(x)
  10150b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  10150f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  101513:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101517:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new<'b, T>(x: &'b T,
                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {
        unsafe {
            ArgumentV1 {
  10151b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  10151f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  101523:	48 89 08             	mov    %rcx,(%rax)
  101526:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  10152a:	48 89 50 08          	mov    %rdx,0x8(%rax)
                formatter: mem::transmute(f),
                value: mem::transmute(x)
            }
        }
    }
  10152e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  101532:	48 83 c4 50          	add    $0x50,%rsp
  101536:	5d                   	pop    %rbp
  101537:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt5Write10write_char17h480b182123224c78E:

0000000000101540 <_ZN4core3fmt5Write10write_char17h480b182123224c78E>:
    /// writer(&mut buf, 'a').unwrap();
    /// writer(&mut buf, 'b').unwrap();
    /// assert_eq!(&buf, "ab");
    /// ```
    #[stable(feature = "fmt_write_char", since = "1.1.0")]
    fn write_char(&mut self, c: char) -> Result {
  101540:	55                   	push   %rbp
  101541:	48 89 e5             	mov    %rsp,%rbp
  101544:	48 83 ec 70          	sub    $0x70,%rsp
  101548:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  10154c:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  101550:	89 75 dc             	mov    %esi,-0x24(%rbp)
  101553:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  101557:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  10155b:	8b 75 dc             	mov    -0x24(%rbp),%esi
  10155e:	89 75 f4             	mov    %esi,-0xc(%rbp)
        self.write_str(c.encode_utf8(&mut [0; 4]))
  101561:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  101565:	8b 75 f4             	mov    -0xc(%rbp),%esi
  101568:	48 89 c1             	mov    %rax,%rcx
  10156b:	48 83 c1 04          	add    $0x4,%rcx
  10156f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  101573:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  101577:	89 75 bc             	mov    %esi,-0x44(%rbp)
  10157a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  10157e:	eb 58                	jmp    1015d8 <_ZN4core3fmt5Write10write_char17h480b182123224c78E+0x98>
  101580:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  101584:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  101588:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  10158c:	e8 0f 1b 00 00       	callq  1030a0 <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE>
  101591:	88 45 ff             	mov    %al,-0x1(%rbp)
  101594:	8a 45 ff             	mov    -0x1(%rbp),%al
  101597:	88 45 e0             	mov    %al,-0x20(%rbp)
    }
  10159a:	8a 45 e0             	mov    -0x20(%rbp),%al
  10159d:	48 83 c4 70          	add    $0x70,%rsp
  1015a1:	5d                   	pop    %rbp
  1015a2:	c3                   	retq   
  1015a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  1015a7:	48 83 c0 01          	add    $0x1,%rax
  1015ab:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  1015af:	c6 01 00             	movb   $0x0,(%rcx)
  1015b2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  1015b6:	eb 20                	jmp    1015d8 <_ZN4core3fmt5Write10write_char17h480b182123224c78E+0x98>
  1015b8:	b8 04 00 00 00       	mov    $0x4,%eax
  1015bd:	89 c2                	mov    %eax,%edx
  1015bf:	48 8d 4d fb          	lea    -0x5(%rbp),%rcx
    /// writer(&mut buf, 'b').unwrap();
    /// assert_eq!(&buf, "ab");
    /// ```
    #[stable(feature = "fmt_write_char", since = "1.1.0")]
    fn write_char(&mut self, c: char) -> Result {
        self.write_str(c.encode_utf8(&mut [0; 4]))
  1015c3:	8b 7d bc             	mov    -0x44(%rbp),%edi
  1015c6:	48 89 ce             	mov    %rcx,%rsi
  1015c9:	e8 72 f6 ff ff       	callq  100c40 <_ZN44_$LT$char$u20$as$u20$core..char..CharExt$GT$11encode_utf817h23e5a7021c6aba4aE>
  1015ce:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  1015d2:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  1015d6:	eb a8                	jmp    101580 <_ZN4core3fmt5Write10write_char17h480b182123224c78E+0x40>
  1015d8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  1015dc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  1015e0:	48 39 c8             	cmp    %rcx,%rax
  1015e3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  1015e7:	75 ba                	jne    1015a3 <_ZN4core3fmt5Write10write_char17h480b182123224c78E+0x63>
  1015e9:	eb cd                	jmp    1015b8 <_ZN4core3fmt5Write10write_char17h480b182123224c78E+0x78>

Disassembly of section .text._ZN4core3fmt5Write9write_fmt17h78c8cffd92df3f60E:

00000000001015f0 <_ZN4core3fmt5Write9write_fmt17h78c8cffd92df3f60E>:
    /// let mut buf = String::new();
    /// writer(&mut buf, "world").unwrap();
    /// assert_eq!(&buf, "world");
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    fn write_fmt(&mut self, args: Arguments) -> Result {
  1015f0:	55                   	push   %rbp
  1015f1:	48 89 e5             	mov    %rsp,%rbp
  1015f4:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  1015fb:	48 8d 05 d6 3c 00 00 	lea    0x3cd6(%rip),%rax        # 1052d8 <vtable.3>
  101602:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  101606:	ba 30 00 00 00       	mov    $0x30,%edx
  10160b:	41 89 d0             	mov    %edx,%r8d
  10160e:	4c 8d 4d 90          	lea    -0x70(%rbp),%r9
  101612:	4c 8d 55 c0          	lea    -0x40(%rbp),%r10
  101616:	4c 8d 9d 50 ff ff ff 	lea    -0xb0(%rbp),%r11
  10161d:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
  101624:	4c 89 df             	mov    %r11,%rdi
  101627:	4c 89 c2             	mov    %r8,%rdx
  10162a:	4c 89 9d 40 ff ff ff 	mov    %r11,-0xc0(%rbp)
  101631:	4c 89 95 38 ff ff ff 	mov    %r10,-0xc8(%rbp)
  101638:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  10163f:	48 89 8d 28 ff ff ff 	mov    %rcx,-0xd8(%rbp)
  101646:	4c 89 85 20 ff ff ff 	mov    %r8,-0xe0(%rbp)
  10164d:	4c 89 8d 18 ff ff ff 	mov    %r9,-0xe8(%rbp)
  101654:	e8 97 2a 00 00       	callq  1040f0 <memcpy>
  101659:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  101660:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  101664:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  10166b:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  101672:	48 89 cf             	mov    %rcx,%rdi
  101675:	48 89 c6             	mov    %rax,%rsi
  101678:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  10167f:	e8 6c 2a 00 00       	callq  1040f0 <memcpy>
            fn write_fmt(&mut self, args: Arguments) -> Result {
                self.0.write_fmt(args)
            }
        }

        write(&mut Adapter(self), args)
  101684:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  101688:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  10168c:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  101693:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  10169a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  1016a1:	48 89 d7             	mov    %rdx,%rdi
  1016a4:	48 89 ce             	mov    %rcx,%rsi
  1016a7:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  1016ae:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  1016b5:	e8 36 2a 00 00       	callq  1040f0 <memcpy>
  1016ba:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  1016c1:	48 89 c7             	mov    %rax,%rdi
  1016c4:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
  1016cb:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  1016d2:	e8 e9 2d 00 00       	callq  1044c0 <_ZN4core3fmt5write17ha9482bb577c609d2E>
  1016d7:	88 45 ff             	mov    %al,-0x1(%rbp)
  1016da:	8a 45 ff             	mov    -0x1(%rbp),%al
  1016dd:	88 45 80             	mov    %al,-0x80(%rbp)
    }
  1016e0:	8a 45 80             	mov    -0x80(%rbp),%al
  1016e3:	48 81 c4 f0 00 00 00 	add    $0xf0,%rsp
  1016ea:	5d                   	pop    %rbp
  1016eb:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt9Arguments6new_v117h11103d15dd9d6a08E:

00000000001016f0 <_ZN4core3fmt9Arguments6new_v117h11103d15dd9d6a08E>:
    /// When using the format_args!() macro, this function is used to generate the
    /// Arguments structure.
    #[doc(hidden)] #[inline]
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new_v1(pieces: &'a [&'a str],
  1016f0:	55                   	push   %rbp
  1016f1:	48 89 e5             	mov    %rsp,%rbp
  1016f4:	48 83 ec 50          	sub    $0x50,%rsp
  1016f8:	48 89 f8             	mov    %rdi,%rax
  1016fb:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  1016ff:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  101703:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  101707:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  10170b:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  10170f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  101713:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  101717:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {
  10171b:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  10171f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  101723:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  101727:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        Arguments {
            pieces: pieces,
  10172b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  10172f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
            fmt: None,
  101733:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  10173a:	00 
            args: args
  10173b:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  10173f:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
    #[doc(hidden)] #[inline]
    #[unstable(feature = "fmt_internals", reason = "internal to format_args!",
               issue = "0")]
    pub fn new_v1(pieces: &'a [&'a str],
                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {
        Arguments {
  101743:	48 89 0f             	mov    %rcx,(%rdi)
  101746:	48 89 57 08          	mov    %rdx,0x8(%rdi)
  10174a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  10174e:	48 89 4f 10          	mov    %rcx,0x10(%rdi)
  101752:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  101756:	48 89 4f 18          	mov    %rcx,0x18(%rdi)
  10175a:	48 89 77 20          	mov    %rsi,0x20(%rdi)
  10175e:	4c 89 47 28          	mov    %r8,0x28(%rdi)
            pieces: pieces,
            fmt: None,
            args: args
        }
    }
  101762:	48 83 c4 50          	add    $0x50,%rsp
  101766:	5d                   	pop    %rbp
  101767:	c3                   	retq   

Disassembly of section .text._ZN4core3mem13uninitialized17hf20c4c0f754b61a5E:

0000000000101770 <_ZN4core3mem13uninitialized17hf20c4c0f754b61a5E>:
/// [copy]: ../intrinsics/fn.copy.html
/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html
/// [`Drop`]: ../ops/trait.Drop.html
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub unsafe fn uninitialized<T>() -> T {
  101770:	55                   	push   %rbp
  101771:	48 89 e5             	mov    %rsp,%rbp
    intrinsics::uninit()
  101774:	50                   	push   %rax
  101775:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  101779:	eb 00                	jmp    10177b <_ZN4core3mem13uninitialized17hf20c4c0f754b61a5E+0xb>
}
  10177b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10177f:	48 83 c4 08          	add    $0x8,%rsp
  101783:	5d                   	pop    %rbp
  101784:	c3                   	retq   

Disassembly of section .text._ZN4core3mem13uninitialized17hf5bdda434fdf5afcE:

0000000000101790 <_ZN4core3mem13uninitialized17hf5bdda434fdf5afcE>:
/// [copy]: ../intrinsics/fn.copy.html
/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html
/// [`Drop`]: ../ops/trait.Drop.html
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub unsafe fn uninitialized<T>() -> T {
  101790:	55                   	push   %rbp
  101791:	48 89 e5             	mov    %rsp,%rbp
  101794:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
  101798:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
  10179f:	48 89 f8             	mov    %rdi,%rax
    intrinsics::uninit()
  1017a2:	48 8b 4c 24 58       	mov    0x58(%rsp),%rcx
  1017a7:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  1017ac:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  1017b1:	4c 8b 44 24 48       	mov    0x48(%rsp),%r8
  1017b6:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  1017bb:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  1017c0:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  1017c5:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  1017ca:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  1017cf:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
}
  1017d4:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  1017d9:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
  1017de:	48 89 08             	mov    %rcx,(%rax)
  1017e1:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  1017e6:	48 89 50 08          	mov    %rdx,0x8(%rax)
  1017ea:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  1017ef:	48 89 70 10          	mov    %rsi,0x10(%rax)
  1017f3:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  1017f8:	48 89 78 18          	mov    %rdi,0x18(%rax)
  1017fc:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  101801:	48 89 ec             	mov    %rbp,%rsp
  101804:	5d                   	pop    %rbp
  101805:	c3                   	retq   

Disassembly of section .text._ZN4core3mem4swap17h5e573d5e27a5ae9cE:

0000000000101810 <_ZN4core3mem4swap17h5e573d5e27a5ae9cE>:
/// assert_eq!(42, x);
/// assert_eq!(5, y);
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn swap<T>(x: &mut T, y: &mut T) {
  101810:	55                   	push   %rbp
  101811:	48 89 e5             	mov    %rsp,%rbp
  101814:	48 83 ec 20          	sub    $0x20,%rsp
  101818:	b8 01 00 00 00       	mov    $0x1,%eax
  10181d:	89 c2                	mov    %eax,%edx
  10181f:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  101823:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  101827:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  10182b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10182f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  101833:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
    unsafe {
        ptr::swap_nonoverlapping(x, y, 1);
  101837:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  10183b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  10183f:	e8 0c 01 00 00       	callq  101950 <_ZN4core3ptr19swap_nonoverlapping17h5ef043214e129f0aE>
    }
}
  101844:	48 83 c4 20          	add    $0x20,%rsp
  101848:	5d                   	pop    %rbp
  101849:	c3                   	retq   

Disassembly of section .text._ZN4core3mem7size_of17h0decfa33ec745297E:

0000000000101850 <_ZN4core3mem7size_of17h0decfa33ec745297E>:
/// assert_eq!(4, mem::size_of::<i32>());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg(not(stage0))]
pub const fn size_of<T>() -> usize {
  101850:	55                   	push   %rbp
  101851:	48 89 e5             	mov    %rsp,%rbp
    unsafe { intrinsics::size_of::<T>() }
  101854:	48 83 ec 10          	sub    $0x10,%rsp
  101858:	48 c7 45 f8 01 00 00 	movq   $0x1,-0x8(%rbp)
  10185f:	00 
  101860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101864:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  101868:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10186c:	48 83 c4 10          	add    $0x10,%rsp
  101870:	5d                   	pop    %rbp
  101871:	c3                   	retq   

Disassembly of section .text._ZN4core3mem7size_of17h2a0b979ce20d266aE:

0000000000101880 <_ZN4core3mem7size_of17h2a0b979ce20d266aE>:
/// assert_eq!(4, mem::size_of::<i32>());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg(not(stage0))]
pub const fn size_of<T>() -> usize {
  101880:	55                   	push   %rbp
  101881:	48 89 e5             	mov    %rsp,%rbp
    unsafe { intrinsics::size_of::<T>() }
  101884:	48 83 ec 10          	sub    $0x10,%rsp
  101888:	48 c7 45 f8 10 00 00 	movq   $0x10,-0x8(%rbp)
  10188f:	00 
  101890:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101894:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  101898:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10189c:	48 83 c4 10          	add    $0x10,%rsp
  1018a0:	5d                   	pop    %rbp
  1018a1:	c3                   	retq   

Disassembly of section .text._ZN4core3mem7size_of17h2ff42b01fb7b57d7E:

00000000001018b0 <_ZN4core3mem7size_of17h2ff42b01fb7b57d7E>:
/// assert_eq!(4, mem::size_of::<i32>());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg(not(stage0))]
pub const fn size_of<T>() -> usize {
  1018b0:	55                   	push   %rbp
  1018b1:	48 89 e5             	mov    %rsp,%rbp
    unsafe { intrinsics::size_of::<T>() }
  1018b4:	48 83 ec 10          	sub    $0x10,%rsp
  1018b8:	48 c7 45 f8 04 00 00 	movq   $0x4,-0x8(%rbp)
  1018bf:	00 
  1018c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1018c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  1018c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1018cc:	48 83 c4 10          	add    $0x10,%rsp
  1018d0:	5d                   	pop    %rbp
  1018d1:	c3                   	retq   

Disassembly of section .text._ZN4core3mem7size_of17hc32309647d9ab275E:

00000000001018e0 <_ZN4core3mem7size_of17hc32309647d9ab275E>:
/// assert_eq!(4, mem::size_of::<i32>());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg(not(stage0))]
pub const fn size_of<T>() -> usize {
  1018e0:	55                   	push   %rbp
  1018e1:	48 89 e5             	mov    %rsp,%rbp
    unsafe { intrinsics::size_of::<T>() }
  1018e4:	48 83 ec 10          	sub    $0x10,%rsp
  1018e8:	48 c7 45 f8 20 00 00 	movq   $0x20,-0x8(%rbp)
  1018ef:	00 
  1018f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1018f4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  1018f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1018fc:	48 83 c4 10          	add    $0x10,%rsp
  101900:	5d                   	pop    %rbp
  101901:	c3                   	retq   

Disassembly of section .text._ZN4core3mem7size_of17hcc3e683a1252d746E:

0000000000101910 <_ZN4core3mem7size_of17hcc3e683a1252d746E>:
/// assert_eq!(4, mem::size_of::<i32>());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
#[cfg(not(stage0))]
pub const fn size_of<T>() -> usize {
  101910:	55                   	push   %rbp
  101911:	48 89 e5             	mov    %rsp,%rbp
    unsafe { intrinsics::size_of::<T>() }
  101914:	48 83 ec 10          	sub    $0x10,%rsp
  101918:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  10191f:	00 
  101920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101924:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  101928:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10192c:	48 83 c4 10          	add    $0x10,%rsp
  101930:	5d                   	pop    %rbp
  101931:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr13drop_in_place17h3012351e8095d3e4E:

0000000000101940 <_ZN4core3ptr13drop_in_place17h3012351e8095d3e4E>:
/// This has all the same safety problems as `ptr::read` with respect to
/// invalid pointers, types, and double drops.
#[stable(feature = "drop_in_place", since = "1.8.0")]
#[lang="drop_in_place"]
#[allow(unconditional_recursion)]
pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
  101940:	55                   	push   %rbp
  101941:	48 89 e5             	mov    %rsp,%rbp
  101944:	50                   	push   %rax
  101945:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  101949:	48 83 c4 08          	add    $0x8,%rsp
  10194d:	5d                   	pop    %rbp
  10194e:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr19swap_nonoverlapping17h5ef043214e129f0aE:

0000000000101950 <_ZN4core3ptr19swap_nonoverlapping17h5ef043214e129f0aE>:
/// assert_eq!(x, [7, 8, 3, 4]);
/// assert_eq!(y, [1, 2, 9]);
/// ```
#[inline]
#[unstable(feature = "swap_nonoverlapping", issue = "42818")]
pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {
  101950:	55                   	push   %rbp
  101951:	48 89 e5             	mov    %rsp,%rbp
  101954:	48 83 ec 50          	sub    $0x50,%rsp
  101958:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  10195c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  101960:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  101964:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  101968:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  10196c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  101970:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  101974:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  101978:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
    let x = x as *mut u8;
  10197c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  101980:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    let y = y as *mut u8;
  101984:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  101988:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
    let len = mem::size_of::<T>() * count;
  10198c:	e8 1f ff ff ff       	callq  1018b0 <_ZN4core3mem7size_of17h2ff42b01fb7b57d7E>
  101991:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  101995:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  101999:	48 0f af 45 e0       	imul   -0x20(%rbp),%rax
  10199e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    swap_nonoverlapping_bytes(x, y, len)
  1019a2:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1019a6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  1019aa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  1019ae:	e8 0d 00 00 00       	callq  1019c0 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E>
}
  1019b3:	48 83 c4 50          	add    $0x50,%rsp
  1019b7:	5d                   	pop    %rbp
  1019b8:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E:

00000000001019c0 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E>:

#[inline]
unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {
  1019c0:	55                   	push   %rbp
  1019c1:	48 89 e5             	mov    %rsp,%rbp
  1019c4:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
  1019c8:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
  1019cf:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
  1019d4:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  1019d9:	48 89 54 24 48       	mov    %rdx,0x48(%rsp)
  1019de:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
  1019e3:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  1019e8:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  1019ed:	48 89 54 24 60       	mov    %rdx,0x60(%rsp)
  1019f2:	48 8b 54 24 48       	mov    0x48(%rsp),%rdx
  1019f7:	48 89 54 24 68       	mov    %rdx,0x68(%rsp)
                       target_endian = "big")),
               repr(simd))]
    struct Block(u64, u64, u64, u64);
    struct UnalignedBlock(u64, u64, u64, u64);

    let block_size = mem::size_of::<Block>();
  1019fc:	e8 df fe ff ff       	callq  1018e0 <_ZN4core3mem7size_of17hc32309647d9ab275E>
  101a01:	48 89 44 24 70       	mov    %rax,0x70(%rsp)

    // Loop through x & y, copying them `Block` at a time
    // The optimizer should unroll the loop fully for most types
    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively
    let mut i = 0;
  101a06:	48 c7 44 24 78 00 00 	movq   $0x0,0x78(%rsp)
  101a0d:	00 00 
    while i + block_size <= len {
  101a0f:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
  101a14:	48 03 44 24 70       	add    0x70(%rsp),%rax
  101a19:	48 3b 44 24 68       	cmp    0x68(%rsp),%rax
  101a1e:	76 15                	jbe    101a35 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x75>
        copy_nonoverlapping(y, x, block_size);
        copy_nonoverlapping(t, y, block_size);
        i += block_size;
    }

    if i < len {
  101a20:	48 8b 44 24 78       	mov    0x78(%rsp),%rax
  101a25:	48 3b 44 24 68       	cmp    0x68(%rsp),%rax
  101a2a:	0f 82 f5 00 00 00    	jb     101b25 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x165>
  101a30:	e9 ff 00 00 00       	jmpq   101b34 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x174>
  101a35:	48 89 e7             	mov    %rsp,%rdi
    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively
    let mut i = 0;
    while i + block_size <= len {
        // Create some uninitialized memory as scratch space
        // Declaring `t` here avoids aligning the stack when this loop is unused
        let mut t: Block = mem::uninitialized();
  101a38:	e8 53 fd ff ff       	callq  101790 <_ZN4core3mem13uninitialized17hf5bdda434fdf5afcE>
  101a3d:	48 8b 3c 24          	mov    (%rsp),%rdi
  101a41:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  101a46:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  101a4b:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  101a50:	48 89 94 24 98 00 00 	mov    %rdx,0x98(%rsp)
  101a57:	00 
  101a58:	48 89 8c 24 90 00 00 	mov    %rcx,0x90(%rsp)
  101a5f:	00 
  101a60:	48 89 84 24 88 00 00 	mov    %rax,0x88(%rsp)
  101a67:	00 
  101a68:	48 89 bc 24 80 00 00 	mov    %rdi,0x80(%rsp)
  101a6f:	00 
  101a70:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
  101a77:	00 
        let t = &mut t as *mut _ as *mut u8;
  101a78:	48 89 84 24 b8 00 00 	mov    %rax,0xb8(%rsp)
  101a7f:	00 
        let x = x.offset(i as isize);
  101a80:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  101a85:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
  101a8a:	e8 b1 01 00 00       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  101a8f:	48 89 84 24 c0 00 00 	mov    %rax,0xc0(%rsp)
  101a96:	00 
        let y = y.offset(i as isize);
  101a97:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
  101a9c:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
  101aa1:	e8 9a 01 00 00       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  101aa6:	48 89 84 24 c8 00 00 	mov    %rax,0xc8(%rsp)
  101aad:	00 

        // Swap a block of bytes of x & y, using t as a temporary buffer
        // This should be optimized into efficient SIMD operations where available
        copy_nonoverlapping(x, t, block_size);
  101aae:	48 8b b4 24 c0 00 00 	mov    0xc0(%rsp),%rsi
  101ab5:	00 
  101ab6:	48 8b bc 24 b8 00 00 	mov    0xb8(%rsp),%rdi
  101abd:	00 
  101abe:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  101ac3:	48 c1 e0 00          	shl    $0x0,%rax
  101ac7:	48 89 c2             	mov    %rax,%rdx
  101aca:	e8 21 26 00 00       	callq  1040f0 <memcpy>
        copy_nonoverlapping(y, x, block_size);
  101acf:	48 8b b4 24 c8 00 00 	mov    0xc8(%rsp),%rsi
  101ad6:	00 
  101ad7:	48 8b bc 24 c0 00 00 	mov    0xc0(%rsp),%rdi
  101ade:	00 
  101adf:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  101ae4:	48 c1 e0 00          	shl    $0x0,%rax
  101ae8:	48 89 c2             	mov    %rax,%rdx
  101aeb:	e8 00 26 00 00       	callq  1040f0 <memcpy>
        copy_nonoverlapping(t, y, block_size);
  101af0:	48 8b b4 24 b8 00 00 	mov    0xb8(%rsp),%rsi
  101af7:	00 
  101af8:	48 8b bc 24 c8 00 00 	mov    0xc8(%rsp),%rdi
  101aff:	00 
  101b00:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  101b05:	48 c1 e0 00          	shl    $0x0,%rax
  101b09:	48 89 c2             	mov    %rax,%rdx
  101b0c:	e8 df 25 00 00       	callq  1040f0 <memcpy>
        i += block_size;
  101b11:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  101b16:	48 03 44 24 78       	add    0x78(%rsp),%rax
  101b1b:	48 89 44 24 78       	mov    %rax,0x78(%rsp)

    // Loop through x & y, copying them `Block` at a time
    // The optimizer should unroll the loop fully for most types
    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively
    let mut i = 0;
    while i + block_size <= len {
  101b20:	e9 ea fe ff ff       	jmpq   101a0f <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x4f>
  101b25:	48 8d bc 24 d0 00 00 	lea    0xd0(%rsp),%rdi
  101b2c:	00 
        i += block_size;
    }

    if i < len {
        // Swap any remaining bytes
        let mut t: UnalignedBlock = mem::uninitialized();
  101b2d:	e8 3e fc ff ff       	callq  101770 <_ZN4core3mem13uninitialized17hf20c4c0f754b61a5E>
  101b32:	eb 05                	jmp    101b39 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x179>
        copy_nonoverlapping(y, x, block_size);
        copy_nonoverlapping(t, y, block_size);
        i += block_size;
    }

    if i < len {
  101b34:	e9 be 00 00 00       	jmpq   101bf7 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x237>
  101b39:	48 8d 84 24 d0 00 00 	lea    0xd0(%rsp),%rax
  101b40:	00 
        // Swap any remaining bytes
        let mut t: UnalignedBlock = mem::uninitialized();
        let rem = len - i;
  101b41:	48 8b 4c 24 68       	mov    0x68(%rsp),%rcx
  101b46:	48 2b 4c 24 78       	sub    0x78(%rsp),%rcx
  101b4b:	48 89 8c 24 f0 00 00 	mov    %rcx,0xf0(%rsp)
  101b52:	00 

        let t = &mut t as *mut _ as *mut u8;
  101b53:	48 89 84 24 f8 00 00 	mov    %rax,0xf8(%rsp)
  101b5a:	00 
        let x = x.offset(i as isize);
  101b5b:	48 8b 7c 24 58       	mov    0x58(%rsp),%rdi
  101b60:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
  101b65:	e8 d6 00 00 00       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  101b6a:	48 89 84 24 00 01 00 	mov    %rax,0x100(%rsp)
  101b71:	00 
        let y = y.offset(i as isize);
  101b72:	48 8b 7c 24 60       	mov    0x60(%rsp),%rdi
  101b77:	48 8b 74 24 78       	mov    0x78(%rsp),%rsi
  101b7c:	e8 bf 00 00 00       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  101b81:	48 89 84 24 08 01 00 	mov    %rax,0x108(%rsp)
  101b88:	00 

        copy_nonoverlapping(x, t, rem);
  101b89:	48 8b b4 24 00 01 00 	mov    0x100(%rsp),%rsi
  101b90:	00 
  101b91:	48 8b bc 24 f8 00 00 	mov    0xf8(%rsp),%rdi
  101b98:	00 
  101b99:	48 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%rax
  101ba0:	00 
  101ba1:	48 c1 e0 00          	shl    $0x0,%rax
  101ba5:	48 89 c2             	mov    %rax,%rdx
  101ba8:	e8 43 25 00 00       	callq  1040f0 <memcpy>
        copy_nonoverlapping(y, x, rem);
  101bad:	48 8b b4 24 08 01 00 	mov    0x108(%rsp),%rsi
  101bb4:	00 
  101bb5:	48 8b bc 24 00 01 00 	mov    0x100(%rsp),%rdi
  101bbc:	00 
  101bbd:	48 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%rax
  101bc4:	00 
  101bc5:	48 c1 e0 00          	shl    $0x0,%rax
  101bc9:	48 89 c2             	mov    %rax,%rdx
  101bcc:	e8 1f 25 00 00       	callq  1040f0 <memcpy>
        copy_nonoverlapping(t, y, rem);
  101bd1:	48 8b b4 24 f8 00 00 	mov    0xf8(%rsp),%rsi
  101bd8:	00 
  101bd9:	48 8b bc 24 08 01 00 	mov    0x108(%rsp),%rdi
  101be0:	00 
  101be1:	48 8b 84 24 f0 00 00 	mov    0xf0(%rsp),%rax
  101be8:	00 
  101be9:	48 c1 e0 00          	shl    $0x0,%rax
  101bed:	48 89 c2             	mov    %rax,%rdx
  101bf0:	e8 fb 24 00 00       	callq  1040f0 <memcpy>
        copy_nonoverlapping(y, x, block_size);
        copy_nonoverlapping(t, y, block_size);
        i += block_size;
    }

    if i < len {
  101bf5:	eb 00                	jmp    101bf7 <_ZN4core3ptr25swap_nonoverlapping_bytes17hbc03559537079bd5E+0x237>

        copy_nonoverlapping(x, t, rem);
        copy_nonoverlapping(y, x, rem);
        copy_nonoverlapping(t, y, rem);
    }
}
  101bf7:	48 89 ec             	mov    %rbp,%rsp
  101bfa:	5d                   	pop    %rbp
  101bfb:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$15wrapping_offset17hc5f00fbcb345791fE:

0000000000101c00 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$15wrapping_offset17hc5f00fbcb345791fE>:
    /// }
    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);
    /// ```
    #[stable(feature = "ptr_wrapping_offset", since = "1.16.0")]
    #[inline]
    pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {
  101c00:	55                   	push   %rbp
  101c01:	48 89 e5             	mov    %rsp,%rbp
  101c04:	48 83 ec 30          	sub    $0x30,%rsp
  101c08:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  101c0c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  101c10:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  101c14:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  101c18:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  101c1c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
        unsafe {
            intrinsics::arith_offset(self, count) as *mut T
  101c20:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  101c24:	48 03 75 f0          	add    -0x10(%rbp),%rsi
  101c28:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  101c2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101c30:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        }
    }
  101c34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  101c38:	48 83 c4 30          	add    $0x30,%rsp
  101c3c:	5d                   	pop    %rbp
  101c3d:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE:

0000000000101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>:
    ///     println!("{}", *ptr.offset(2));
    /// }
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[inline]
    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized {
  101c40:	55                   	push   %rbp
  101c41:	48 89 e5             	mov    %rsp,%rbp
  101c44:	48 83 ec 30          	sub    $0x30,%rsp
  101c48:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  101c4c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  101c50:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  101c54:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  101c58:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  101c5c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
        intrinsics::offset(self, count) as *mut T
  101c60:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  101c64:	48 03 75 f0          	add    -0x10(%rbp),%rsi
  101c68:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  101c6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101c70:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }
  101c74:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  101c78:	48 83 c4 30          	add    $0x30,%rsp
  101c7c:	5d                   	pop    %rbp
  101c7d:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h9c2b2f5d5e552b9cE:

0000000000101c80 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h9c2b2f5d5e552b9cE>:
    ///     println!("{}", *ptr.offset(2) as char);
    /// }
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[inline]
    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {
  101c80:	55                   	push   %rbp
  101c81:	48 89 e5             	mov    %rsp,%rbp
  101c84:	48 83 ec 30          	sub    $0x30,%rsp
  101c88:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  101c8c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  101c90:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  101c94:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  101c98:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  101c9c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
        intrinsics::offset(self, count)
  101ca0:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  101ca4:	48 03 75 f0          	add    -0x10(%rbp),%rsi
  101ca8:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  101cac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  101cb0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }
  101cb4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  101cb8:	48 83 c4 30          	add    $0x30,%rsp
  101cbc:	5d                   	pop    %rbp
  101cbd:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h32957334a8540e61E:

0000000000101cc0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h32957334a8540e61E>:
    /// let ptr: *const u8 = s.as_ptr();
    /// assert!(!ptr.is_null());
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[inline]
    pub fn is_null(self) -> bool where T: Sized {
  101cc0:	55                   	push   %rbp
  101cc1:	48 89 e5             	mov    %rsp,%rbp
  101cc4:	48 83 ec 20          	sub    $0x20,%rsp
  101cc8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  101ccc:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  101cd0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        self == null()
  101cd4:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  101cd8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  101cdc:	e8 1f 00 00 00       	callq  101d00 <_ZN4core3ptr4null17h86c43f4da2c684d6E>
  101ce1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  101ce5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  101ce9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  101ced:	48 39 c8             	cmp    %rcx,%rax
  101cf0:	0f 94 c2             	sete   %dl
    }
  101cf3:	80 e2 01             	and    $0x1,%dl
  101cf6:	0f b6 c2             	movzbl %dl,%eax
  101cf9:	48 83 c4 20          	add    $0x20,%rsp
  101cfd:	5d                   	pop    %rbp
  101cfe:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr4null17h86c43f4da2c684d6E:

0000000000101d00 <_ZN4core3ptr4null17h86c43f4da2c684d6E>:
/// let p: *const i32 = ptr::null();
/// assert!(p.is_null());
/// ```
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub const fn null<T>() -> *const T { 0 as *const T }
  101d00:	55                   	push   %rbp
  101d01:	48 89 e5             	mov    %rsp,%rbp
  101d04:	31 c0                	xor    %eax,%eax
  101d06:	5d                   	pop    %rbp
  101d07:	c3                   	retq   

Disassembly of section .text._ZN4core3str11unwrap_or_017h9328e14589e8318fE:

0000000000101d10 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE>:
/// bits `10`).
#[inline]
fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }

#[inline]
fn unwrap_or_0(opt: Option<&u8>) -> u8 {
  101d10:	55                   	push   %rbp
  101d11:	48 89 e5             	mov    %rsp,%rbp
  101d14:	48 83 ec 20          	sub    $0x20,%rsp
  101d18:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  101d1c:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  101d20:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
    match opt {
        Some(&byte) => byte,
  101d24:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  101d28:	48 85 ff             	test   %rdi,%rdi
  101d2b:	75 08                	jne    101d35 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE+0x25>
  101d2d:	eb 00                	jmp    101d2f <_ZN4core3str11unwrap_or_017h9328e14589e8318fE+0x1f>
        None => 0,
  101d2f:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
#[inline]
fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }

#[inline]
fn unwrap_or_0(opt: Option<&u8>) -> u8 {
    match opt {
  101d33:	eb 0f                	jmp    101d44 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE+0x34>
        Some(&byte) => byte,
  101d35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  101d39:	8a 08                	mov    (%rax),%cl
  101d3b:	88 4d ff             	mov    %cl,-0x1(%rbp)
  101d3e:	8a 4d ff             	mov    -0x1(%rbp),%cl
  101d41:	88 4d ef             	mov    %cl,-0x11(%rbp)
        None => 0,
    }
}
  101d44:	8a 45 ef             	mov    -0x11(%rbp),%al
  101d47:	48 83 c4 20          	add    $0x20,%rsp
  101d4b:	5d                   	pop    %rbp
  101d4c:	c3                   	retq   

Disassembly of section .text._ZN4core3str15next_code_point17h7cabed80ef8b9ffdE:

0000000000101d50 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE>:

/// Reads the next code point out of a byte iterator (assuming a
/// UTF-8-like encoding).
#[unstable(feature = "str_internals", issue = "0")]
#[inline]
pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {
  101d50:	55                   	push   %rbp
  101d51:	48 89 e5             	mov    %rsp,%rbp
  101d54:	48 83 ec 70          	sub    $0x70,%rsp
  101d58:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  101d5c:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
  101d60:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    // Decode UTF-8
    let x = match bytes.next() {
  101d64:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  101d68:	e8 23 09 00 00       	callq  102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>
  101d6d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        None => return None,
  101d71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  101d75:	48 85 c0             	test   %rax,%rax
  101d78:	75 1b                	jne    101d95 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x45>
  101d7a:	eb 00                	jmp    101d7c <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x2c>
  101d7c:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
  101d83:	eb 4b                	jmp    101dd0 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x80>
        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),
  101d85:	0f b6 45 c6          	movzbl -0x3a(%rbp),%eax
  101d89:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%rbp)
  101d90:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  101d93:	eb 3b                	jmp    101dd0 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x80>
  101d95:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  101d99:	8a 08                	mov    (%rax),%cl
  101d9b:	88 4d c6             	mov    %cl,-0x3a(%rbp)
  101d9e:	80 7d c6 80          	cmpb   $0x80,-0x3a(%rbp)
  101da2:	72 e1                	jb     101d85 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x35>
  101da4:	be 02 00 00 00       	mov    $0x2,%esi
        Some(&next_byte) => next_byte,
  101da9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  101dad:	8a 08                	mov    (%rax),%cl
  101daf:	88 4d c7             	mov    %cl,-0x39(%rbp)
  101db2:	8a 4d c7             	mov    -0x39(%rbp),%cl
  101db5:	88 4d b7             	mov    %cl,-0x49(%rbp)
    };

    // Multibyte case follows
    // Decode from a byte combination out of: [[[x y] z] w]
    // NOTE: Performance is sensitive to the exact formulation here
    let init = utf8_first_byte(x, 2);
  101db8:	0f b6 7d b7          	movzbl -0x49(%rbp),%edi
  101dbc:	e8 df 00 00 00       	callq  101ea0 <_ZN4core3str15utf8_first_byte17h153f9c732c1cf1dbE>
  101dc1:	89 45 c8             	mov    %eax,-0x38(%rbp)
  101dc4:	eb 0c                	jmp    101dd2 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x82>
            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
        }
    }

    Some(ch)
}
  101dc6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  101dca:	48 83 c4 70          	add    $0x70,%rsp
  101dce:	5d                   	pop    %rbp
  101dcf:	c3                   	retq   
#[unstable(feature = "str_internals", issue = "0")]
#[inline]
pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {
    // Decode UTF-8
    let x = match bytes.next() {
        None => return None,
  101dd0:	eb f4                	jmp    101dc6 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x76>

    // Multibyte case follows
    // Decode from a byte combination out of: [[[x y] z] w]
    // NOTE: Performance is sensitive to the exact formulation here
    let init = utf8_first_byte(x, 2);
    let y = unwrap_or_0(bytes.next());
  101dd2:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  101dd6:	e8 b5 08 00 00       	callq  102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>
  101ddb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  101ddf:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  101de3:	e8 28 ff ff ff       	callq  101d10 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE>
  101de8:	88 45 cf             	mov    %al,-0x31(%rbp)
    let mut ch = utf8_acc_cont_byte(init, y);
  101deb:	8b 7d c8             	mov    -0x38(%rbp),%edi
  101dee:	0f b6 75 cf          	movzbl -0x31(%rbp),%esi
  101df2:	e8 e9 00 00 00       	callq  101ee0 <_ZN4core3str18utf8_acc_cont_byte17hed4c97fa24d042a1E>
  101df7:	89 45 dc             	mov    %eax,-0x24(%rbp)
    if x >= 0xE0 {
  101dfa:	80 7d b7 e0          	cmpb   $0xe0,-0x49(%rbp)
  101dfe:	72 0f                	jb     101e0f <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0xbf>
        // [[x y z] w] case
        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid
        let z = unwrap_or_0(bytes.next());
  101e00:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  101e04:	e8 87 08 00 00       	callq  102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>
  101e09:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  101e0d:	eb 02                	jmp    101e11 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0xc1>
    // Decode from a byte combination out of: [[[x y] z] w]
    // NOTE: Performance is sensitive to the exact formulation here
    let init = utf8_first_byte(x, 2);
    let y = unwrap_or_0(bytes.next());
    let mut ch = utf8_acc_cont_byte(init, y);
    if x >= 0xE0 {
  101e0f:	eb 77                	jmp    101e88 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x138>
        // [[x y z] w] case
        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid
        let z = unwrap_or_0(bytes.next());
  101e11:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  101e15:	e8 f6 fe ff ff       	callq  101d10 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE>
  101e1a:	88 45 e7             	mov    %al,-0x19(%rbp)
        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);
  101e1d:	8a 45 cf             	mov    -0x31(%rbp),%al
  101e20:	24 3f                	and    $0x3f,%al
  101e22:	0f b6 f8             	movzbl %al,%edi
  101e25:	0f b6 75 e7          	movzbl -0x19(%rbp),%esi
  101e29:	e8 b2 00 00 00       	callq  101ee0 <_ZN4core3str18utf8_acc_cont_byte17hed4c97fa24d042a1E>
  101e2e:	89 45 f0             	mov    %eax,-0x10(%rbp)
        ch = init << 12 | y_z;
  101e31:	8b 45 c8             	mov    -0x38(%rbp),%eax
  101e34:	c1 e0 0c             	shl    $0xc,%eax
  101e37:	0b 45 f0             	or     -0x10(%rbp),%eax
  101e3a:	89 45 dc             	mov    %eax,-0x24(%rbp)
        if x >= 0xF0 {
  101e3d:	80 7d b7 f0          	cmpb   $0xf0,-0x49(%rbp)
  101e41:	72 0f                	jb     101e52 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x102>
            // [x y z w] case
            // use only the lower 3 bits of `init`
            let w = unwrap_or_0(bytes.next());
  101e43:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  101e47:	e8 44 08 00 00       	callq  102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>
  101e4c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  101e50:	eb 02                	jmp    101e54 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x104>
        // [[x y z] w] case
        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid
        let z = unwrap_or_0(bytes.next());
        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);
        ch = init << 12 | y_z;
        if x >= 0xF0 {
  101e52:	eb 32                	jmp    101e86 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x136>
            // [x y z w] case
            // use only the lower 3 bits of `init`
            let w = unwrap_or_0(bytes.next());
  101e54:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  101e58:	e8 b3 fe ff ff       	callq  101d10 <_ZN4core3str11unwrap_or_017h9328e14589e8318fE>
  101e5d:	88 45 f7             	mov    %al,-0x9(%rbp)
            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
  101e60:	8b 45 c8             	mov    -0x38(%rbp),%eax
  101e63:	83 e0 07             	and    $0x7,%eax
  101e66:	c1 e0 12             	shl    $0x12,%eax
  101e69:	8b 7d f0             	mov    -0x10(%rbp),%edi
  101e6c:	0f b6 75 f7          	movzbl -0x9(%rbp),%esi
  101e70:	89 45 94             	mov    %eax,-0x6c(%rbp)
  101e73:	e8 68 00 00 00       	callq  101ee0 <_ZN4core3str18utf8_acc_cont_byte17hed4c97fa24d042a1E>
  101e78:	89 45 90             	mov    %eax,-0x70(%rbp)
  101e7b:	8b 45 94             	mov    -0x6c(%rbp),%eax
  101e7e:	8b 4d 90             	mov    -0x70(%rbp),%ecx
  101e81:	09 c8                	or     %ecx,%eax
  101e83:	89 45 dc             	mov    %eax,-0x24(%rbp)
    // Decode from a byte combination out of: [[[x y] z] w]
    // NOTE: Performance is sensitive to the exact formulation here
    let init = utf8_first_byte(x, 2);
    let y = unwrap_or_0(bytes.next());
    let mut ch = utf8_acc_cont_byte(init, y);
    if x >= 0xE0 {
  101e86:	eb 00                	jmp    101e88 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x138>
            let w = unwrap_or_0(bytes.next());
            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
        }
    }

    Some(ch)
  101e88:	8b 45 dc             	mov    -0x24(%rbp),%eax
  101e8b:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%rbp)
  101e92:	89 45 a4             	mov    %eax,-0x5c(%rbp)
}
  101e95:	e9 2c ff ff ff       	jmpq   101dc6 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE+0x76>

Disassembly of section .text._ZN4core3str15utf8_first_byte17h153f9c732c1cf1dbE:

0000000000101ea0 <_ZN4core3str15utf8_first_byte17h153f9c732c1cf1dbE>:

/// Returns the initial codepoint accumulator for the first byte.
/// The first byte is special, only want bottom 5 bits for width 2, 4 bits
/// for width 3, and 3 bits for width 4.
#[inline]
fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }
  101ea0:	55                   	push   %rbp
  101ea1:	48 89 e5             	mov    %rsp,%rbp
  101ea4:	48 83 ec 10          	sub    $0x10,%rsp
  101ea8:	40 88 f8             	mov    %dil,%al
  101eab:	b1 7f                	mov    $0x7f,%cl
  101ead:	88 45 f3             	mov    %al,-0xd(%rbp)
  101eb0:	89 75 f4             	mov    %esi,-0xc(%rbp)
  101eb3:	8a 45 f3             	mov    -0xd(%rbp),%al
  101eb6:	88 45 fb             	mov    %al,-0x5(%rbp)
  101eb9:	8b 75 f4             	mov    -0xc(%rbp),%esi
  101ebc:	89 75 fc             	mov    %esi,-0x4(%rbp)
  101ebf:	8a 45 fb             	mov    -0x5(%rbp),%al
  101ec2:	8b 75 fc             	mov    -0x4(%rbp),%esi
  101ec5:	40 88 f2             	mov    %sil,%dl
  101ec8:	80 e2 07             	and    $0x7,%dl
  101ecb:	88 4d f2             	mov    %cl,-0xe(%rbp)
  101ece:	88 d1                	mov    %dl,%cl
  101ed0:	8a 55 f2             	mov    -0xe(%rbp),%dl
  101ed3:	d2 ea                	shr    %cl,%dl
  101ed5:	20 d0                	and    %dl,%al
  101ed7:	0f b6 c0             	movzbl %al,%eax
  101eda:	48 83 c4 10          	add    $0x10,%rsp
  101ede:	5d                   	pop    %rbp
  101edf:	c3                   	retq   

Disassembly of section .text._ZN4core3str18utf8_acc_cont_byte17hed4c97fa24d042a1E:

0000000000101ee0 <_ZN4core3str18utf8_acc_cont_byte17hed4c97fa24d042a1E>:

/// Returns the value of `ch` updated with continuation byte `byte`.
#[inline]
fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }
  101ee0:	55                   	push   %rbp
  101ee1:	48 89 e5             	mov    %rsp,%rbp
  101ee4:	48 83 ec 10          	sub    $0x10,%rsp
  101ee8:	40 88 f0             	mov    %sil,%al
  101eeb:	89 7d f0             	mov    %edi,-0x10(%rbp)
  101eee:	88 45 f7             	mov    %al,-0x9(%rbp)
  101ef1:	8b 75 f0             	mov    -0x10(%rbp),%esi
  101ef4:	89 75 f8             	mov    %esi,-0x8(%rbp)
  101ef7:	8a 45 f7             	mov    -0x9(%rbp),%al
  101efa:	88 45 ff             	mov    %al,-0x1(%rbp)
  101efd:	8b 75 f8             	mov    -0x8(%rbp),%esi
  101f00:	c1 e6 06             	shl    $0x6,%esi
  101f03:	8a 45 ff             	mov    -0x1(%rbp),%al
  101f06:	24 3f                	and    $0x3f,%al
  101f08:	0f b6 f8             	movzbl %al,%edi
  101f0b:	09 fe                	or     %edi,%esi
  101f0d:	89 f0                	mov    %esi,%eax
  101f0f:	48 83 c4 10          	add    $0x10,%rsp
  101f13:	5d                   	pop    %rbp
  101f14:	c3                   	retq   

Disassembly of section .text._ZN4core3str23from_utf8_unchecked_mut17hff78b68e1dcadaeaE:

0000000000101f20 <_ZN4core3str23from_utf8_unchecked_mut17hff78b68e1dcadaeaE>:
/// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.
///
/// [fromutf8]: fn.from_utf8_unchecked.html
#[inline]
#[stable(feature = "str_mut_extras", since = "1.20.0")]
pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {
  101f20:	55                   	push   %rbp
  101f21:	48 89 e5             	mov    %rsp,%rbp
  101f24:	48 83 ec 40          	sub    $0x40,%rsp
  101f28:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  101f2c:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  101f30:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  101f34:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  101f38:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  101f3c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    mem::transmute(v)
  101f40:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  101f44:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  101f48:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  101f4c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  101f50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  101f54:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  101f58:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  101f5c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
}
  101f60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  101f64:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  101f68:	48 83 c4 40          	add    $0x40,%rsp
  101f6c:	5d                   	pop    %rbp
  101f6d:	c3                   	retq   

Disassembly of section .text._ZN4core4char18from_u32_unchecked17h1116433b5fe7ca01E:

0000000000101f70 <_ZN4core4char18from_u32_unchecked17h1116433b5fe7ca01E>:
///
/// assert_eq!('❤', c);
/// ```
#[inline]
#[stable(feature = "char_from_unchecked", since = "1.5.0")]
pub unsafe fn from_u32_unchecked(i: u32) -> char {
  101f70:	55                   	push   %rbp
  101f71:	48 89 e5             	mov    %rsp,%rbp
  101f74:	48 83 ec 10          	sub    $0x10,%rsp
  101f78:	89 7d f4             	mov    %edi,-0xc(%rbp)
  101f7b:	8b 7d f4             	mov    -0xc(%rbp),%edi
  101f7e:	89 7d f8             	mov    %edi,-0x8(%rbp)
    transmute(i)
  101f81:	8b 7d f8             	mov    -0x8(%rbp),%edi
  101f84:	89 7d fc             	mov    %edi,-0x4(%rbp)
  101f87:	8b 45 fc             	mov    -0x4(%rbp),%eax
  101f8a:	89 45 f0             	mov    %eax,-0x10(%rbp)
}
  101f8d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  101f90:	48 83 c4 10          	add    $0x10,%rsp
  101f94:	5d                   	pop    %rbp
  101f95:	c3                   	retq   

Disassembly of section .text._ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E:

0000000000101fa0 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<A: Step> Iterator for ops::Range<A> {
    type Item = A;

    #[inline]
    fn next(&mut self) -> Option<A> {
  101fa0:	55                   	push   %rbp
  101fa1:	48 89 e5             	mov    %rsp,%rbp
  101fa4:	48 83 ec 30          	sub    $0x30,%rsp
  101fa8:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  101fac:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  101fb0:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
        if self.start < self.end {
  101fb4:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  101fb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  101fbc:	48 83 c0 04          	add    $0x4,%rax
  101fc0:	48 89 c6             	mov    %rax,%rsi
  101fc3:	e8 e8 f3 ff ff       	callq  1013b0 <_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u32$GT$2lt17h121ef3e0591effabE>
  101fc8:	88 45 df             	mov    %al,-0x21(%rbp)
  101fcb:	8a 45 df             	mov    -0x21(%rbp),%al
  101fce:	a8 01                	test   $0x1,%al
  101fd0:	75 02                	jne    101fd4 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E+0x34>
  101fd2:	eb 0e                	jmp    101fe2 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E+0x42>
            let mut n = self.start.add_one();
  101fd4:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  101fd8:	e8 a3 f3 ff ff       	callq  101380 <_ZN47_$LT$u32$u20$as$u20$core..iter..range..Step$GT$7add_one17hb9c6498dc4559fb8E>
  101fdd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  101fe0:	eb 09                	jmp    101feb <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E+0x4b>
            mem::swap(&mut n, &mut self.start);
            Some(n)
        } else {
            None
  101fe2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
impl<A: Step> Iterator for ops::Range<A> {
    type Item = A;

    #[inline]
    fn next(&mut self) -> Option<A> {
        if self.start < self.end {
  101fe9:	eb 1a                	jmp    102005 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E+0x65>
  101feb:	48 8d 7d fc          	lea    -0x4(%rbp),%rdi
            let mut n = self.start.add_one();
            mem::swap(&mut n, &mut self.start);
  101fef:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  101ff3:	e8 18 f8 ff ff       	callq  101810 <_ZN4core3mem4swap17h5e573d5e27a5ae9cE>
            Some(n)
  101ff8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  101ffb:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)
  102002:	89 45 ec             	mov    %eax,-0x14(%rbp)
        } else {
            None
        }
    }
  102005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  102009:	48 83 c4 30          	add    $0x30,%rsp
  10200d:	5d                   	pop    %rbp
  10200e:	c3                   	retq   

Disassembly of section .text._ZN4core4iter8iterator8Iterator6cloned17he6396dd745aa022fE:

0000000000102010 <_ZN4core4iter8iterator8Iterator6cloned17he6396dd745aa022fE>:
    ///
    /// assert_eq!(v_cloned, vec![1, 2, 3]);
    /// assert_eq!(v_map, vec![1, 2, 3]);
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    fn cloned<'a, T: 'a>(self) -> Cloned<Self>
  102010:	55                   	push   %rbp
  102011:	48 89 e5             	mov    %rsp,%rbp
  102014:	48 83 ec 30          	sub    $0x30,%rsp
  102018:	48 89 f8             	mov    %rdi,%rax
  10201b:	48 8b 0e             	mov    (%rsi),%rcx
  10201e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  102022:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
  102026:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  10202a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  10202e:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  102032:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  102036:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
        where Self: Sized + Iterator<Item=&'a T>, T: Clone
    {
        Cloned { it: self }
  10203a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  10203e:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
  102042:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  102046:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
  10204a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  10204e:	48 89 0f             	mov    %rcx,(%rdi)
  102051:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  102055:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
    }
  102059:	48 83 c4 30          	add    $0x30,%rsp
  10205d:	5d                   	pop    %rbp
  10205e:	c3                   	retq   

Disassembly of section .text._ZN4core5slice13size_from_ptr17h06cec35606878578E:

0000000000102060 <_ZN4core5slice13size_from_ptr17h06cec35606878578E>:
        self.iter_mut()
    }
}

#[inline]
fn size_from_ptr<T>(_: *const T) -> usize {
  102060:	55                   	push   %rbp
  102061:	48 89 e5             	mov    %rsp,%rbp
  102064:	48 83 ec 10          	sub    $0x10,%rsp
  102068:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    mem::size_of::<T>()
  10206c:	e8 df f7 ff ff       	callq  101850 <_ZN4core3mem7size_of17h0decfa33ec745297E>
  102071:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  102075:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  102079:	48 83 c4 10          	add    $0x10,%rsp
  10207d:	5d                   	pop    %rbp
  10207e:	c3                   	retq   

Disassembly of section .text._ZN4core5slice18from_raw_parts_mut17h8bd5f10f725e92cfE:

0000000000102080 <_ZN4core5slice18from_raw_parts_mut17h8bd5f10f725e92cfE>:
/// as not being able to provide a non-aliasing guarantee of the returned
/// mutable slice. `p` must be non-null even for zero-length slices as with
/// `from_raw_parts`.
#[inline]
#[stable(feature = "rust1", since = "1.0.0")]
pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {
  102080:	55                   	push   %rbp
  102081:	48 89 e5             	mov    %rsp,%rbp
  102084:	48 83 ec 50          	sub    $0x50,%rsp
  102088:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  10208c:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  102090:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  102094:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  102098:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  10209c:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    mem::transmute(Repr { data: p, len: len })
  1020a0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  1020a4:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  1020a8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  1020ac:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  1020b0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1020b4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1020b8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1020bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  1020c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1020c4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  1020c8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  1020cc:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
}
  1020d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1020d4:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  1020d8:	48 83 c4 50          	add    $0x50,%rsp
  1020dc:	5d                   	pop    %rbp
  1020dd:	c3                   	retq   

Disassembly of section .text._ZN4core5slice8SliceExt8is_empty17h1fd878a3ea2a5070E:

00000000001020e0 <_ZN4core5slice8SliceExt8is_empty17h1fd878a3ea2a5070E>:

    #[stable(feature = "core", since = "1.6.0")]
    fn len(&self) -> usize;

    #[stable(feature = "core", since = "1.6.0")]
    fn is_empty(&self) -> bool { self.len() == 0 }
  1020e0:	55                   	push   %rbp
  1020e1:	48 89 e5             	mov    %rsp,%rbp
  1020e4:	48 83 ec 30          	sub    $0x30,%rsp
  1020e8:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  1020ec:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  1020f0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1020f4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1020f8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1020fc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  102100:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102104:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  102108:	e8 13 01 00 00       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  10210d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  102111:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  102115:	48 83 f8 00          	cmp    $0x0,%rax
  102119:	0f 94 c1             	sete   %cl
  10211c:	80 e1 01             	and    $0x1,%cl
  10211f:	0f b6 c1             	movzbl %cl,%eax
  102122:	48 83 c4 30          	add    $0x30,%rsp
  102126:	5d                   	pop    %rbp
  102127:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$10as_mut_ptr17ha3cb56465eb6d5bcE:

0000000000102130 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$10as_mut_ptr17ha3cb56465eb6d5bcE>:
    {
        index.get_unchecked_mut(self)
    }

    #[inline]
    fn as_mut_ptr(&mut self) -> *mut T {
  102130:	55                   	push   %rbp
  102131:	48 89 e5             	mov    %rsp,%rbp
  102134:	48 83 ec 20          	sub    $0x20,%rsp
  102138:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  10213c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  102140:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  102144:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  102148:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10214c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        self as *mut [T] as *mut T
  102150:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    }
  102154:	48 83 c4 20          	add    $0x20,%rsp
  102158:	5d                   	pop    %rbp
  102159:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17h76a470b3405b37a9E:

0000000000102160 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17h76a470b3405b37a9E>:
            i += 1;
        }
    }

    #[inline]
    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output
  102160:	55                   	push   %rbp
  102161:	48 89 e5             	mov    %rsp,%rbp
  102164:	48 83 ec 50          	sub    $0x50,%rsp
  102168:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  10216c:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  102170:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  102174:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  102178:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  10217c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  102180:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  102184:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  102188:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  10218c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  102190:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
        where I: SliceIndex<[T]>
    {
        index.get_unchecked_mut(self)
  102194:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  102198:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  10219c:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1021a0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1021a4:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  1021a8:	e8 63 e7 ff ff       	callq  100910 <_ZN101_$LT$core..ops..range..RangeTo$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17h24ad8ca6cfa12c21E>
  1021ad:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  1021b1:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    }
  1021b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1021b9:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  1021bd:	48 83 c4 50          	add    $0x50,%rsp
  1021c1:	5d                   	pop    %rbp
  1021c2:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE:

00000000001021d0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$17get_unchecked_mut17ha6ba354a25f0a22fE>:
            i += 1;
        }
    }

    #[inline]
    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output
  1021d0:	55                   	push   %rbp
  1021d1:	48 89 e5             	mov    %rsp,%rbp
  1021d4:	48 83 ec 40          	sub    $0x40,%rsp
  1021d8:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  1021dc:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  1021e0:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  1021e4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  1021e8:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  1021ec:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  1021f0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1021f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  1021f8:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
        where I: SliceIndex<[T]>
    {
        index.get_unchecked_mut(self)
  1021fc:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  102200:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  102204:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  102208:	e8 23 03 00 00       	callq  102530 <_ZN68_$LT$usize$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hd54592d8db86c5b8E>
  10220d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    }
  102211:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  102215:	48 83 c4 40          	add    $0x40,%rsp
  102219:	5d                   	pop    %rbp
  10221a:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE:

0000000000102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>:
            }
        }
    }

    #[inline]
    fn len(&self) -> usize {
  102220:	55                   	push   %rbp
  102221:	48 89 e5             	mov    %rsp,%rbp
  102224:	48 83 ec 38          	sub    $0x38,%rsp
  102228:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  10222c:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  102230:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  102234:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  102238:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10223c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        unsafe {
            mem::transmute::<&[T], Repr<T>>(self).len
  102240:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  102244:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  102248:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10224c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  102250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  102254:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        }
    }
  102258:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  10225c:	48 83 c4 38          	add    $0x38,%rsp
  102260:	5d                   	pop    %rbp
  102261:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE:

0000000000102270 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE>:
    fn split_at(&self, mid: usize) -> (&[T], &[T]) {
        (&self[..mid], &self[mid..])
    }

    #[inline]
    fn iter(&self) -> Iter<T> {
  102270:	55                   	push   %rbp
  102271:	48 89 e5             	mov    %rsp,%rbp
  102274:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  10227b:	48 89 f8             	mov    %rdi,%rax
  10227e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  102282:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  102286:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  10228a:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  10228e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  102292:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
        unsafe {
            let p = if mem::size_of::<T>() == 0 {
  102296:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  10229a:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
  10229e:	e8 ad f5 ff ff       	callq  101850 <_ZN4core3mem7size_of17h0decfa33ec745297E>
  1022a3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  1022a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  1022ab:	48 83 f8 00          	cmp    $0x0,%rax
  1022af:	75 0d                	jne    1022be <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0x4e>
  1022b1:	b8 01 00 00 00       	mov    $0x1,%eax
  1022b6:	89 c1                	mov    %eax,%ecx
                1 as *const _
  1022b8:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
    }

    #[inline]
    fn iter(&self) -> Iter<T> {
        unsafe {
            let p = if mem::size_of::<T>() == 0 {
  1022bc:	eb 25                	jmp    1022e3 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0x73>
                1 as *const _
            } else {
                let p = self.as_ptr();
  1022be:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  1022c2:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  1022c6:	e8 e5 00 00 00       	callq  1023b0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$6as_ptr17h07ee28539d370d7eE>
  1022cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                assume(!p.is_null());
  1022cf:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1022d3:	e8 e8 f9 ff ff       	callq  101cc0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h32957334a8540e61E>
  1022d8:	88 45 a7             	mov    %al,-0x59(%rbp)
                p
  1022db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1022df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            };

            Iter {
                ptr: p,
  1022e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
                end: slice_offset!(p, self.len() as isize),
  1022e7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  1022eb:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)

// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  1022ef:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  1022f3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  1022f7:	e8 64 fd ff ff       	callq  102060 <_ZN4core5slice13size_from_ptr17h06cec35606878578E>
  1022fc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  102300:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  102304:	48 83 f8 00          	cmp    $0x0,%rax
  102308:	75 1e                	jne    102328 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0xb8>
            (ptr as *mut i8).wrapping_offset($by) as _
  10230a:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
                p
            };

            Iter {
                ptr: p,
                end: slice_offset!(p, self.len() as isize),
  10230e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  102312:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  102316:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  10231a:	48 89 c7             	mov    %rax,%rdi
  10231d:	e8 fe fe ff ff       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  102322:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  102326:	eb 24                	jmp    10234c <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0xdc>
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
            (ptr as *mut i8).wrapping_offset($by) as _
        } else {
            ptr.offset($by)
  102328:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
                p
            };

            Iter {
                ptr: p,
                end: slice_offset!(p, self.len() as isize),
  10232c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  102330:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  102334:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
  10233b:	48 89 c7             	mov    %rax,%rdi
  10233e:	e8 dd fe ff ff       	callq  102220 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$3len17h7ad08f3fd591f33fE>
  102343:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  10234a:	eb 21                	jmp    10236d <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0xfd>
// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
            (ptr as *mut i8).wrapping_offset($by) as _
  10234c:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  102350:	48 8b 75 80          	mov    -0x80(%rbp),%rsi
  102354:	e8 a7 f8 ff ff       	callq  101c00 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$15wrapping_offset17hc5f00fbcb345791fE>
  102359:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  102360:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  102367:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  10236b:	eb 19                	jmp    102386 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0x116>
            (ptr as *mut i8).wrapping_offset($by) as _
        } else {
            ptr.offset($by)
  10236d:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
  102374:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
  10237b:	e8 00 f9 ff ff       	callq  101c80 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h9c2b2f5d5e552b9cE>
  102380:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  102384:	eb 00                	jmp    102386 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$4iter17h03a761cb9b54cfabE+0x116>
                let p = self.as_ptr();
                assume(!p.is_null());
                p
            };

            Iter {
  102386:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  10238a:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  10238e:	48 89 08             	mov    %rcx,(%rax)
  102391:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  102395:	48 89 50 08          	mov    %rdx,0x8(%rax)
                ptr: p,
                end: slice_offset!(p, self.len() as isize),
                _marker: marker::PhantomData
            }
        }
    }
  102399:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  10239d:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
  1023a4:	5d                   	pop    %rbp
  1023a5:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$6as_ptr17h07ee28539d370d7eE:

00000000001023b0 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$6as_ptr17h07ee28539d370d7eE>:
    {
        index.get_unchecked(self)
    }

    #[inline]
    fn as_ptr(&self) -> *const T {
  1023b0:	55                   	push   %rbp
  1023b1:	48 89 e5             	mov    %rsp,%rbp
  1023b4:	48 83 ec 20          	sub    $0x20,%rsp
  1023b8:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  1023bc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  1023c0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1023c4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1023c8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  1023cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        self as *const [T] as *const T
  1023d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
    }
  1023d4:	48 83 c4 20          	add    $0x20,%rsp
  1023d8:	5d                   	pop    %rbp
  1023d9:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned17h6e1efb4b685fff84E:

00000000001023e0 <_ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned17h6e1efb4b685fff84E>:
    /// assert_eq!(opt_x, Some(&12));
    /// let cloned = opt_x.cloned();
    /// assert_eq!(cloned, Some(12));
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn cloned(self) -> Option<T> {
  1023e0:	55                   	push   %rbp
  1023e1:	48 89 e5             	mov    %rsp,%rbp
  1023e4:	48 83 ec 30          	sub    $0x30,%rsp
  1023e8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  1023ec:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  1023f0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        self.map(|t| t.clone())
  1023f4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1023f8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  1023fc:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102400:	e8 8b e5 ff ff       	callq  100990 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17h0a8100ea303c60b4E>
  102405:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  102409:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
  10240d:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
    }
  102411:	66 8b 45 e0          	mov    -0x20(%rbp),%ax
  102415:	48 83 c4 30          	add    $0x30,%rsp
  102419:	5d                   	pop    %rbp
  10241a:	c3                   	retq   

Disassembly of section .text._ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned28_$u7b$$u7b$closure$u7d$$u7d$17h84971d7ba5c3a3c4E:

0000000000102420 <_ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned28_$u7b$$u7b$closure$u7d$$u7d$17h84971d7ba5c3a3c4E>:
    /// let cloned = opt_x.cloned();
    /// assert_eq!(cloned, Some(12));
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    pub fn cloned(self) -> Option<T> {
        self.map(|t| t.clone())
  102420:	55                   	push   %rbp
  102421:	48 89 e5             	mov    %rsp,%rbp
  102424:	48 83 ec 20          	sub    $0x20,%rsp
  102428:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  10242c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102430:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  102434:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  102438:	e8 e3 e7 ff ff       	callq  100c20 <_ZN41_$LT$u8$u20$as$u20$core..clone..Clone$GT$5clone17h9b566f05c3348106E>
  10243d:	88 45 e7             	mov    %al,-0x19(%rbp)
  102440:	8a 45 e7             	mov    -0x19(%rbp),%al
  102443:	48 83 c4 20          	add    $0x20,%rsp
  102447:	5d                   	pop    %rbp
  102448:	c3                   	retq   

Disassembly of section .text._ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h1caf42890652eb64E:

0000000000102450 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h1caf42890652eb64E>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self) -> I {
  102450:	55                   	push   %rbp
  102451:	48 89 e5             	mov    %rsp,%rbp
  102454:	48 83 ec 30          	sub    $0x30,%rsp
  102458:	48 89 f8             	mov    %rdi,%rax
  10245b:	48 8b 0e             	mov    (%rsi),%rcx
  10245e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  102462:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
  102466:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  10246a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  10246e:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  102472:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  102476:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
        self
  10247a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  10247e:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
  102482:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  102486:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
  10248a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  10248e:	48 89 0f             	mov    %rcx,(%rdi)
  102491:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  102495:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
    }
  102499:	48 83 c4 30          	add    $0x30,%rsp
  10249d:	5d                   	pop    %rbp
  10249e:	c3                   	retq   

Disassembly of section .text._ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h5aead721d21f11abE:

00000000001024a0 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h5aead721d21f11abE>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self) -> I {
  1024a0:	55                   	push   %rbp
  1024a1:	48 89 e5             	mov    %rsp,%rbp
  1024a4:	48 83 ec 30          	sub    $0x30,%rsp
  1024a8:	48 89 f8             	mov    %rdi,%rax
  1024ab:	48 8b 0e             	mov    (%rsi),%rcx
  1024ae:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  1024b2:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
  1024b6:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  1024ba:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  1024be:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  1024c2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  1024c6:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
        self
  1024ca:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  1024ce:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
  1024d2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  1024d6:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
  1024da:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1024de:	48 89 0f             	mov    %rcx,(%rdi)
  1024e1:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  1024e5:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
    }
  1024e9:	48 83 c4 30          	add    $0x30,%rsp
  1024ed:	5d                   	pop    %rbp
  1024ee:	c3                   	retq   

Disassembly of section .text._ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17hee78865d9151b03cE:

00000000001024f0 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17hee78865d9151b03cE>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<I: Iterator> IntoIterator for I {
    type Item = I::Item;
    type IntoIter = I;

    fn into_iter(self) -> I {
  1024f0:	55                   	push   %rbp
  1024f1:	48 89 e5             	mov    %rsp,%rbp
  1024f4:	48 83 ec 20          	sub    $0x20,%rsp
  1024f8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  1024fc:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  102500:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  102504:	8b 45 e0             	mov    -0x20(%rbp),%eax
  102507:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  10250a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  10250d:	89 4d f4             	mov    %ecx,-0xc(%rbp)
        self
  102510:	8b 45 f0             	mov    -0x10(%rbp),%eax
  102513:	8b 4d f4             	mov    -0xc(%rbp),%ecx
    }
  102516:	89 45 f8             	mov    %eax,-0x8(%rbp)
  102519:	89 4d fc             	mov    %ecx,-0x4(%rbp)
  10251c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  102520:	48 83 c4 20          	add    $0x20,%rsp
  102524:	5d                   	pop    %rbp
  102525:	c3                   	retq   

Disassembly of section .text._ZN68_$LT$usize$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hd54592d8db86c5b8E:

0000000000102530 <_ZN68_$LT$usize$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hd54592d8db86c5b8E>:
    unsafe fn get_unchecked(self, slice: &[T]) -> &T {
        &*slice.as_ptr().offset(self as isize)
    }

    #[inline]
    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {
  102530:	55                   	push   %rbp
  102531:	48 89 e5             	mov    %rsp,%rbp
  102534:	48 83 ec 40          	sub    $0x40,%rsp
  102538:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  10253c:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  102540:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  102544:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  102548:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  10254c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  102550:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  102554:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  102558:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
        &mut *slice.as_mut_ptr().offset(self as isize)
  10255c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102560:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  102564:	e8 c7 fb ff ff       	callq  102130 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$10as_mut_ptr17ha3cb56465eb6d5bcE>
  102569:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  10256d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  102571:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  102575:	e8 c6 f6 ff ff       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  10257a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    }
  10257e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  102582:	48 83 c4 40          	add    $0x40,%rsp
  102586:	5d                   	pop    %rbp
  102587:	c3                   	retq   

Disassembly of section .text._ZN78_$LT$core..iter..Cloned$LT$I$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h1f4ff9722352b322E:

0000000000102590 <_ZN78_$LT$core..iter..Cloned$LT$I$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h1f4ff9722352b322E>:
impl<'a, I, T: 'a> Iterator for Cloned<I>
    where I: Iterator<Item=&'a T>, T: Clone
{
    type Item = T;

    fn next(&mut self) -> Option<T> {
  102590:	55                   	push   %rbp
  102591:	48 89 e5             	mov    %rsp,%rbp
  102594:	48 83 ec 30          	sub    $0x30,%rsp
  102598:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  10259c:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  1025a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        self.it.next().cloned()
  1025a4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  1025a8:	e8 e3 00 00 00       	callq  102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>
  1025ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  1025b1:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  1025b5:	e8 26 fe ff ff       	callq  1023e0 <_ZN53_$LT$core..option..Option$LT$$RF$$u27$a$u20$T$GT$$GT$6cloned17h6e1efb4b685fff84E>
  1025ba:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  1025be:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
  1025c2:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
    }
  1025c6:	66 8b 45 e0          	mov    -0x20(%rbp),%ax
  1025ca:	48 83 c4 30          	add    $0x30,%rsp
  1025ce:	5d                   	pop    %rbp
  1025cf:	c3                   	retq   

Disassembly of section .text._ZN81_$LT$core..str..Bytes$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h051f91d177f38de8E:

00000000001025d0 <_ZN81_$LT$core..str..Bytes$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h051f91d177f38de8E>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<'a> Iterator for Bytes<'a> {
    type Item = u8;

    #[inline]
    fn next(&mut self) -> Option<u8> {
  1025d0:	55                   	push   %rbp
  1025d1:	48 89 e5             	mov    %rsp,%rbp
  1025d4:	48 83 ec 20          	sub    $0x20,%rsp
  1025d8:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  1025dc:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  1025e0:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
        self.0.next()
  1025e4:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  1025e8:	e8 a3 ff ff ff       	callq  102590 <_ZN78_$LT$core..iter..Cloned$LT$I$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h1f4ff9722352b322E>
  1025ed:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  1025f1:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
  1025f5:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
    }
  1025f9:	66 8b 45 e8          	mov    -0x18(%rbp),%ax
  1025fd:	48 83 c4 20          	add    $0x20,%rsp
  102601:	5d                   	pop    %rbp
  102602:	c3                   	retq   

Disassembly of section .text._ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17he6fac7fabb5aee4dE:

0000000000102610 <_ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17he6fac7fabb5aee4dE>:
#[stable(feature = "rust1", since = "1.0.0")]
impl<'a> Iterator for Chars<'a> {
    type Item = char;

    #[inline]
    fn next(&mut self) -> Option<char> {
  102610:	55                   	push   %rbp
  102611:	48 89 e5             	mov    %rsp,%rbp
  102614:	48 83 ec 30          	sub    $0x30,%rsp
  102618:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  10261c:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  102620:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
        next_code_point(&mut self.iter).map(|ch| {
  102624:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  102628:	e8 23 f7 ff ff       	callq  101d50 <_ZN4core3str15next_code_point17h7cabed80ef8b9ffdE>
  10262d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  102631:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  102635:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  102639:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  10263d:	e8 ee e3 ff ff       	callq  100a30 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$3map17hf0322fec5945cf5aE>
  102642:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  102646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10264a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
            // str invariant says `ch` is a valid Unicode Scalar Value
            unsafe {
                char::from_u32_unchecked(ch)
            }
        })
    }
  10264e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  102652:	48 83 c4 30          	add    $0x30,%rsp
  102656:	5d                   	pop    %rbp
  102657:	c3                   	retq   

Disassembly of section .text._ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17h87b813b206527ea1E:

0000000000102660 <_ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17h87b813b206527ea1E>:
impl<'a> Iterator for Chars<'a> {
    type Item = char;

    #[inline]
    fn next(&mut self) -> Option<char> {
        next_code_point(&mut self.iter).map(|ch| {
  102660:	55                   	push   %rbp
  102661:	48 89 e5             	mov    %rsp,%rbp
  102664:	48 83 ec 20          	sub    $0x20,%rsp
  102668:	89 7d f8             	mov    %edi,-0x8(%rbp)
  10266b:	8b 7d f8             	mov    -0x8(%rbp),%edi
  10266e:	89 7d fc             	mov    %edi,-0x4(%rbp)
            // str invariant says `ch` is a valid Unicode Scalar Value
            unsafe {
                char::from_u32_unchecked(ch)
  102671:	8b 7d fc             	mov    -0x4(%rbp),%edi
  102674:	e8 f7 f8 ff ff       	callq  101f70 <_ZN4core4char18from_u32_unchecked17h1116433b5fe7ca01E>
  102679:	89 45 ec             	mov    %eax,-0x14(%rbp)
            }
        })
  10267c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  10267f:	48 83 c4 20          	add    $0x20,%rsp
  102683:	5d                   	pop    %rbp
  102684:	c3                   	retq   

Disassembly of section .text._ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E:

0000000000102690 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E>:
        #[stable(feature = "rust1", since = "1.0.0")]
        impl<'a, T> Iterator for $name<'a, T> {
            type Item = $elem;

            #[inline]
            fn next(&mut self) -> Option<$elem> {
  102690:	55                   	push   %rbp
  102691:	48 89 e5             	mov    %rsp,%rbp
  102694:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  10269b:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  10269f:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
  1026a3:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
                // could be implemented with slices, but this avoids bounds checks
                unsafe {
                    if mem::size_of::<T>() != 0 {
  1026a7:	e8 a4 f1 ff ff       	callq  101850 <_ZN4core3mem7size_of17h0decfa33ec745297E>
  1026ac:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  1026b0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  1026b4:	48 83 f8 00          	cmp    $0x0,%rax
  1026b8:	74 14                	je     1026ce <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x3e>
                        assume(!self.ptr.is_null());
  1026ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  1026be:	48 8b 38             	mov    (%rax),%rdi
  1026c1:	e8 fa f5 ff ff       	callq  101cc0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h32957334a8540e61E>
  1026c6:	88 85 7f ff ff ff    	mov    %al,-0x81(%rbp)
  1026cc:	eb 02                	jmp    1026d0 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x40>

            #[inline]
            fn next(&mut self) -> Option<$elem> {
                // could be implemented with slices, but this avoids bounds checks
                unsafe {
                    if mem::size_of::<T>() != 0 {
  1026ce:	eb 15                	jmp    1026e5 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x55>
                        assume(!self.ptr.is_null());
                        assume(!self.end.is_null());
  1026d0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  1026d4:	48 8b 78 08          	mov    0x8(%rax),%rdi
  1026d8:	e8 e3 f5 ff ff       	callq  101cc0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h32957334a8540e61E>
  1026dd:	88 85 7e ff ff ff    	mov    %al,-0x82(%rbp)

            #[inline]
            fn next(&mut self) -> Option<$elem> {
                // could be implemented with slices, but this avoids bounds checks
                unsafe {
                    if mem::size_of::<T>() != 0 {
  1026e3:	eb 00                	jmp    1026e5 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x55>
                        assume(!self.ptr.is_null());
                        assume(!self.end.is_null());
                    }
                    if self.ptr == self.end {
  1026e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  1026e9:	48 8b 00             	mov    (%rax),%rax
  1026ec:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  1026f0:	48 3b 41 08          	cmp    0x8(%rcx),%rax
  1026f4:	75 0d                	jne    102703 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x73>
                        None
  1026f6:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  1026fd:	00 
                unsafe {
                    if mem::size_of::<T>() != 0 {
                        assume(!self.ptr.is_null());
                        assume(!self.end.is_null());
                    }
                    if self.ptr == self.end {
  1026fe:	e9 c6 00 00 00       	jmpq   1027c9 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x139>
                        None
                    } else {
                        Some($mkref!(self.ptr.post_inc()))
  102703:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  102707:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
trait PointerExt : Copy {
    unsafe fn slice_offset(self, i: isize) -> Self;

    /// Increments `self` by 1, but returns the old value.
    #[inline(always)]
    unsafe fn post_inc(&mut self) -> Self {
  10270b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  10270f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        let current = *self;
  102713:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  102717:	48 8b 00             	mov    (%rax),%rax
  10271a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        *self = self.slice_offset(1);
  10271e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  102722:	48 8b 00             	mov    (%rax),%rax
  102725:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  102729:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  102730:	00 
    }
}

impl<T> PointerExt for *const T {
    #[inline(always)]
    unsafe fn slice_offset(self, i: isize) -> Self {
  102731:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  102735:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  102739:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  10273d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        slice_offset!(self, i)
  102741:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  102745:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  102749:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  10274d:	e8 0e f9 ff ff       	callq  102060 <_ZN4core5slice13size_from_ptr17h06cec35606878578E>
  102752:	48 83 f8 00          	cmp    $0x0,%rax
  102756:	75 13                	jne    10276b <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0xdb>
            (ptr as *mut i8).wrapping_offset($by) as _
  102758:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
}

impl<T> PointerExt for *const T {
    #[inline(always)]
    unsafe fn slice_offset(self, i: isize) -> Self {
        slice_offset!(self, i)
  10275c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
            (ptr as *mut i8).wrapping_offset($by) as _
  102760:	e8 9b f4 ff ff       	callq  101c00 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$15wrapping_offset17hc5f00fbcb345791fE>
  102765:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

// Use macros to be generic over const/mut
macro_rules! slice_offset {
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  102769:	eb 11                	jmp    10277c <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0xec>
            (ptr as *mut i8).wrapping_offset($by) as _
        } else {
            ptr.offset($by)
  10276b:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
}

impl<T> PointerExt for *const T {
    #[inline(always)]
    unsafe fn slice_offset(self, i: isize) -> Self {
        slice_offset!(self, i)
  10276f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
    ($ptr:expr, $by:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
            (ptr as *mut i8).wrapping_offset($by) as _
        } else {
            ptr.offset($by)
  102773:	e8 08 f5 ff ff       	callq  101c80 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h9c2b2f5d5e552b9cE>
  102778:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

impl<T> PointerExt for *const T {
    #[inline(always)]
    unsafe fn slice_offset(self, i: isize) -> Self {
        slice_offset!(self, i)
    }
  10277c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax

    /// Increments `self` by 1, but returns the old value.
    #[inline(always)]
    unsafe fn post_inc(&mut self) -> Self {
        let current = *self;
        *self = self.slice_offset(1);
  102780:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  102784:	48 89 01             	mov    %rax,(%rcx)
        current
  102787:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
                        assume(!self.end.is_null());
                    }
                    if self.ptr == self.end {
                        None
                    } else {
                        Some($mkref!(self.ptr.post_inc()))
  10278b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

// make a &T from a *const T
macro_rules! make_ref {
    ($ptr:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  10278f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  102793:	e8 c8 f8 ff ff       	callq  102060 <_ZN4core5slice13size_from_ptr17h06cec35606878578E>
  102798:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  10279f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  1027a6:	48 83 f8 00          	cmp    $0x0,%rax
  1027aa:	75 0d                	jne    1027b9 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x129>
  1027ac:	b8 01 00 00 00       	mov    $0x1,%eax
  1027b1:	89 c1                	mov    %eax,%ecx
            // Use a non-null pointer value
            &*(1 as *mut _)
  1027b3:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)

// make a &T from a *const T
macro_rules! make_ref {
    ($ptr:expr) => {{
        let ptr = $ptr;
        if size_from_ptr(ptr) == 0 {
  1027b7:	eb 08                	jmp    1027c1 <_ZN91_$LT$core..slice..Iter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17ha11fdbbf6cb0fd64E+0x131>
            // Use a non-null pointer value
            &*(1 as *mut _)
        } else {
            &*ptr
  1027b9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  1027bd:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                        assume(!self.end.is_null());
                    }
                    if self.ptr == self.end {
                        None
                    } else {
                        Some($mkref!(self.ptr.post_inc()))
  1027c1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  1027c5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                    }
                }
            }
  1027c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  1027cd:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
  1027d4:	5d                   	pop    %rbp
  1027d5:	c3                   	retq   

Disassembly of section .text._ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$10write_char17hdae04501c6ec7132E:

00000000001027e0 <_ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$10write_char17hdae04501c6ec7132E>:
        {
            fn write_str(&mut self, s: &str) -> Result {
                self.0.write_str(s)
            }

            fn write_char(&mut self, c: char) -> Result {
  1027e0:	55                   	push   %rbp
  1027e1:	48 89 e5             	mov    %rsp,%rbp
  1027e4:	48 83 ec 30          	sub    $0x30,%rsp
  1027e8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  1027ec:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  1027ef:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  1027f3:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  1027f7:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  1027fa:	89 75 f8             	mov    %esi,-0x8(%rbp)
                self.0.write_char(c)
  1027fd:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102801:	48 8b 3f             	mov    (%rdi),%rdi
  102804:	8b 75 f8             	mov    -0x8(%rbp),%esi
  102807:	e8 34 ed ff ff       	callq  101540 <_ZN4core3fmt5Write10write_char17h480b182123224c78E>
  10280c:	88 45 ff             	mov    %al,-0x1(%rbp)
  10280f:	8a 45 ff             	mov    -0x1(%rbp),%al
  102812:	88 45 e8             	mov    %al,-0x18(%rbp)
            }
  102815:	8a 45 e8             	mov    -0x18(%rbp),%al
  102818:	48 83 c4 30          	add    $0x30,%rsp
  10281c:	5d                   	pop    %rbp
  10281d:	c3                   	retq   

Disassembly of section .text._ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$9write_fmt17hfcbc895c420f66d2E:

0000000000102820 <_ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$9write_fmt17hfcbc895c420f66d2E>:

            fn write_fmt(&mut self, args: Arguments) -> Result {
  102820:	55                   	push   %rbp
  102821:	48 89 e5             	mov    %rsp,%rbp
  102824:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  10282b:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  10282f:	b9 30 00 00 00       	mov    $0x30,%ecx
  102834:	89 ca                	mov    %ecx,%edx
  102836:	4c 8d 45 98          	lea    -0x68(%rbp),%r8
  10283a:	4c 8d 8d 58 ff ff ff 	lea    -0xa8(%rbp),%r9
  102841:	48 89 bd 50 ff ff ff 	mov    %rdi,-0xb0(%rbp)
  102848:	4c 89 cf             	mov    %r9,%rdi
  10284b:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  102852:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
  102859:	4c 89 85 38 ff ff ff 	mov    %r8,-0xc8(%rbp)
  102860:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  102867:	e8 84 18 00 00       	callq  1040f0 <memcpy>
  10286c:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  102873:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  102877:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  10287e:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  102885:	48 89 d7             	mov    %rdx,%rdi
  102888:	48 89 c6             	mov    %rax,%rsi
  10288b:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  102892:	e8 59 18 00 00       	callq  1040f0 <memcpy>
                self.0.write_fmt(args)
  102897:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  10289b:	48 8b 38             	mov    (%rax),%rdi
  10289e:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  1028a5:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  1028ac:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  1028b3:	48 89 d7             	mov    %rdx,%rdi
  1028b6:	48 89 c6             	mov    %rax,%rsi
  1028b9:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  1028c0:	e8 2b 18 00 00       	callq  1040f0 <memcpy>
  1028c5:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
  1028cc:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
  1028d3:	e8 18 ed ff ff       	callq  1015f0 <_ZN4core3fmt5Write9write_fmt17h78c8cffd92df3f60E>
  1028d8:	88 45 ff             	mov    %al,-0x1(%rbp)
  1028db:	8a 45 ff             	mov    -0x1(%rbp),%al
  1028de:	88 45 88             	mov    %al,-0x78(%rbp)
            }
  1028e1:	8a 45 88             	mov    -0x78(%rbp),%al
  1028e4:	48 81 c4 e0 00 00 00 	add    $0xe0,%rsp
  1028eb:	5d                   	pop    %rbp
  1028ec:	c3                   	retq   

Disassembly of section .text._ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$9write_str17h21ed534c2bd963c9E:

00000000001028f0 <_ZN96_$LT$core..fmt..Write..write_fmt..Adapter$LT$$u27$a$C$$u20$T$GT$$u20$as$u20$core..fmt..Write$GT$9write_str17h21ed534c2bd963c9E>:
        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);

        impl<'a, T: ?Sized> Write for Adapter<'a, T>
            where T: Write
        {
            fn write_str(&mut self, s: &str) -> Result {
  1028f0:	55                   	push   %rbp
  1028f1:	48 89 e5             	mov    %rsp,%rbp
  1028f4:	48 83 ec 40          	sub    $0x40,%rsp
  1028f8:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  1028fc:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  102900:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  102904:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  102908:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  10290c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  102910:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  102914:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  102918:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
                self.0.write_str(s)
  10291c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  102920:	48 8b 3a             	mov    (%rdx),%rdi
  102923:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  102927:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  10292b:	e8 70 07 00 00       	callq  1030a0 <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE>
  102930:	88 45 ff             	mov    %al,-0x1(%rbp)
  102933:	8a 45 ff             	mov    -0x1(%rbp),%al
  102936:	88 45 d8             	mov    %al,-0x28(%rbp)
            }
  102939:	8a 45 d8             	mov    -0x28(%rbp),%al
  10293c:	48 83 c4 40          	add    $0x40,%rsp
  102940:	5d                   	pop    %rbp
  102941:	c3                   	retq   

Disassembly of section .text._ZN99_$LT$core..ops..range..Range$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hcf7274c356591f08E:

0000000000102950 <_ZN99_$LT$core..ops..range..Range$LT$usize$GT$$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$17get_unchecked_mut17hcf7274c356591f08E>:
    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {
        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)
    }

    #[inline]
    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {
  102950:	55                   	push   %rbp
  102951:	48 89 e5             	mov    %rsp,%rbp
  102954:	48 83 ec 60          	sub    $0x60,%rsp
  102958:	48 8b 07             	mov    (%rdi),%rax
  10295b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  10295f:	48 8b 47 08          	mov    0x8(%rdi),%rax
  102963:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  102967:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10296b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  10296f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  102973:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  102977:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  10297b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  10297f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  102983:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  102987:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  10298b:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)
  10298f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102993:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  102997:	e8 94 f7 ff ff       	callq  102130 <_ZN53_$LT$$u5b$T$u5d$$u20$as$u20$core..slice..SliceExt$GT$10as_mut_ptr17ha3cb56465eb6d5bcE>
  10299c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  1029a0:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1029a4:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  1029a8:	e8 93 f2 ff ff       	callq  101c40 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17ha9e58ef27bb6695aE>
  1029ad:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  1029b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1029b5:	48 2b 45 e0          	sub    -0x20(%rbp),%rax
  1029b9:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  1029bd:	48 89 c6             	mov    %rax,%rsi
  1029c0:	e8 bb f6 ff ff       	callq  102080 <_ZN4core5slice18from_raw_parts_mut17h8bd5f10f725e92cfE>
  1029c5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  1029c9:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    }
  1029cd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  1029d1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  1029d5:	48 83 c4 60          	add    $0x60,%rsp
  1029d9:	5d                   	pop    %rbp
  1029da:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE:

00000000001029e0 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE>:
const VGA_H: u32 = 25;
const VGA_BUFF: usize = 0xB8000;

extern crate rlibc;

pub fn print_char_at(c: u8, x: u32, y: u32, color: u8) {
  1029e0:	55                   	push   %rbp
  1029e1:	48 89 e5             	mov    %rsp,%rbp
  1029e4:	48 83 ec 50          	sub    $0x50,%rsp
  1029e8:	88 c8                	mov    %cl,%al
  1029ea:	41 88 f8             	mov    %dil,%r8b
  1029ed:	b9 50 00 00 00       	mov    $0x50,%ecx
  1029f2:	44 88 45 d7          	mov    %r8b,-0x29(%rbp)
  1029f6:	89 75 d8             	mov    %esi,-0x28(%rbp)
  1029f9:	89 55 dc             	mov    %edx,-0x24(%rbp)
  1029fc:	88 45 e2             	mov    %al,-0x1e(%rbp)
  1029ff:	8a 45 d7             	mov    -0x29(%rbp),%al
  102a02:	88 45 e3             	mov    %al,-0x1d(%rbp)
  102a05:	8b 55 d8             	mov    -0x28(%rbp),%edx
  102a08:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  102a0b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  102a0e:	89 55 e8             	mov    %edx,-0x18(%rbp)
  102a11:	8a 45 e2             	mov    -0x1e(%rbp),%al
  102a14:	88 45 ef             	mov    %al,-0x11(%rbp)
    let offset : usize = ((y * VGA_W + x) * 2) as usize;
  102a17:	8b 45 e8             	mov    -0x18(%rbp),%eax
  102a1a:	f7 e1                	mul    %ecx
  102a1c:	41 0f 90 c0          	seto   %r8b
  102a20:	41 f6 c0 01          	test   $0x1,%r8b
  102a24:	89 45 d0             	mov    %eax,-0x30(%rbp)
  102a27:	0f 85 95 00 00 00    	jne    102ac2 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE+0xe2>
  102a2d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  102a30:	03 45 e4             	add    -0x1c(%rbp),%eax
  102a33:	0f 92 c1             	setb   %cl
  102a36:	f6 c1 01             	test   $0x1,%cl
  102a39:	89 45 cc             	mov    %eax,-0x34(%rbp)
  102a3c:	0f 85 8f 00 00 00    	jne    102ad1 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE+0xf1>
  102a42:	b8 02 00 00 00       	mov    $0x2,%eax
  102a47:	8b 4d cc             	mov    -0x34(%rbp),%ecx
  102a4a:	89 45 c8             	mov    %eax,-0x38(%rbp)
  102a4d:	89 c8                	mov    %ecx,%eax
  102a4f:	8b 55 c8             	mov    -0x38(%rbp),%edx
  102a52:	f7 e2                	mul    %edx
  102a54:	40 0f 90 c6          	seto   %sil
  102a58:	40 f6 c6 01          	test   $0x1,%sil
  102a5c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  102a5f:	75 7f                	jne    102ae0 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE+0x100>
  102a61:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  102a64:	89 c1                	mov    %eax,%ecx
  102a66:	89 ca                	mov    %ecx,%edx
  102a68:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
	let data : u16 = (color as u16) << 8 | (c as u16);
  102a6c:	40 8a 75 ef          	mov    -0x11(%rbp),%sil
  102a70:	40 0f b6 ce          	movzbl %sil,%ecx
  102a74:	66 89 cf             	mov    %cx,%di
  102a77:	66 c1 e7 08          	shl    $0x8,%di
  102a7b:	66 89 7d c2          	mov    %di,-0x3e(%rbp)
  102a7f:	8a 45 e3             	mov    -0x1d(%rbp),%al
  102a82:	0f b6 c8             	movzbl %al,%ecx
  102a85:	66 89 ca             	mov    %cx,%dx
  102a88:	66 8b 75 c2          	mov    -0x3e(%rbp),%si
  102a8c:	66 09 d6             	or     %dx,%si
  102a8f:	66 89 75 fe          	mov    %si,-0x2(%rbp)
	unsafe { *((VGA_BUFF + offset) as *mut u16) = data; }
  102a93:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
  102a97:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102a9b:	48 81 c7 00 80 0b 00 	add    $0xb8000,%rdi
  102aa2:	0f 92 c0             	setb   %al
  102aa5:	a8 01                	test   $0x1,%al
  102aa7:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  102aab:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  102aaf:	75 3e                	jne    102aef <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE+0x10f>
  102ab1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  102ab5:	66 8b 4d c0          	mov    -0x40(%rbp),%cx
  102ab9:	66 89 08             	mov    %cx,(%rax)
}
  102abc:	48 83 c4 50          	add    $0x50,%rsp
  102ac0:	5d                   	pop    %rbp
  102ac1:	c3                   	retq   
  102ac2:	48 8d 05 3f 28 00 00 	lea    0x283f(%rip),%rax        # 105308 <panic_loc.6>
const VGA_BUFF: usize = 0xB8000;

extern crate rlibc;

pub fn print_char_at(c: u8, x: u32, y: u32, color: u8) {
    let offset : usize = ((y * VGA_W + x) * 2) as usize;
  102ac9:	48 89 c7             	mov    %rax,%rdi
  102acc:	e8 cf 16 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102ad1:	48 8d 05 58 28 00 00 	lea    0x2858(%rip),%rax        # 105330 <panic_loc.7>
  102ad8:	48 89 c7             	mov    %rax,%rdi
  102adb:	e8 c0 16 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102ae0:	48 8d 05 71 28 00 00 	lea    0x2871(%rip),%rax        # 105358 <panic_loc.8>
  102ae7:	48 89 c7             	mov    %rax,%rdi
  102aea:	e8 b1 16 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102aef:	48 8d 05 8a 28 00 00 	lea    0x288a(%rip),%rax        # 105380 <panic_loc.9>
	let data : u16 = (color as u16) << 8 | (c as u16);
	unsafe { *((VGA_BUFF + offset) as *mut u16) = data; }
  102af6:	48 89 c7             	mov    %rax,%rdi
  102af9:	e8 a2 16 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E:

0000000000102b00 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E>:
}

pub fn print_char(c: char, color: u8) {
  102b00:	55                   	push   %rbp
  102b01:	48 89 e5             	mov    %rsp,%rbp
  102b04:	48 83 ec 30          	sub    $0x30,%rsp
  102b08:	40 88 f0             	mov    %sil,%al
  102b0b:	89 7d e0             	mov    %edi,-0x20(%rbp)
  102b0e:	88 45 e7             	mov    %al,-0x19(%rbp)
  102b11:	8b 75 e0             	mov    -0x20(%rbp),%esi
  102b14:	89 75 f0             	mov    %esi,-0x10(%rbp)
  102b17:	8a 45 e7             	mov    -0x19(%rbp),%al
  102b1a:	88 45 f7             	mov    %al,-0x9(%rbp)
	unsafe {
		match c {
		'\n' =>
  102b1d:	8b 75 f0             	mov    -0x10(%rbp),%esi
  102b20:	83 ee 0a             	sub    $0xa,%esi
  102b23:	89 75 dc             	mov    %esi,-0x24(%rbp)
  102b26:	75 26                	jne    102b4e <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x4e>
  102b28:	eb 00                	jmp    102b2a <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x2a>
			{
				VGA_COL = 0;
  102b2a:	c7 05 cc a4 00 00 00 	movl   $0x0,0xa4cc(%rip)        # 10d000 <stack_top>
  102b31:	00 00 00 
				VGA_ROW += 1;
  102b34:	8b 05 ca a4 00 00    	mov    0xa4ca(%rip),%eax        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102b3a:	83 c0 01             	add    $0x1,%eax
  102b3d:	0f 92 c1             	setb   %cl
  102b40:	f6 c1 01             	test   $0x1,%cl
  102b43:	89 45 d8             	mov    %eax,-0x28(%rbp)
  102b46:	0f 85 af 00 00 00    	jne    102bfb <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xfb>
  102b4c:	eb 2a                	jmp    102b78 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x78>
			},
		_ =>
			{
				print_char_at(c as u8, VGA_COL, VGA_ROW, color);
  102b4e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  102b51:	88 c1                	mov    %al,%cl
  102b53:	8b 35 a7 a4 00 00    	mov    0xa4a7(%rip),%esi        # 10d000 <stack_top>
  102b59:	8b 15 a5 a4 00 00    	mov    0xa4a5(%rip),%edx        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102b5f:	0f b6 f9             	movzbl %cl,%edi
  102b62:	0f b6 4d f7          	movzbl -0x9(%rbp),%ecx
  102b66:	e8 75 fe ff ff       	callq  1029e0 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE>
  102b6b:	eb 16                	jmp    102b83 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x83>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102b6d:	83 3d 8c a4 00 00 50 	cmpl   $0x50,0xa48c(%rip)        # 10d000 <stack_top>
  102b74:	73 2c                	jae    102ba2 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xa2>
  102b76:	eb 40                	jmp    102bb8 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xb8>
	unsafe {
		match c {
		'\n' =>
			{
				VGA_COL = 0;
				VGA_ROW += 1;
  102b78:	8b 45 d8             	mov    -0x28(%rbp),%eax
  102b7b:	89 05 83 a4 00 00    	mov    %eax,0xa483(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
	unsafe { *((VGA_BUFF + offset) as *mut u16) = data; }
}

pub fn print_char(c: char, color: u8) {
	unsafe {
		match c {
  102b81:	eb ea                	jmp    102b6d <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x6d>
				VGA_ROW += 1;
			},
		_ =>
			{
				print_char_at(c as u8, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
  102b83:	8b 05 77 a4 00 00    	mov    0xa477(%rip),%eax        # 10d000 <stack_top>
  102b89:	83 c0 01             	add    $0x1,%eax
  102b8c:	0f 92 c1             	setb   %cl
  102b8f:	f6 c1 01             	test   $0x1,%cl
  102b92:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  102b95:	75 55                	jne    102bec <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xec>
  102b97:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  102b9a:	89 05 60 a4 00 00    	mov    %eax,0xa460(%rip)        # 10d000 <stack_top>
	unsafe { *((VGA_BUFF + offset) as *mut u16) = data; }
}

pub fn print_char(c: char, color: u8) {
	unsafe {
		match c {
  102ba0:	eb cb                	jmp    102b6d <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x6d>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
  102ba2:	8b 05 5c a4 00 00    	mov    0xa45c(%rip),%eax        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102ba8:	83 c0 01             	add    $0x1,%eax
  102bab:	0f 92 c1             	setb   %cl
  102bae:	f6 c1 01             	test   $0x1,%cl
  102bb1:	89 45 d0             	mov    %eax,-0x30(%rbp)
  102bb4:	75 54                	jne    102c0a <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0x10a>
  102bb6:	eb 02                	jmp    102bba <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xba>
				print_char_at(c as u8, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102bb8:	eb 2c                	jmp    102be6 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xe6>
			VGA_ROW += 1;
  102bba:	8b 45 d0             	mov    -0x30(%rbp),%eax
  102bbd:	89 05 41 a4 00 00    	mov    %eax,0xa441(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
			VGA_COL = 0;
  102bc3:	c7 05 33 a4 00 00 00 	movl   $0x0,0xa433(%rip)        # 10d000 <stack_top>
  102bca:	00 00 00 
			if VGA_ROW >= VGA_H {
  102bcd:	83 3d 30 a4 00 00 19 	cmpl   $0x19,0xa430(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102bd4:	72 0c                	jb     102be2 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xe2>
				VGA_ROW = 0;
  102bd6:	c7 05 24 a4 00 00 00 	movl   $0x0,0xa424(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102bdd:	00 00 00 
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
			VGA_COL = 0;
			if VGA_ROW >= VGA_H {
  102be0:	eb 02                	jmp    102be4 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xe4>
  102be2:	eb 00                	jmp    102be4 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xe4>
				print_char_at(c as u8, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102be4:	eb 00                	jmp    102be6 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E+0xe6>
			if VGA_ROW >= VGA_H {
				VGA_ROW = 0;
			}
		}
	}
}
  102be6:	48 83 c4 30          	add    $0x30,%rsp
  102bea:	5d                   	pop    %rbp
  102beb:	c3                   	retq   
  102bec:	48 8d 05 b5 27 00 00 	lea    0x27b5(%rip),%rax        # 1053a8 <panic_loc.a>
				VGA_ROW += 1;
			},
		_ =>
			{
				print_char_at(c as u8, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
  102bf3:	48 89 c7             	mov    %rax,%rdi
  102bf6:	e8 a5 15 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102bfb:	48 8d 05 ce 27 00 00 	lea    0x27ce(%rip),%rax        # 1053d0 <panic_loc.b>
	unsafe {
		match c {
		'\n' =>
			{
				VGA_COL = 0;
				VGA_ROW += 1;
  102c02:	48 89 c7             	mov    %rax,%rdi
  102c05:	e8 96 15 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102c0a:	48 8d 05 e7 27 00 00 	lea    0x27e7(%rip),%rax        # 1053f8 <panic_loc.c>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
  102c11:	48 89 c7             	mov    %rax,%rdi
  102c14:	e8 87 15 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E:

0000000000102c20 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E>:
			}
		}
	}
}

pub fn print_byte(c: u8, color: u8) {
  102c20:	55                   	push   %rbp
  102c21:	48 89 e5             	mov    %rsp,%rbp
  102c24:	48 83 ec 20          	sub    $0x20,%rsp
  102c28:	40 88 f0             	mov    %sil,%al
  102c2b:	40 88 f9             	mov    %dil,%cl
  102c2e:	88 4d ee             	mov    %cl,-0x12(%rbp)
  102c31:	88 45 ef             	mov    %al,-0x11(%rbp)
  102c34:	8a 45 ee             	mov    -0x12(%rbp),%al
  102c37:	88 45 f6             	mov    %al,-0xa(%rbp)
  102c3a:	8a 45 ef             	mov    -0x11(%rbp),%al
  102c3d:	88 45 f7             	mov    %al,-0x9(%rbp)
	unsafe {
		match c {
		b'\n' =>
  102c40:	8a 45 f6             	mov    -0xa(%rbp),%al
  102c43:	2c 0a                	sub    $0xa,%al
  102c45:	88 45 ed             	mov    %al,-0x13(%rbp)
  102c48:	75 26                	jne    102c70 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x50>
  102c4a:	eb 00                	jmp    102c4c <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x2c>
			{
				VGA_COL = 0;
  102c4c:	c7 05 aa a3 00 00 00 	movl   $0x0,0xa3aa(%rip)        # 10d000 <stack_top>
  102c53:	00 00 00 
				VGA_ROW += 1;
  102c56:	8b 05 a8 a3 00 00    	mov    0xa3a8(%rip),%eax        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102c5c:	83 c0 01             	add    $0x1,%eax
  102c5f:	0f 92 c1             	setb   %cl
  102c62:	f6 c1 01             	test   $0x1,%cl
  102c65:	89 45 e8             	mov    %eax,-0x18(%rbp)
  102c68:	0f 85 ad 00 00 00    	jne    102d1b <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xfb>
  102c6e:	eb 28                	jmp    102c98 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x78>
			},
		_ =>
			{
				print_char_at(c, VGA_COL, VGA_ROW, color);
  102c70:	8a 45 f6             	mov    -0xa(%rbp),%al
  102c73:	8b 35 87 a3 00 00    	mov    0xa387(%rip),%esi        # 10d000 <stack_top>
  102c79:	8b 15 85 a3 00 00    	mov    0xa385(%rip),%edx        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102c7f:	0f b6 f8             	movzbl %al,%edi
  102c82:	0f b6 4d f7          	movzbl -0x9(%rbp),%ecx
  102c86:	e8 55 fd ff ff       	callq  1029e0 <_ZN13rustbucket_os6driver3vga13print_char_at17h5b33b3f07c17aacaE>
  102c8b:	eb 16                	jmp    102ca3 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x83>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102c8d:	83 3d 6c a3 00 00 50 	cmpl   $0x50,0xa36c(%rip)        # 10d000 <stack_top>
  102c94:	73 2c                	jae    102cc2 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xa2>
  102c96:	eb 40                	jmp    102cd8 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xb8>
	unsafe {
		match c {
		b'\n' =>
			{
				VGA_COL = 0;
				VGA_ROW += 1;
  102c98:	8b 45 e8             	mov    -0x18(%rbp),%eax
  102c9b:	89 05 63 a3 00 00    	mov    %eax,0xa363(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
	}
}

pub fn print_byte(c: u8, color: u8) {
	unsafe {
		match c {
  102ca1:	eb ea                	jmp    102c8d <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x6d>
				VGA_ROW += 1;
			},
		_ =>
			{
				print_char_at(c, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
  102ca3:	8b 05 57 a3 00 00    	mov    0xa357(%rip),%eax        # 10d000 <stack_top>
  102ca9:	83 c0 01             	add    $0x1,%eax
  102cac:	0f 92 c1             	setb   %cl
  102caf:	f6 c1 01             	test   $0x1,%cl
  102cb2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  102cb5:	75 55                	jne    102d0c <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xec>
  102cb7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  102cba:	89 05 40 a3 00 00    	mov    %eax,0xa340(%rip)        # 10d000 <stack_top>
	}
}

pub fn print_byte(c: u8, color: u8) {
	unsafe {
		match c {
  102cc0:	eb cb                	jmp    102c8d <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x6d>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
  102cc2:	8b 05 3c a3 00 00    	mov    0xa33c(%rip),%eax        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102cc8:	83 c0 01             	add    $0x1,%eax
  102ccb:	0f 92 c1             	setb   %cl
  102cce:	f6 c1 01             	test   $0x1,%cl
  102cd1:	89 45 e0             	mov    %eax,-0x20(%rbp)
  102cd4:	75 54                	jne    102d2a <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0x10a>
  102cd6:	eb 02                	jmp    102cda <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xba>
				print_char_at(c, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102cd8:	eb 2c                	jmp    102d06 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xe6>
			VGA_ROW += 1;
  102cda:	8b 45 e0             	mov    -0x20(%rbp),%eax
  102cdd:	89 05 21 a3 00 00    	mov    %eax,0xa321(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
			VGA_COL = 0;
  102ce3:	c7 05 13 a3 00 00 00 	movl   $0x0,0xa313(%rip)        # 10d000 <stack_top>
  102cea:	00 00 00 
			if VGA_ROW >= VGA_H {
  102ced:	83 3d 10 a3 00 00 19 	cmpl   $0x19,0xa310(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102cf4:	72 0c                	jb     102d02 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xe2>
				VGA_ROW = 0;
  102cf6:	c7 05 04 a3 00 00 00 	movl   $0x0,0xa304(%rip)        # 10d004 <_ZN13rustbucket_os6driver3vga7VGA_ROW17h7febd73148c8b8cfE>
  102cfd:	00 00 00 
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
			VGA_COL = 0;
			if VGA_ROW >= VGA_H {
  102d00:	eb 02                	jmp    102d04 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xe4>
  102d02:	eb 00                	jmp    102d04 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xe4>
				print_char_at(c, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
  102d04:	eb 00                	jmp    102d06 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E+0xe6>
			if VGA_ROW >= VGA_H {
				VGA_ROW = 0;
			}
		}
	}
}
  102d06:	48 83 c4 20          	add    $0x20,%rsp
  102d0a:	5d                   	pop    %rbp
  102d0b:	c3                   	retq   
  102d0c:	48 8d 05 0d 27 00 00 	lea    0x270d(%rip),%rax        # 105420 <panic_loc.d>
				VGA_ROW += 1;
			},
		_ =>
			{
				print_char_at(c, VGA_COL, VGA_ROW, color);
				VGA_COL += 1;
  102d13:	48 89 c7             	mov    %rax,%rdi
  102d16:	e8 85 14 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102d1b:	48 8d 05 26 27 00 00 	lea    0x2726(%rip),%rax        # 105448 <panic_loc.e>
	unsafe {
		match c {
		b'\n' =>
			{
				VGA_COL = 0;
				VGA_ROW += 1;
  102d22:	48 89 c7             	mov    %rax,%rdi
  102d25:	e8 76 14 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  102d2a:	48 8d 05 3f 27 00 00 	lea    0x273f(%rip),%rax        # 105470 <panic_loc.f>
				VGA_COL += 1;
			},
		};

		if VGA_COL >= VGA_W {
			VGA_ROW += 1;
  102d31:	48 89 c7             	mov    %rax,%rdi
  102d34:	e8 67 14 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E:

0000000000102d40 <_ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E>:
			}
		}
	}
}

pub fn print(str: &str, color: u8) {
  102d40:	55                   	push   %rbp
  102d41:	48 89 e5             	mov    %rsp,%rbp
  102d44:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  102d4b:	88 d0                	mov    %dl,%al
  102d4d:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  102d51:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
  102d58:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  102d5c:	88 45 8f             	mov    %al,-0x71(%rbp)
  102d5f:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
  102d66:	48 8b 7d 80          	mov    -0x80(%rbp),%rdi
  102d6a:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  102d6e:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  102d72:	8a 45 8f             	mov    -0x71(%rbp),%al
  102d75:	88 45 a7             	mov    %al,-0x59(%rbp)
	for c in str.chars() {
  102d78:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  102d7c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  102d80:	48 89 cf             	mov    %rcx,%rdi
  102d83:	e8 c8 dd ff ff       	callq  100b50 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5chars17h778cc94a820d39f6E>
  102d88:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
  102d8c:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
  102d90:	e8 bb f6 ff ff       	callq  102450 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h1caf42890652eb64E>
  102d95:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  102d99:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  102d9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  102da1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  102da5:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
  102da9:	e8 62 f8 ff ff       	callq  102610 <_ZN81_$LT$core..str..Chars$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17he6fac7fabb5aee4dE>
  102dae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  102db2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  102db6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  102dba:	8b 45 e8             	mov    -0x18(%rbp),%eax
  102dbd:	85 c0                	test   %eax,%eax
  102dbf:	75 0b                	jne    102dcc <_ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E+0x8c>
  102dc1:	eb 00                	jmp    102dc3 <_ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E+0x83>
        print_char(c, color);
  }
}
  102dc3:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
  102dca:	5d                   	pop    %rbp
  102dcb:	c3                   	retq   
		}
	}
}

pub fn print(str: &str, color: u8) {
	for c in str.chars() {
  102dcc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  102dcf:	89 45 f0             	mov    %eax,-0x10(%rbp)
  102dd2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  102dd5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  102dd8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  102ddb:	89 45 f4             	mov    %eax,-0xc(%rbp)
        print_char(c, color);
  102dde:	8b 7d f4             	mov    -0xc(%rbp),%edi
  102de1:	0f b6 75 a7          	movzbl -0x59(%rbp),%esi
  102de5:	e8 16 fd ff ff       	callq  102b00 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E>
		}
	}
}

pub fn print(str: &str, color: u8) {
	for c in str.chars() {
  102dea:	eb b9                	jmp    102da5 <_ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E+0x65>

Disassembly of section .text._ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE:

0000000000102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>:
        print_char(c, color);
  }
}

pub fn println(str: &str) {
  102df0:	55                   	push   %rbp
  102df1:	48 89 e5             	mov    %rsp,%rbp
  102df4:	48 83 ec 20          	sub    $0x20,%rsp
  102df8:	ba 07 00 00 00       	mov    $0x7,%edx
  102dfd:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  102e01:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  102e05:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  102e09:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  102e0d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  102e11:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	print(str, 0x07);
  102e15:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
  102e19:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  102e1d:	e8 1e ff ff ff       	callq  102d40 <_ZN13rustbucket_os6driver3vga5print17hc60e8ec7fcb4f637E>
  102e22:	bf 0a 00 00 00       	mov    $0xa,%edi
  102e27:	be 07 00 00 00       	mov    $0x7,%esi
	print_char('\n', 0x07);
  102e2c:	e8 cf fc ff ff       	callq  102b00 <_ZN13rustbucket_os6driver3vga10print_char17h88c8863842991c21E>
}
  102e31:	48 83 c4 20          	add    $0x20,%rsp
  102e35:	5d                   	pop    %rbp
  102e36:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE:

0000000000102e40 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE>:

pub fn clear_term() {
  102e40:	55                   	push   %rbp
  102e41:	48 89 e5             	mov    %rsp,%rbp
    //loop through columns and rows, print whitespace char
    for x in 0..VGA_W as u32 {
  102e44:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  102e4b:	c7 85 58 ff ff ff 00 	movl   $0x0,-0xa8(%rbp)
  102e52:	00 00 00 
  102e55:	c7 85 5c ff ff ff 50 	movl   $0x50,-0xa4(%rbp)
  102e5c:	00 00 00 
  102e5f:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  102e65:	8b 8d 5c ff ff ff    	mov    -0xa4(%rbp),%ecx
  102e6b:	89 45 c0             	mov    %eax,-0x40(%rbp)
  102e6e:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  102e71:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
  102e75:	e8 76 f6 ff ff       	callq  1024f0 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17hee78865d9151b03cE>
  102e7a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  102e7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  102e82:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  102e86:	8b 4d c8             	mov    -0x38(%rbp),%ecx
  102e89:	8b 55 cc             	mov    -0x34(%rbp),%edx
  102e8c:	89 8d 4c ff ff ff    	mov    %ecx,-0xb4(%rbp)
  102e92:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%rbp)
  102e98:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  102e9e:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
  102ea4:	8b 8d 48 ff ff ff    	mov    -0xb8(%rbp),%ecx
  102eaa:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%rbp)
  102eb0:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
  102eb7:	e8 e4 f0 ff ff       	callq  101fa0 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E>
  102ebc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  102ec0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  102ec4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  102ecb:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  102ed1:	85 c0                	test   %eax,%eax
  102ed3:	75 0b                	jne    102ee0 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0xa0>
  102ed5:	eb 00                	jmp    102ed7 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x97>
          let offset : usize = ((y * VGA_W + x) * 2) as usize;
          let data : i16 = 0x0720;
          unsafe { *((VGA_BUFF + offset) as *mut i16) = data; }
        }
    }
}
  102ed7:	48 81 c4 e0 00 00 00 	add    $0xe0,%rsp
  102ede:	5d                   	pop    %rbp
  102edf:	c3                   	retq   
	print_char('\n', 0x07);
}

pub fn clear_term() {
    //loop through columns and rows, print whitespace char
    for x in 0..VGA_W as u32 {
  102ee0:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  102ee6:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
  102eec:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  102ef2:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  102ef8:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  102efe:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
        for y in 0..VGA_H as u32 {
  102f04:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%rbp)
  102f0b:	c7 45 8c 19 00 00 00 	movl   $0x19,-0x74(%rbp)
  102f12:	8b 45 88             	mov    -0x78(%rbp),%eax
  102f15:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
  102f18:	89 45 e0             	mov    %eax,-0x20(%rbp)
  102f1b:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  102f1e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  102f22:	e8 c9 f5 ff ff       	callq  1024f0 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17hee78865d9151b03cE>
  102f27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  102f2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  102f2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  102f33:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  102f36:	8b 55 ec             	mov    -0x14(%rbp),%edx
  102f39:	89 8d 44 ff ff ff    	mov    %ecx,-0xbc(%rbp)
  102f3f:	89 95 40 ff ff ff    	mov    %edx,-0xc0(%rbp)
  102f45:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  102f4b:	89 45 90             	mov    %eax,-0x70(%rbp)
  102f4e:	8b 8d 40 ff ff ff    	mov    -0xc0(%rbp),%ecx
  102f54:	89 4d 94             	mov    %ecx,-0x6c(%rbp)
  102f57:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  102f5b:	e8 40 f0 ff ff       	callq  101fa0 <_ZN4core4iter5range93_$LT$impl$u20$core..iter..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hbf7bc22d6b627882E>
  102f60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  102f64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  102f68:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  102f6c:	8b 45 a0             	mov    -0x60(%rbp),%eax
  102f6f:	85 c0                	test   %eax,%eax
  102f71:	75 07                	jne    102f7a <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x13a>
  102f73:	eb 00                	jmp    102f75 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x135>
	print_char('\n', 0x07);
}

pub fn clear_term() {
    //loop through columns and rows, print whitespace char
    for x in 0..VGA_W as u32 {
  102f75:	e9 36 ff ff ff       	jmpq   102eb0 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x70>
  102f7a:	b8 50 00 00 00       	mov    $0x50,%eax
        for y in 0..VGA_H as u32 {
  102f7f:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
  102f82:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  102f85:	8b 4d a8             	mov    -0x58(%rbp),%ecx
  102f88:	89 4d 9c             	mov    %ecx,-0x64(%rbp)
  102f8b:	8b 4d 9c             	mov    -0x64(%rbp),%ecx
  102f8e:	89 4d ac             	mov    %ecx,-0x54(%rbp)
          let offset : usize = ((y * VGA_W + x) * 2) as usize;
  102f91:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  102f94:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  102f9a:	89 c8                	mov    %ecx,%eax
  102f9c:	8b 8d 3c ff ff ff    	mov    -0xc4(%rbp),%ecx
  102fa2:	f7 e1                	mul    %ecx
  102fa4:	40 0f 90 c6          	seto   %sil
  102fa8:	40 f6 c6 01          	test   $0x1,%sil
  102fac:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
  102fb2:	0f 85 9a 00 00 00    	jne    103052 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x212>
  102fb8:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  102fbe:	03 85 7c ff ff ff    	add    -0x84(%rbp),%eax
  102fc4:	0f 92 c1             	setb   %cl
  102fc7:	f6 c1 01             	test   $0x1,%cl
  102fca:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  102fd0:	0f 85 8b 00 00 00    	jne    103061 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x221>
  102fd6:	b8 02 00 00 00       	mov    $0x2,%eax
  102fdb:	8b 8d 34 ff ff ff    	mov    -0xcc(%rbp),%ecx
  102fe1:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%rbp)
  102fe7:	89 c8                	mov    %ecx,%eax
  102fe9:	8b 95 30 ff ff ff    	mov    -0xd0(%rbp),%edx
  102fef:	f7 e2                	mul    %edx
  102ff1:	40 0f 90 c6          	seto   %sil
  102ff5:	40 f6 c6 01          	test   $0x1,%sil
  102ff9:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
  102fff:	75 6f                	jne    103070 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x230>
  103001:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  103007:	89 c1                	mov    %eax,%ecx
  103009:	89 ca                	mov    %ecx,%edx
  10300b:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
          let data : i16 = 0x0720;
  10300f:	66 c7 45 be 20 07    	movw   $0x720,-0x42(%rbp)
          unsafe { *((VGA_BUFF + offset) as *mut i16) = data; }
  103015:	66 8b 75 be          	mov    -0x42(%rbp),%si
  103019:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  10301d:	48 81 c2 00 80 0b 00 	add    $0xb8000,%rdx
  103024:	40 0f 92 c7          	setb   %dil
  103028:	40 f6 c7 01          	test   $0x1,%dil
  10302c:	66 89 b5 2a ff ff ff 	mov    %si,-0xd6(%rbp)
  103033:	48 89 95 20 ff ff ff 	mov    %rdx,-0xe0(%rbp)
  10303a:	75 43                	jne    10307f <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x23f>
  10303c:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  103043:	66 8b 8d 2a ff ff ff 	mov    -0xd6(%rbp),%cx
  10304a:	66 89 08             	mov    %cx,(%rax)
}

pub fn clear_term() {
    //loop through columns and rows, print whitespace char
    for x in 0..VGA_W as u32 {
        for y in 0..VGA_H as u32 {
  10304d:	e9 05 ff ff ff       	jmpq   102f57 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE+0x117>
  103052:	48 8d 05 3f 24 00 00 	lea    0x243f(%rip),%rax        # 105498 <panic_loc.g>
          let offset : usize = ((y * VGA_W + x) * 2) as usize;
  103059:	48 89 c7             	mov    %rax,%rdi
  10305c:	e8 3f 11 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103061:	48 8d 05 58 24 00 00 	lea    0x2458(%rip),%rax        # 1054c0 <panic_loc.h>
  103068:	48 89 c7             	mov    %rax,%rdi
  10306b:	e8 30 11 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103070:	48 8d 05 71 24 00 00 	lea    0x2471(%rip),%rax        # 1054e8 <panic_loc.i>
  103077:	48 89 c7             	mov    %rax,%rdi
  10307a:	e8 21 11 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  10307f:	48 8d 05 8a 24 00 00 	lea    0x248a(%rip),%rax        # 105510 <panic_loc.j>
          let data : i16 = 0x0720;
          unsafe { *((VGA_BUFF + offset) as *mut i16) = data; }
  103086:	48 89 c7             	mov    %rax,%rdi
  103089:	e8 12 11 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os6driver3vga6Writer3new17h22cf55dda78b32a8E:

0000000000103090 <_ZN13rustbucket_os6driver3vga6Writer3new17h22cf55dda78b32a8E>:
pub struct Writer {

}

impl Writer {
	pub fn new() -> Writer {
  103090:	55                   	push   %rbp
  103091:	48 89 e5             	mov    %rsp,%rbp
		Writer {

		}
	}
  103094:	5d                   	pop    %rbp
  103095:	c3                   	retq   

Disassembly of section .text._ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE:

00000000001030a0 <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE>:
}

impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
  1030a0:	55                   	push   %rbp
  1030a1:	48 89 e5             	mov    %rsp,%rbp
  1030a4:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
  1030ab:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  1030af:	48 89 7d 80          	mov    %rdi,-0x80(%rbp)
  1030b3:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  1030b7:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  1030bb:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  1030bf:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  1030c3:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  1030c7:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
  1030cb:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  1030cf:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
        for byte in s.bytes() {
  1030d3:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  1030d7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  1030db:	48 89 c7             	mov    %rax,%rdi
  1030de:	e8 ed d9 ff ff       	callq  100ad0 <_ZN41_$LT$str$u20$as$u20$core..str..StrExt$GT$5bytes17h5a544d0b11cea8d4E>
  1030e3:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
  1030e7:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  1030eb:	e8 b0 f3 ff ff       	callq  1024a0 <_ZN54_$LT$I$u20$as$u20$core..iter..traits..IntoIterator$GT$9into_iter17h5aead721d21f11abE>
  1030f0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1030f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  1030f8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  1030fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  103100:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  103104:	e8 c7 f4 ff ff       	callq  1025d0 <_ZN81_$LT$core..str..Bytes$LT$$u27$a$GT$$u20$as$u20$core..iter..iterator..Iterator$GT$4next17h051f91d177f38de8E>
  103109:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  10310d:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
  103111:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  103115:	8a 45 f8             	mov    -0x8(%rbp),%al
  103118:	84 c0                	test   %al,%al
  10311a:	75 12                	jne    10312e <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE+0x8e>
  10311c:	eb 00                	jmp    10311e <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE+0x7e>
          print_byte(byte, 0x07);
        }

        Ok(())
  10311e:	c6 45 98 00          	movb   $0x0,-0x68(%rbp)
    }
  103122:	8a 45 98             	mov    -0x68(%rbp),%al
  103125:	48 81 c4 80 00 00 00 	add    $0x80,%rsp
  10312c:	5d                   	pop    %rbp
  10312d:	c3                   	retq   
  10312e:	be 07 00 00 00       	mov    $0x7,%esi
	}
}

impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
  103133:	8a 45 f9             	mov    -0x7(%rbp),%al
  103136:	88 45 fc             	mov    %al,-0x4(%rbp)
  103139:	8a 45 fc             	mov    -0x4(%rbp),%al
  10313c:	88 45 f7             	mov    %al,-0x9(%rbp)
  10313f:	8a 45 f7             	mov    -0x9(%rbp),%al
  103142:	88 45 fd             	mov    %al,-0x3(%rbp)
          print_byte(byte, 0x07);
  103145:	0f b6 7d fd          	movzbl -0x3(%rbp),%edi
  103149:	e8 d2 fa ff ff       	callq  102c20 <_ZN13rustbucket_os6driver3vga10print_byte17ha836a9b5eebc3a78E>
	}
}

impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
  10314e:	eb b0                	jmp    103100 <_ZN71_$LT$rustbucket_os..driver..vga..Writer$u20$as$u20$core..fmt..Write$GT$9write_str17hcf025abd929e71fbE+0x60>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt10GdtPointer3new17h071d8e7313f81613E:

0000000000103150 <_ZN13rustbucket_os4arch6x86_643gdt10GdtPointer3new17h071d8e7313f81613E>:
}

//set a static variable containing the GDT pointer
//we use a static variable, since we can find its location in memory with "VAR".as_ptr()
impl GdtPointer {
    pub fn new() -> GdtPointer {
  103150:	55                   	push   %rbp
  103151:	48 89 e5             	mov    %rsp,%rbp
  103154:	48 89 f8             	mov    %rdi,%rax
        GdtPointer {
  103157:	66 c7 07 00 00       	movw   $0x0,(%rdi)
  10315c:	48 c7 47 02 00 00 00 	movq   $0x0,0x2(%rdi)
  103163:	00 
            limit: 0,
            base: 0
        }
    }
  103164:	5d                   	pop    %rbp
  103165:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E:

0000000000103170 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E>:
extern "C" { fn gdt_flush(); }

pub struct Gdt([GdtEntry; 3]);

impl Gdt {
    pub fn new() -> Gdt {
  103170:	55                   	push   %rbp
  103171:	48 89 e5             	mov    %rsp,%rbp
  103174:	48 83 ec 50          	sub    $0x50,%rsp
  103178:	48 89 f8             	mov    %rdi,%rax
        Gdt([GdtEntry::new(); 3])
  10317b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  10317f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  103183:	e8 a8 02 00 00       	callq  103430 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry3new17h279cd56506a733b1E>
  103188:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  10318c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  103190:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  103194:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  103198:	48 89 c1             	mov    %rax,%rcx
  10319b:	48 83 c1 18          	add    $0x18,%rcx
  10319f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  1031a3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  1031a7:	eb 3e                	jmp    1031e7 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E+0x77>
  1031a9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  1031ad:	48 83 c0 08          	add    $0x8,%rax
  1031b1:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1031b5:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  1031b9:	48 89 0a             	mov    %rcx,(%rdx)
  1031bc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  1031c0:	eb 25                	jmp    1031e7 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E+0x77>
  1031c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1031c6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  1031ca:	48 89 01             	mov    %rax,(%rcx)
  1031cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  1031d1:	48 89 41 08          	mov    %rax,0x8(%rcx)
  1031d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1031d9:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
  1031dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1031e1:	48 83 c4 50          	add    $0x50,%rsp
  1031e5:	5d                   	pop    %rbp
  1031e6:	c3                   	retq   
  1031e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1031eb:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  1031ef:	48 39 c8             	cmp    %rcx,%rax
  1031f2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  1031f6:	75 b1                	jne    1031a9 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E+0x39>
  1031f8:	eb c8                	jmp    1031c2 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E+0x52>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E:

0000000000103200 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E>:

    pub fn set_segment(&mut self, vector: u8, entry: GdtEntry) {
  103200:	55                   	push   %rbp
  103201:	48 89 e5             	mov    %rsp,%rbp
  103204:	48 83 ec 50          	sub    $0x50,%rsp
  103208:	40 88 f0             	mov    %sil,%al
  10320b:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  10320f:	88 45 cf             	mov    %al,-0x31(%rbp)
  103212:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  103216:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  10321a:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  10321e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  103222:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  103226:	8a 45 cf             	mov    -0x31(%rbp),%al
  103229:	88 45 ef             	mov    %al,-0x11(%rbp)
  10322c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  103230:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
        self.0[vector as usize] = entry;
  103234:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  103238:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  10323c:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  103240:	89 f2                	mov    %esi,%edx
  103242:	48 83 fa 03          	cmp    $0x3,%rdx
  103246:	0f 92 c0             	setb   %al
  103249:	a8 01                	test   $0x1,%al
  10324b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  10324f:	75 02                	jne    103253 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E+0x53>
  103251:	eb 16                	jmp    103269 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E+0x69>
  103253:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  103257:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  10325b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  10325f:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    }
  103263:	48 83 c4 50          	add    $0x50,%rsp
  103267:	5d                   	pop    %rbp
  103268:	c3                   	retq   
  103269:	48 8d 05 c8 22 00 00 	lea    0x22c8(%rip),%rax        # 105538 <panic_bounds_check_loc.l>
  103270:	b9 03 00 00 00       	mov    $0x3,%ecx
  103275:	89 ca                	mov    %ecx,%edx
    pub fn new() -> Gdt {
        Gdt([GdtEntry::new(); 3])
    }

    pub fn set_segment(&mut self, vector: u8, entry: GdtEntry) {
        self.0[vector as usize] = entry;
  103277:	48 89 c7             	mov    %rax,%rdi
  10327a:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  10327e:	e8 8d 0f 00 00       	callq  104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt3Gdt7install17he0df2274a98540bcE:

0000000000103290 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install17he0df2274a98540bcE>:
    }

    pub fn install(&self) {
  103290:	55                   	push   %rbp
  103291:	48 89 e5             	mov    %rsp,%rbp
  103294:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  10329b:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  1032a2:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  1032a9:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  1032b0:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
        let mut ptr = GdtPointer::new();
  1032b7:	48 89 c7             	mov    %rax,%rdi
  1032ba:	e8 91 fe ff ff       	callq  103150 <_ZN13rustbucket_os4arch6x86_643gdt10GdtPointer3new17h071d8e7313f81613E>
        ptr.limit = (GDT_LENGTH as u16 * size_of::<GdtEntry>() as u16) - 1;
  1032bf:	e8 4c e6 ff ff       	callq  101910 <_ZN4core3mem7size_of17hcc3e683a1252d746E>
  1032c4:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  1032cb:	66 b8 03 00          	mov    $0x3,%ax
  1032cf:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  1032d6:	66 89 ca             	mov    %cx,%dx
  1032d9:	66 89 85 5e ff ff ff 	mov    %ax,-0xa2(%rbp)
  1032e0:	66 89 d0             	mov    %dx,%ax
  1032e3:	66 8b 95 5e ff ff ff 	mov    -0xa2(%rbp),%dx
  1032ea:	66 f7 e2             	mul    %dx
  1032ed:	40 0f 90 c6          	seto   %sil
  1032f1:	40 f6 c6 01          	test   $0x1,%sil
  1032f5:	66 89 85 5c ff ff ff 	mov    %ax,-0xa4(%rbp)
  1032fc:	0f 85 01 01 00 00    	jne    103403 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install17he0df2274a98540bcE+0x173>
  103302:	66 8b 85 5c ff ff ff 	mov    -0xa4(%rbp),%ax
  103309:	66 83 e8 01          	sub    $0x1,%ax
  10330d:	0f 92 c1             	setb   %cl
  103310:	f6 c1 01             	test   $0x1,%cl
  103313:	66 89 85 5a ff ff ff 	mov    %ax,-0xa6(%rbp)
  10331a:	0f 85 f2 00 00 00    	jne    103412 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install17he0df2274a98540bcE+0x182>
  103320:	66 8b 85 5a ff ff ff 	mov    -0xa6(%rbp),%ax
  103327:	66 89 85 78 ff ff ff 	mov    %ax,-0x88(%rbp)
        ptr.base = self as *const _ as u64;
  10332e:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  103335:	48 89 8d 7a ff ff ff 	mov    %rcx,-0x86(%rbp)
  10333c:	48 8d 8d 78 ff ff ff 	lea    -0x88(%rbp),%rcx
    
        unsafe {
            asm!("lgdt ($0)" :: "r" (&ptr) : "memory");
  103343:	0f 01 11             	lgdt   (%rcx)
        }

        write!(Writer::new(), "\nSuccess! Created 64-bit GDT at address 0x{:X}\n", ptr.base);
  103346:	e8 45 fd ff ff       	callq  103090 <_ZN13rustbucket_os6driver3vga6Writer3new17h22cf55dda78b32a8E>
  10334b:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
  10334f:	48 8d 15 aa 1c 00 00 	lea    0x1caa(%rip),%rdx        # 105000 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E>
  103356:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  10335d:	48 8b 35 04 1f 00 00 	mov    0x1f04(%rip),%rsi        # 105268 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install15__STATIC_FMTSTR17h0d08357b30ebe827E>
  103364:	48 8b 0d 05 1f 00 00 	mov    0x1f05(%rip),%rcx        # 105270 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install15__STATIC_FMTSTR17h0d08357b30ebe827E+0x8>
  10336b:	48 83 c0 02          	add    $0x2,%rax
  10336f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  103373:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  103377:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  10337b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  10337f:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  103386:	48 89 c6             	mov    %rax,%rsi
  103389:	48 89 8d 48 ff ff ff 	mov    %rcx,-0xb8(%rbp)
  103390:	e8 5b e0 ff ff       	callq  1013f0 <_ZN4core3fmt10ArgumentV13new17h09e3b96240765f15E>
  103395:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  103399:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  10339d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  1033a4:	48 89 8d 38 ff ff ff 	mov    %rcx,-0xc8(%rbp)
  1033ab:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  1033af:	b8 01 00 00 00       	mov    $0x1,%eax
  1033b4:	41 89 c0             	mov    %eax,%r8d
  1033b7:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  1033bb:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  1033c2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  1033c6:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
  1033cd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  1033d1:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  1033d8:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  1033df:	e8 0c e3 ff ff       	callq  1016f0 <_ZN4core3fmt9Arguments6new_v117h11103d15dd9d6a08E>
  1033e4:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  1033e8:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
  1033ec:	e8 ff e1 ff ff       	callq  1015f0 <_ZN4core3fmt5Write9write_fmt17h78c8cffd92df3f60E>
  1033f1:	88 45 ff             	mov    %al,-0x1(%rbp)
  1033f4:	8a 45 ff             	mov    -0x1(%rbp),%al
  1033f7:	88 45 88             	mov    %al,-0x78(%rbp)
    }
  1033fa:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
  103401:	5d                   	pop    %rbp
  103402:	c3                   	retq   
  103403:	48 8d 05 46 21 00 00 	lea    0x2146(%rip),%rax        # 105550 <panic_loc.m>
        self.0[vector as usize] = entry;
    }

    pub fn install(&self) {
        let mut ptr = GdtPointer::new();
        ptr.limit = (GDT_LENGTH as u16 * size_of::<GdtEntry>() as u16) - 1;
  10340a:	48 89 c7             	mov    %rax,%rdi
  10340d:	e8 8e 0d 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103412:	48 8d 05 5f 21 00 00 	lea    0x215f(%rip),%rax        # 105578 <panic_loc.o>
  103419:	48 89 c7             	mov    %rax,%rdi
  10341c:	e8 7f 0d 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt8GdtEntry3new17h279cd56506a733b1E:

0000000000103430 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry3new17h279cd56506a733b1E>:
    }
}

impl GdtEntry {
    //constructor, since Rust does not support forward declaration
    pub const fn new() -> GdtEntry {
  103430:	55                   	push   %rbp
  103431:	48 89 e5             	mov    %rsp,%rbp
        GdtEntry {
  103434:	50                   	push   %rax
  103435:	66 c7 45 f8 00 00    	movw   $0x0,-0x8(%rbp)
  10343b:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%rbp)
  103441:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  103445:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)
  103449:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
  10344d:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
            base_high: 0,
            limit_low: 0,
            granularity: 0,
            access: 0
        }
    }
  103451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  103455:	48 83 c4 08          	add    $0x8,%rsp
  103459:	5d                   	pop    %rbp
  10345a:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt8GdtEntry6set_up17hedd3ee21b73ef6eeE:

0000000000103460 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry6set_up17hedd3ee21b73ef6eeE>:

    pub fn set_up(base_in: u32, limit_in: u32, access_in: u8, gran_in: u8) -> GdtEntry {
  103460:	55                   	push   %rbp
  103461:	48 89 e5             	mov    %rsp,%rbp
  103464:	48 83 ec 38          	sub    $0x38,%rsp
  103468:	88 c8                	mov    %cl,%al
  10346a:	41 88 d0             	mov    %dl,%r8b
  10346d:	89 7d dc             	mov    %edi,-0x24(%rbp)
  103470:	89 75 e0             	mov    %esi,-0x20(%rbp)
  103473:	44 88 45 e6          	mov    %r8b,-0x1a(%rbp)
  103477:	88 45 e7             	mov    %al,-0x19(%rbp)
  10347a:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  10347d:	89 4d f4             	mov    %ecx,-0xc(%rbp)
  103480:	8b 4d e0             	mov    -0x20(%rbp),%ecx
  103483:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  103486:	8a 45 e6             	mov    -0x1a(%rbp),%al
  103489:	88 45 fc             	mov    %al,-0x4(%rbp)
  10348c:	8a 45 e7             	mov    -0x19(%rbp),%al
  10348f:	88 45 fd             	mov    %al,-0x3(%rbp)
        let temp_flags: u8 = ((limit_in >> 16) & 0x0F) as u8;
  103492:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  103495:	c1 e9 10             	shr    $0x10,%ecx
  103498:	89 4d d8             	mov    %ecx,-0x28(%rbp)
  10349b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  10349e:	83 e0 0f             	and    $0xf,%eax
  1034a1:	88 c1                	mov    %al,%cl
  1034a3:	88 4d fe             	mov    %cl,-0x2(%rbp)
        let flags: u8 = temp_flags | ((gran_in << 4) &0xF0) as u8;
  1034a6:	8a 4d fe             	mov    -0x2(%rbp),%cl
  1034a9:	8a 55 fd             	mov    -0x3(%rbp),%dl
  1034ac:	c0 e2 04             	shl    $0x4,%dl
  1034af:	88 4d d7             	mov    %cl,-0x29(%rbp)
  1034b2:	88 55 d6             	mov    %dl,-0x2a(%rbp)
  1034b5:	8a 45 d6             	mov    -0x2a(%rbp),%al
  1034b8:	24 f0                	and    $0xf0,%al
  1034ba:	8a 4d d7             	mov    -0x29(%rbp),%cl
  1034bd:	08 c1                	or     %al,%cl
  1034bf:	88 4d ff             	mov    %cl,-0x1(%rbp)

        GdtEntry {
            //set the base (offset) of the entry
            base_low: base_in as u16,
  1034c2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  1034c5:	66 89 d6             	mov    %dx,%si
            base_middle: (base_in >> 16) as u8,
  1034c8:	8b 55 f4             	mov    -0xc(%rbp),%edx
  1034cb:	c1 ea 10             	shr    $0x10,%edx
  1034ce:	66 89 75 d4          	mov    %si,-0x2c(%rbp)
  1034d2:	89 55 d0             	mov    %edx,-0x30(%rbp)
  1034d5:	8b 45 d0             	mov    -0x30(%rbp),%eax
  1034d8:	88 c1                	mov    %al,%cl
            base_high: (base_in >> 24) as u8,
  1034da:	8b 55 f4             	mov    -0xc(%rbp),%edx
  1034dd:	c1 ea 18             	shr    $0x18,%edx
  1034e0:	88 4d cf             	mov    %cl,-0x31(%rbp)
  1034e3:	89 55 c8             	mov    %edx,-0x38(%rbp)
  1034e6:	8b 45 c8             	mov    -0x38(%rbp),%eax
  1034e9:	88 c1                	mov    %al,%cl

            //set the size of the entry
            limit_low: limit_in as u16,
  1034eb:	8b 55 f8             	mov    -0x8(%rbp),%edx
  1034ee:	66 89 d6             	mov    %dx,%si
            granularity: flags,
  1034f1:	40 8a 7d ff          	mov    -0x1(%rbp),%dil

            //set the access level of the entry
            access: access_in
  1034f5:	44 8a 45 fc          	mov    -0x4(%rbp),%r8b

    pub fn set_up(base_in: u32, limit_in: u32, access_in: u8, gran_in: u8) -> GdtEntry {
        let temp_flags: u8 = ((limit_in >> 16) & 0x0F) as u8;
        let flags: u8 = temp_flags | ((gran_in << 4) &0xF0) as u8;

        GdtEntry {
  1034f9:	66 89 75 e8          	mov    %si,-0x18(%rbp)
  1034fd:	66 8b 75 d4          	mov    -0x2c(%rbp),%si
  103501:	66 89 75 ea          	mov    %si,-0x16(%rbp)
  103505:	44 8a 4d cf          	mov    -0x31(%rbp),%r9b
  103509:	44 88 4d ec          	mov    %r9b,-0x14(%rbp)
  10350d:	44 88 45 ed          	mov    %r8b,-0x13(%rbp)
  103511:	40 88 7d ee          	mov    %dil,-0x12(%rbp)
  103515:	88 4d ef             	mov    %cl,-0x11(%rbp)
            granularity: flags,

            //set the access level of the entry
            access: access_in
        }
    }
  103518:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10351c:	48 83 c4 38          	add    $0x38,%rsp
  103520:	5d                   	pop    %rbp
  103521:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643gdt8gdt_init17ha467834baa059034E:

0000000000103530 <_ZN13rustbucket_os4arch6x86_643gdt8gdt_init17ha467834baa059034E>:
}

pub fn gdt_init() {
  103530:	55                   	push   %rbp
  103531:	48 89 e5             	mov    %rsp,%rbp
  103534:	48 83 ec 60          	sub    $0x60,%rsp
  103538:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
    //set access flags for code segments
    let code_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  10353c:	c6 45 ad 02          	movb   $0x2,-0x53(%rbp)
  103540:	8a 45 ad             	mov    -0x53(%rbp),%al
        AccessFlags::Executable as u8 |
  103543:	c6 45 ae 08          	movb   $0x8,-0x52(%rbp)
  103547:	8a 4d ae             	mov    -0x52(%rbp),%cl
}

pub fn gdt_init() {
    //set access flags for code segments
    let code_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  10354a:	08 c8                	or     %cl,%al
        AccessFlags::Executable as u8 |
        AccessFlags::One as u8 |
  10354c:	c6 45 af 10          	movb   $0x10,-0x51(%rbp)
  103550:	8a 4d af             	mov    -0x51(%rbp),%cl
}

pub fn gdt_init() {
    //set access flags for code segments
    let code_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  103553:	08 c8                	or     %cl,%al
        AccessFlags::Executable as u8 |
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
  103555:	c6 45 b0 80          	movb   $0x80,-0x50(%rbp)
  103559:	8a 4d b0             	mov    -0x50(%rbp),%cl
}

pub fn gdt_init() {
    //set access flags for code segments
    let code_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  10355c:	08 c8                	or     %cl,%al
  10355e:	88 45 ac             	mov    %al,-0x54(%rbp)
        AccessFlags::Executable as u8 |
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
    //set access flags for data segments
    let data_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  103561:	c6 45 b2 02          	movb   $0x2,-0x4e(%rbp)
  103565:	8a 45 b2             	mov    -0x4e(%rbp),%al
        AccessFlags::One as u8 |
  103568:	c6 45 b3 10          	movb   $0x10,-0x4d(%rbp)
  10356c:	8a 4d b3             	mov    -0x4d(%rbp),%cl
        AccessFlags::Executable as u8 |
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
    //set access flags for data segments
    let data_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  10356f:	08 c8                	or     %cl,%al
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
  103571:	c6 45 b4 80          	movb   $0x80,-0x4c(%rbp)
  103575:	8a 4d b4             	mov    -0x4c(%rbp),%cl
        AccessFlags::Executable as u8 |
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
    //set access flags for data segments
    let data_flags: u8 =
        AccessFlags::ReadWrite as u8 |
  103578:	08 c8                	or     %cl,%al
  10357a:	88 45 b1             	mov    %al,-0x4f(%rbp)
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
    //set granularity flags, indicate a 64-bit table
    let granularity_flags: u8 =
        GranularityFlags::Page as u8 |
  10357d:	c6 45 b6 08          	movb   $0x8,-0x4a(%rbp)
  103581:	8a 45 b6             	mov    -0x4a(%rbp),%al
        GranularityFlags::LongMode_64 as u8;
  103584:	c6 45 b7 02          	movb   $0x2,-0x49(%rbp)
  103588:	8a 4d b7             	mov    -0x49(%rbp),%cl
        AccessFlags::ReadWrite as u8 |
        AccessFlags::One as u8 |
        AccessFlags::Present as u8;
    //set granularity flags, indicate a 64-bit table
    let granularity_flags: u8 =
        GranularityFlags::Page as u8 |
  10358b:	08 c8                	or     %cl,%al
  10358d:	88 45 b5             	mov    %al,-0x4b(%rbp)
        GranularityFlags::LongMode_64 as u8;

    let mut gdt = Gdt::new();
  103590:	e8 db fb ff ff       	callq  103170 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt3new17hfc6114e8fda2bfc2E>
  103595:	31 c0                	xor    %eax,%eax

    //set up gdt entries
    gdt.set_segment(0, GdtEntry::set_up(0, 0, 0, 0));
  103597:	89 c7                	mov    %eax,%edi
  103599:	89 c6                	mov    %eax,%esi
  10359b:	89 c2                	mov    %eax,%edx
  10359d:	89 c1                	mov    %eax,%ecx
  10359f:	e8 bc fe ff ff       	callq  103460 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry6set_up17hedd3ee21b73ef6eeE>
  1035a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  1035a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1035ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  1035b0:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  1035b4:	31 f6                	xor    %esi,%esi
  1035b6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  1035ba:	e8 41 fc ff ff       	callq  103200 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E>
  1035bf:	31 ff                	xor    %edi,%edi
  1035c1:	be ff ff 0f 00       	mov    $0xfffff,%esi
    gdt.set_segment(1, GdtEntry::set_up(0, 0xFFFFF, code_flags, granularity_flags));
  1035c6:	8a 45 ac             	mov    -0x54(%rbp),%al
  1035c9:	0f b6 d0             	movzbl %al,%edx
  1035cc:	0f b6 4d b5          	movzbl -0x4b(%rbp),%ecx
  1035d0:	e8 8b fe ff ff       	callq  103460 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry6set_up17hedd3ee21b73ef6eeE>
  1035d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  1035d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1035dd:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  1035e1:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  1035e5:	be 01 00 00 00       	mov    $0x1,%esi
  1035ea:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1035ee:	e8 0d fc ff ff       	callq  103200 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E>
  1035f3:	31 ff                	xor    %edi,%edi
  1035f5:	be ff ff 0f 00       	mov    $0xfffff,%esi
    gdt.set_segment(2, GdtEntry::set_up(0, 0xFFFFF, data_flags, granularity_flags));
  1035fa:	8a 45 b1             	mov    -0x4f(%rbp),%al
  1035fd:	0f b6 d0             	movzbl %al,%edx
  103600:	0f b6 4d b5          	movzbl -0x4b(%rbp),%ecx
  103604:	e8 57 fe ff ff       	callq  103460 <_ZN13rustbucket_os4arch6x86_643gdt8GdtEntry6set_up17hedd3ee21b73ef6eeE>
  103609:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  10360d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  103611:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  103615:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
  103619:	be 02 00 00 00       	mov    $0x2,%esi
  10361e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  103622:	e8 d9 fb ff ff       	callq  103200 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt11set_segment17ha6c6ea308af034e5E>
  103627:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi

    gdt.install();
  10362b:	e8 60 fc ff ff       	callq  103290 <_ZN13rustbucket_os4arch6x86_643gdt3Gdt7install17he0df2274a98540bcE>
}
  103630:	48 83 c4 60          	add    $0x60,%rsp
  103634:	5d                   	pop    %rbp
  103635:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt10IdtPointer3new17h6564721221009265E:

0000000000103640 <_ZN13rustbucket_os4arch6x86_643idt10IdtPointer3new17h6564721221009265E>:
}

//set a static variable containing the IDT pointer
//we use a static variable, since we can find its location in memory with "VAR".as_ptr()
impl IdtPointer {
    pub fn new() -> IdtPointer {
  103640:	55                   	push   %rbp
  103641:	48 89 e5             	mov    %rsp,%rbp
  103644:	48 89 f8             	mov    %rdi,%rax
        IdtPointer {
  103647:	66 c7 07 00 00       	movw   $0x0,(%rdi)
  10364c:	48 c7 47 02 00 00 00 	movq   $0x0,0x2(%rdi)
  103653:	00 
            limit: 0,
            base: 0
        }
    }
  103654:	5d                   	pop    %rbp
  103655:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE:

0000000000103660 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE>:
}

pub struct Idt([IdtEntry; 256]);

impl Idt {
    pub fn new() -> Idt {
  103660:	55                   	push   %rbp
  103661:	48 89 e5             	mov    %rsp,%rbp
  103664:	48 81 ec 40 10 00 00 	sub    $0x1040,%rsp
  10366b:	48 89 f8             	mov    %rdi,%rax
  10366e:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
        Idt([IdtEntry::missing(); 256])
  103672:	48 89 bd e8 ef ff ff 	mov    %rdi,-0x1018(%rbp)
  103679:	48 89 cf             	mov    %rcx,%rdi
  10367c:	48 89 85 e0 ef ff ff 	mov    %rax,-0x1020(%rbp)
  103683:	e8 d8 02 00 00       	callq  103960 <_ZN13rustbucket_os4arch6x86_643idt8IdtEntry7missing17h1c6e0f4c0ae5ee92E>
  103688:	48 8d 85 f0 ef ff ff 	lea    -0x1010(%rbp),%rax
  10368f:	48 89 c1             	mov    %rax,%rcx
  103692:	48 81 c1 00 10 00 00 	add    $0x1000,%rcx
  103699:	48 89 8d d8 ef ff ff 	mov    %rcx,-0x1028(%rbp)
  1036a0:	48 89 85 d0 ef ff ff 	mov    %rax,-0x1030(%rbp)
  1036a7:	eb 5a                	jmp    103703 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE+0xa3>
  1036a9:	48 8b 85 c8 ef ff ff 	mov    -0x1038(%rbp),%rax
  1036b0:	48 83 c0 10          	add    $0x10,%rax
  1036b4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1036b8:	48 8b 95 c8 ef ff ff 	mov    -0x1038(%rbp),%rdx
  1036bf:	48 89 0a             	mov    %rcx,(%rdx)
  1036c2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  1036c6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  1036ca:	48 89 85 d0 ef ff ff 	mov    %rax,-0x1030(%rbp)
  1036d1:	eb 30                	jmp    103703 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE+0xa3>
  1036d3:	b8 00 10 00 00       	mov    $0x1000,%eax
  1036d8:	89 c2                	mov    %eax,%edx
  1036da:	48 8d 8d f0 ef ff ff 	lea    -0x1010(%rbp),%rcx
  1036e1:	48 8b b5 e8 ef ff ff 	mov    -0x1018(%rbp),%rsi
  1036e8:	48 89 f7             	mov    %rsi,%rdi
  1036eb:	48 89 ce             	mov    %rcx,%rsi
  1036ee:	e8 fd 09 00 00       	callq  1040f0 <memcpy>
    }
  1036f3:	48 8b 85 e0 ef ff ff 	mov    -0x1020(%rbp),%rax
  1036fa:	48 81 c4 40 10 00 00 	add    $0x1040,%rsp
  103701:	5d                   	pop    %rbp
  103702:	c3                   	retq   
  103703:	48 8b 85 d0 ef ff ff 	mov    -0x1030(%rbp),%rax
  10370a:	48 8b 8d d8 ef ff ff 	mov    -0x1028(%rbp),%rcx
  103711:	48 39 c8             	cmp    %rcx,%rax
  103714:	48 89 85 c8 ef ff ff 	mov    %rax,-0x1038(%rbp)
  10371b:	75 8c                	jne    1036a9 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE+0x49>
  10371d:	eb b4                	jmp    1036d3 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE+0x73>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E:

0000000000103720 <_ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E>:

    pub fn set_handler(&mut self, vector: u8, func: unsafe extern "C" fn()) {
  103720:	55                   	push   %rbp
  103721:	48 89 e5             	mov    %rsp,%rbp
  103724:	48 83 ec 50          	sub    $0x50,%rsp
  103728:	40 88 f0             	mov    %sil,%al
  10372b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  10372f:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
  103733:	88 45 cf             	mov    %al,-0x31(%rbp)
  103736:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  10373a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  10373e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  103742:	8a 45 cf             	mov    -0x31(%rbp),%al
  103745:	88 45 e7             	mov    %al,-0x19(%rbp)
  103748:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  10374c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        self.0[vector as usize] = IdtEntry::new(func);
  103750:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  103754:	48 89 cf             	mov    %rcx,%rdi
  103757:	e8 34 02 00 00       	callq  103990 <_ZN13rustbucket_os4arch6x86_643idt8IdtEntry3new17hcc2a8d95fa6ab2a2E>
  10375c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  103760:	89 c1                	mov    %eax,%ecx
  103762:	48 81 f9 00 01 00 00 	cmp    $0x100,%rcx
  103769:	0f 92 c2             	setb   %dl
  10376c:	f6 c2 01             	test   $0x1,%dl
  10376f:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  103773:	75 02                	jne    103777 <_ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E+0x57>
  103775:	eb 24                	jmp    10379b <_ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E+0x7b>
  103777:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  10377b:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  10377f:	48 c1 e1 04          	shl    $0x4,%rcx
  103783:	48 01 c8             	add    %rcx,%rax
  103786:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  10378a:	48 89 08             	mov    %rcx,(%rax)
  10378d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  103791:	48 89 48 08          	mov    %rcx,0x8(%rax)
    }
  103795:	48 83 c4 50          	add    $0x50,%rsp
  103799:	5d                   	pop    %rbp
  10379a:	c3                   	retq   
  10379b:	48 8d 05 fe 1d 00 00 	lea    0x1dfe(%rip),%rax        # 1055a0 <panic_bounds_check_loc.q>
  1037a2:	b9 00 01 00 00       	mov    $0x100,%ecx
  1037a7:	89 ca                	mov    %ecx,%edx
    pub fn new() -> Idt {
        Idt([IdtEntry::missing(); 256])
    }

    pub fn set_handler(&mut self, vector: u8, func: unsafe extern "C" fn()) {
        self.0[vector as usize] = IdtEntry::new(func);
  1037a9:	48 89 c7             	mov    %rax,%rdi
  1037ac:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  1037b0:	e8 5b 0a 00 00       	callq  104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt3Idt7install17hb2896a79efe007e8E:

00000000001037c0 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install17hb2896a79efe007e8E>:
    }

    pub fn install(&self) {
  1037c0:	55                   	push   %rbp
  1037c1:	48 89 e5             	mov    %rsp,%rbp
  1037c4:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  1037cb:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  1037d2:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  1037d9:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
  1037e0:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
        let mut ptr = IdtPointer::new();
  1037e7:	48 89 c7             	mov    %rax,%rdi
  1037ea:	e8 51 fe ff ff       	callq  103640 <_ZN13rustbucket_os4arch6x86_643idt10IdtPointer3new17h6564721221009265E>
        ptr.limit = (IDT_LENGTH as u16 * size_of::<IdtEntry>() as u16) - 1;
  1037ef:	e8 8c e0 ff ff       	callq  101880 <_ZN4core3mem7size_of17h2a0b979ce20d266aE>
  1037f4:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  1037fb:	66 b8 00 01          	mov    $0x100,%ax
  1037ff:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  103806:	66 89 ca             	mov    %cx,%dx
  103809:	66 89 85 5e ff ff ff 	mov    %ax,-0xa2(%rbp)
  103810:	66 89 d0             	mov    %dx,%ax
  103813:	66 8b 95 5e ff ff ff 	mov    -0xa2(%rbp),%dx
  10381a:	66 f7 e2             	mul    %dx
  10381d:	40 0f 90 c6          	seto   %sil
  103821:	40 f6 c6 01          	test   $0x1,%sil
  103825:	66 89 85 5c ff ff ff 	mov    %ax,-0xa4(%rbp)
  10382c:	0f 85 01 01 00 00    	jne    103933 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install17hb2896a79efe007e8E+0x173>
  103832:	66 8b 85 5c ff ff ff 	mov    -0xa4(%rbp),%ax
  103839:	66 83 e8 01          	sub    $0x1,%ax
  10383d:	0f 92 c1             	setb   %cl
  103840:	f6 c1 01             	test   $0x1,%cl
  103843:	66 89 85 5a ff ff ff 	mov    %ax,-0xa6(%rbp)
  10384a:	0f 85 f2 00 00 00    	jne    103942 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install17hb2896a79efe007e8E+0x182>
  103850:	66 8b 85 5a ff ff ff 	mov    -0xa6(%rbp),%ax
  103857:	66 89 85 78 ff ff ff 	mov    %ax,-0x88(%rbp)
        ptr.base = self as *const _ as u64;
  10385e:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  103865:	48 89 8d 7a ff ff ff 	mov    %rcx,-0x86(%rbp)
  10386c:	48 8d 8d 78 ff ff ff 	lea    -0x88(%rbp),%rcx

        unsafe {
            asm!("lidt ($0)" :: "r" (&ptr) : "memory");
  103873:	0f 01 19             	lidt   (%rcx)
        }

        write!(Writer::new(), "Success! Created 64-bit IDT at address 0x{:X}\n", ptr.base);
  103876:	e8 15 f8 ff ff       	callq  103090 <_ZN13rustbucket_os6driver3vga6Writer3new17h22cf55dda78b32a8E>
  10387b:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
  10387f:	48 8d 15 7a 17 00 00 	lea    0x177a(%rip),%rdx        # 105000 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E>
  103886:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  10388d:	48 8b 35 e4 19 00 00 	mov    0x19e4(%rip),%rsi        # 105278 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install15__STATIC_FMTSTR17h29d73ef6837b59adE>
  103894:	48 8b 0d e5 19 00 00 	mov    0x19e5(%rip),%rcx        # 105280 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install15__STATIC_FMTSTR17h29d73ef6837b59adE+0x8>
  10389b:	48 83 c0 02          	add    $0x2,%rax
  10389f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  1038a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1038a7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  1038ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  1038af:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  1038b6:	48 89 c6             	mov    %rax,%rsi
  1038b9:	48 89 8d 48 ff ff ff 	mov    %rcx,-0xb8(%rbp)
  1038c0:	e8 2b db ff ff       	callq  1013f0 <_ZN4core3fmt10ArgumentV13new17h09e3b96240765f15E>
  1038c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1038c9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1038cd:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  1038d4:	48 89 8d 38 ff ff ff 	mov    %rcx,-0xc8(%rbp)
  1038db:	48 8d 7d 98          	lea    -0x68(%rbp),%rdi
  1038df:	b8 01 00 00 00       	mov    $0x1,%eax
  1038e4:	41 89 c0             	mov    %eax,%r8d
  1038e7:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  1038eb:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  1038f2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  1038f6:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
  1038fd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  103901:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  103908:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
  10390f:	e8 dc dd ff ff       	callq  1016f0 <_ZN4core3fmt9Arguments6new_v117h11103d15dd9d6a08E>
  103914:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
  103918:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
  10391c:	e8 cf dc ff ff       	callq  1015f0 <_ZN4core3fmt5Write9write_fmt17h78c8cffd92df3f60E>
  103921:	88 45 ff             	mov    %al,-0x1(%rbp)
  103924:	8a 45 ff             	mov    -0x1(%rbp),%al
  103927:	88 45 88             	mov    %al,-0x78(%rbp)
    }
  10392a:	48 81 c4 d0 00 00 00 	add    $0xd0,%rsp
  103931:	5d                   	pop    %rbp
  103932:	c3                   	retq   
  103933:	48 8d 05 7e 1c 00 00 	lea    0x1c7e(%rip),%rax        # 1055b8 <panic_loc.r>
        self.0[vector as usize] = IdtEntry::new(func);
    }

    pub fn install(&self) {
        let mut ptr = IdtPointer::new();
        ptr.limit = (IDT_LENGTH as u16 * size_of::<IdtEntry>() as u16) - 1;
  10393a:	48 89 c7             	mov    %rax,%rdi
  10393d:	e8 5e 08 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103942:	48 8d 05 97 1c 00 00 	lea    0x1c97(%rip),%rax        # 1055e0 <panic_loc.s>
  103949:	48 89 c7             	mov    %rax,%rdi
  10394c:	e8 4f 08 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt8IdtEntry7missing17h1c6e0f4c0ae5ee92E:

0000000000103960 <_ZN13rustbucket_os4arch6x86_643idt8IdtEntry7missing17h1c6e0f4c0ae5ee92E>:
//we use a static variable, since we can find its location in memory with "VAR".as_ptr()
//let mut IDT: [IdtEntry; 256] = [IdtEntry::missing(); 256];

impl IdtEntry {
    //constructor, since Rust does not support forward declaration
    pub const fn missing() -> IdtEntry {
  103960:	55                   	push   %rbp
  103961:	48 89 e5             	mov    %rsp,%rbp
  103964:	48 89 f8             	mov    %rdi,%rax
        IdtEntry {
  103967:	66 c7 07 00 00       	movw   $0x0,(%rdi)
  10396c:	66 c7 47 02 00 00    	movw   $0x0,0x2(%rdi)
  103972:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
  103976:	c6 47 05 00          	movb   $0x0,0x5(%rdi)
  10397a:	66 c7 47 06 00 00    	movw   $0x0,0x6(%rdi)
  103980:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%rdi)
  103987:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
            flags: 0,
            base_middle: 0,
            base_high: 0,
            zero2: 0
        }
    }
  10398e:	5d                   	pop    %rbp
  10398f:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt8IdtEntry3new17hcc2a8d95fa6ab2a2E:

0000000000103990 <_ZN13rustbucket_os4arch6x86_643idt8IdtEntry3new17hcc2a8d95fa6ab2a2E>:

    pub fn new(func: unsafe extern "C" fn()) -> IdtEntry {
  103990:	55                   	push   %rbp
  103991:	48 89 e5             	mov    %rsp,%rbp
  103994:	48 83 ec 50          	sub    $0x50,%rsp
  103998:	48 89 f8             	mov    %rdi,%rax
  10399b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10399f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1039a3:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
        let pointer = func as u64;
  1039a7:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  1039ab:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

        IdtEntry {
            base_low: pointer as u16,
  1039af:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  1039b3:	66 89 f1             	mov    %si,%cx
            base_middle: (pointer >> 16) as u16,
  1039b6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  1039ba:	48 c1 ee 10          	shr    $0x10,%rsi
  1039be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  1039c2:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  1039c6:	66 89 4d ce          	mov    %cx,-0x32(%rbp)
  1039ca:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  1039ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1039d2:	66 89 c1             	mov    %ax,%cx
            base_high: (pointer >> 32) as u32,
  1039d5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1039d9:	48 c1 ea 20          	shr    $0x20,%rdx
  1039dd:	66 89 4d be          	mov    %cx,-0x42(%rbp)
  1039e1:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  1039e5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  1039e9:	89 c1                	mov    %eax,%ecx
            selector: 8,

            zero1: 0,
            zero2: 0,

            flags: EntryFlags::InterruptGate as u8 | EntryFlags::Present as u8
  1039eb:	c6 45 fe 0e          	movb   $0xe,-0x2(%rbp)
  1039ef:	8a 55 fe             	mov    -0x2(%rbp),%dl
  1039f2:	c6 45 ff 80          	movb   $0x80,-0x1(%rbp)
  1039f6:	40 8a 75 ff          	mov    -0x1(%rbp),%sil
  1039fa:	40 08 f2             	or     %sil,%dl
    }

    pub fn new(func: unsafe extern "C" fn()) -> IdtEntry {
        let pointer = func as u64;

        IdtEntry {
  1039fd:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  103a01:	66 44 8b 45 ce       	mov    -0x32(%rbp),%r8w
  103a06:	66 44 89 07          	mov    %r8w,(%rdi)
  103a0a:	66 c7 47 02 08 00    	movw   $0x8,0x2(%rdi)
  103a10:	c6 47 04 00          	movb   $0x0,0x4(%rdi)
  103a14:	88 57 05             	mov    %dl,0x5(%rdi)
  103a17:	66 44 8b 4d be       	mov    -0x42(%rbp),%r9w
  103a1c:	66 44 89 4f 06       	mov    %r9w,0x6(%rdi)
  103a21:	89 4f 08             	mov    %ecx,0x8(%rdi)
  103a24:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
            zero1: 0,
            zero2: 0,

            flags: EntryFlags::InterruptGate as u8 | EntryFlags::Present as u8
        }
    }
  103a2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  103a2f:	48 83 c4 50          	add    $0x50,%rsp
  103a33:	5d                   	pop    %rbp
  103a34:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch6x86_643idt8idt_init17h0d2bd7a98c3018deE:

0000000000103a40 <_ZN13rustbucket_os4arch6x86_643idt8idt_init17h0d2bd7a98c3018deE>:

extern "C" { fn isr_stub(); }
extern "C" { fn isr_except_stub(); }

// Initialise IDT
pub fn idt_init() {
  103a40:	55                   	push   %rbp
  103a41:	48 89 e5             	mov    %rsp,%rbp
  103a44:	48 81 ec 00 10 00 00 	sub    $0x1000,%rsp
  103a4b:	48 8d bd 00 f0 ff ff 	lea    -0x1000(%rbp),%rdi
    unsafe {
        let mut IDT = Idt::new();
  103a52:	e8 09 fc ff ff       	callq  103660 <_ZN13rustbucket_os4arch6x86_643idt3Idt3new17h91d2a75a9f61ae5cE>
  103a57:	48 8d bd 00 f0 ff ff 	lea    -0x1000(%rbp),%rdi
  103a5e:	31 f6                	xor    %esi,%esi
  103a60:	48 8b 15 e1 17 00 00 	mov    0x17e1(%rip),%rdx        # 105248 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0x128>

        // Set ISR handlers
        IDT.set_handler(0, isr_except_stub); // Divide by zero
  103a67:	e8 b4 fc ff ff       	callq  103720 <_ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E>
  103a6c:	48 8d bd 00 f0 ff ff 	lea    -0x1000(%rbp),%rdi
  103a73:	be 21 00 00 00       	mov    $0x21,%esi
  103a78:	48 8b 15 c1 17 00 00 	mov    0x17c1(%rip),%rdx        # 105240 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0x120>
        IDT.set_handler(33, isr_stub); // Keyboard
  103a7f:	e8 9c fc ff ff       	callq  103720 <_ZN13rustbucket_os4arch6x86_643idt3Idt11set_handler17h8edd3fc4b6eb3ab5E>
  103a84:	48 8d bd 00 f0 ff ff 	lea    -0x1000(%rbp),%rdi

        IDT.install();
  103a8b:	e8 30 fd ff ff       	callq  1037c0 <_ZN13rustbucket_os4arch6x86_643idt3Idt7install17hb2896a79efe007e8E>
    }
}
  103a90:	48 81 c4 00 10 00 00 	add    $0x1000,%rsp
  103a97:	5d                   	pop    %rbp
  103a98:	c3                   	retq   

Disassembly of section .text.pic_init:

0000000000103aa0 <pic_init>:
//PIC vector offsets
const PIC_OFFSET_MASTER: u8 = 32; //offset the PIC indexes by 32
const PIC_OFFSET_SLAVE: u8 = PIC_OFFSET_MASTER + 8;

#[no_mangle]
pub fn pic_init() {
  103aa0:	55                   	push   %rbp
  103aa1:	48 89 e5             	mov    %rsp,%rbp
  103aa4:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  103aab:	66 c7 45 90 20 00    	movw   $0x20,-0x70(%rbp)
  103ab1:	c6 45 93 11          	movb   $0x11,-0x6d(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103ab5:	66 8b 45 90          	mov    -0x70(%rbp),%ax
  103ab9:	66 89 45 94          	mov    %ax,-0x6c(%rbp)
  103abd:	8a 4d 93             	mov    -0x6d(%rbp),%cl
  103ac0:	88 4d 97             	mov    %cl,-0x69(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103ac3:	66 8b 55 94          	mov    -0x6c(%rbp),%dx
  103ac7:	8a 45 97             	mov    -0x69(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103aca:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103acb:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)

    while i < 150 {
  103ad2:	81 7d 98 96 00 00 00 	cmpl   $0x96,-0x68(%rbp)
  103ad9:	7d 27                	jge    103b02 <pic_init+0x62>
        i = i + 1;
  103adb:	8b 45 98             	mov    -0x68(%rbp),%eax
  103ade:	ff c0                	inc    %eax
  103ae0:	0f 90 c1             	seto   %cl
  103ae3:	f6 c1 01             	test   $0x1,%cl
  103ae6:	89 45 8c             	mov    %eax,-0x74(%rbp)
  103ae9:	75 08                	jne    103af3 <pic_init+0x53>
  103aeb:	8b 45 8c             	mov    -0x74(%rbp),%eax
  103aee:	89 45 98             	mov    %eax,-0x68(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103af1:	eb df                	jmp    103ad2 <pic_init+0x32>
  103af3:	48 8d 05 0e 1b 00 00 	lea    0x1b0e(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103afa:	48 89 c7             	mov    %rax,%rdi
  103afd:	e8 9e 06 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
    unsafe {
        //start the initialisation of the PICs
        port_io::outb(PIC_MASTER_COMMAND, ICW1_INIT | ICW1_ICW4);
        port_io::wait();
  103b02:	eb 00                	jmp    103b04 <pic_init+0x64>
  103b04:	66 c7 45 9c a0 00    	movw   $0xa0,-0x64(%rbp)
  103b0a:	c6 45 9f 11          	movb   $0x11,-0x61(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103b0e:	66 8b 45 9c          	mov    -0x64(%rbp),%ax
  103b12:	66 89 45 a0          	mov    %ax,-0x60(%rbp)
  103b16:	8a 4d 9f             	mov    -0x61(%rbp),%cl
  103b19:	88 4d a3             	mov    %cl,-0x5d(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103b1c:	66 8b 55 a0          	mov    -0x60(%rbp),%dx
  103b20:	8a 45 a3             	mov    -0x5d(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103b23:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103b24:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)

    while i < 150 {
  103b2b:	81 7d a4 96 00 00 00 	cmpl   $0x96,-0x5c(%rbp)
  103b32:	7d 27                	jge    103b5b <pic_init+0xbb>
        i = i + 1;
  103b34:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  103b37:	ff c0                	inc    %eax
  103b39:	0f 90 c1             	seto   %cl
  103b3c:	f6 c1 01             	test   $0x1,%cl
  103b3f:	89 45 88             	mov    %eax,-0x78(%rbp)
  103b42:	75 08                	jne    103b4c <pic_init+0xac>
  103b44:	8b 45 88             	mov    -0x78(%rbp),%eax
  103b47:	89 45 a4             	mov    %eax,-0x5c(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103b4a:	eb df                	jmp    103b2b <pic_init+0x8b>
  103b4c:	48 8d 05 b5 1a 00 00 	lea    0x1ab5(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103b53:	48 89 c7             	mov    %rax,%rdi
  103b56:	e8 45 06 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
        port_io::outb(PIC_SLAVE_COMMAND, ICW1_INIT | ICW1_ICW4);
        port_io::wait();
  103b5b:	eb 00                	jmp    103b5d <pic_init+0xbd>
  103b5d:	66 c7 45 a8 21 00    	movw   $0x21,-0x58(%rbp)
  103b63:	c6 45 ab 20          	movb   $0x20,-0x55(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103b67:	66 8b 45 a8          	mov    -0x58(%rbp),%ax
  103b6b:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  103b6f:	8a 4d ab             	mov    -0x55(%rbp),%cl
  103b72:	88 4d af             	mov    %cl,-0x51(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103b75:	66 8b 55 ac          	mov    -0x54(%rbp),%dx
  103b79:	8a 45 af             	mov    -0x51(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103b7c:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103b7d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

    while i < 150 {
  103b84:	81 7d b0 96 00 00 00 	cmpl   $0x96,-0x50(%rbp)
  103b8b:	7d 27                	jge    103bb4 <pic_init+0x114>
        i = i + 1;
  103b8d:	8b 45 b0             	mov    -0x50(%rbp),%eax
  103b90:	ff c0                	inc    %eax
  103b92:	0f 90 c1             	seto   %cl
  103b95:	f6 c1 01             	test   $0x1,%cl
  103b98:	89 45 84             	mov    %eax,-0x7c(%rbp)
  103b9b:	75 08                	jne    103ba5 <pic_init+0x105>
  103b9d:	8b 45 84             	mov    -0x7c(%rbp),%eax
  103ba0:	89 45 b0             	mov    %eax,-0x50(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103ba3:	eb df                	jmp    103b84 <pic_init+0xe4>
  103ba5:	48 8d 05 5c 1a 00 00 	lea    0x1a5c(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103bac:	48 89 c7             	mov    %rax,%rdi
  103baf:	e8 ec 05 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

        //provide the PIC vector offsets
        port_io::outb(PIC_MASTER_DATA, PIC_OFFSET_MASTER);
        port_io::wait();
  103bb4:	eb 00                	jmp    103bb6 <pic_init+0x116>
  103bb6:	66 c7 45 b4 a1 00    	movw   $0xa1,-0x4c(%rbp)
  103bbc:	c6 45 b7 28          	movb   $0x28,-0x49(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103bc0:	66 8b 45 b4          	mov    -0x4c(%rbp),%ax
  103bc4:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
  103bc8:	8a 4d b7             	mov    -0x49(%rbp),%cl
  103bcb:	88 4d bb             	mov    %cl,-0x45(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103bce:	66 8b 55 b8          	mov    -0x48(%rbp),%dx
  103bd2:	8a 45 bb             	mov    -0x45(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103bd5:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103bd6:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)

    while i < 150 {
  103bdd:	81 7d bc 96 00 00 00 	cmpl   $0x96,-0x44(%rbp)
  103be4:	7d 27                	jge    103c0d <pic_init+0x16d>
        i = i + 1;
  103be6:	8b 45 bc             	mov    -0x44(%rbp),%eax
  103be9:	ff c0                	inc    %eax
  103beb:	0f 90 c1             	seto   %cl
  103bee:	f6 c1 01             	test   $0x1,%cl
  103bf1:	89 45 80             	mov    %eax,-0x80(%rbp)
  103bf4:	75 08                	jne    103bfe <pic_init+0x15e>
  103bf6:	8b 45 80             	mov    -0x80(%rbp),%eax
  103bf9:	89 45 bc             	mov    %eax,-0x44(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103bfc:	eb df                	jmp    103bdd <pic_init+0x13d>
  103bfe:	48 8d 05 03 1a 00 00 	lea    0x1a03(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103c05:	48 89 c7             	mov    %rax,%rdi
  103c08:	e8 93 05 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
        port_io::outb(PIC_SLAVE_DATA, PIC_OFFSET_SLAVE);
        port_io::wait();
  103c0d:	eb 00                	jmp    103c0f <pic_init+0x16f>
  103c0f:	66 c7 45 c0 21 00    	movw   $0x21,-0x40(%rbp)
  103c15:	c6 45 c3 04          	movb   $0x4,-0x3d(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103c19:	66 8b 45 c0          	mov    -0x40(%rbp),%ax
  103c1d:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  103c21:	8a 4d c3             	mov    -0x3d(%rbp),%cl
  103c24:	88 4d c7             	mov    %cl,-0x39(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103c27:	66 8b 55 c4          	mov    -0x3c(%rbp),%dx
  103c2b:	8a 45 c7             	mov    -0x39(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103c2e:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103c2f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)

    while i < 150 {
  103c36:	81 7d c8 96 00 00 00 	cmpl   $0x96,-0x38(%rbp)
  103c3d:	7d 2d                	jge    103c6c <pic_init+0x1cc>
        i = i + 1;
  103c3f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  103c42:	ff c0                	inc    %eax
  103c44:	0f 90 c1             	seto   %cl
  103c47:	f6 c1 01             	test   $0x1,%cl
  103c4a:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
  103c50:	75 0b                	jne    103c5d <pic_init+0x1bd>
  103c52:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  103c58:	89 45 c8             	mov    %eax,-0x38(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103c5b:	eb d9                	jmp    103c36 <pic_init+0x196>
  103c5d:	48 8d 05 a4 19 00 00 	lea    0x19a4(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103c64:	48 89 c7             	mov    %rax,%rdi
  103c67:	e8 34 05 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

        //provide slave/master relationship information
        port_io::outb(PIC_MASTER_DATA, 4); //inform MASTER there is a SLAVE at IRQ2
        port_io::wait();
  103c6c:	eb 00                	jmp    103c6e <pic_init+0x1ce>
  103c6e:	66 c7 45 cc a1 00    	movw   $0xa1,-0x34(%rbp)
  103c74:	c6 45 cf 02          	movb   $0x2,-0x31(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103c78:	66 8b 45 cc          	mov    -0x34(%rbp),%ax
  103c7c:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  103c80:	8a 4d cf             	mov    -0x31(%rbp),%cl
  103c83:	88 4d d3             	mov    %cl,-0x2d(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103c86:	66 8b 55 d0          	mov    -0x30(%rbp),%dx
  103c8a:	8a 45 d3             	mov    -0x2d(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103c8d:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103c8e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)

    while i < 150 {
  103c95:	81 7d d4 96 00 00 00 	cmpl   $0x96,-0x2c(%rbp)
  103c9c:	7d 2d                	jge    103ccb <pic_init+0x22b>
        i = i + 1;
  103c9e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  103ca1:	ff c0                	inc    %eax
  103ca3:	0f 90 c1             	seto   %cl
  103ca6:	f6 c1 01             	test   $0x1,%cl
  103ca9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
  103caf:	75 0b                	jne    103cbc <pic_init+0x21c>
  103cb1:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
  103cb7:	89 45 d4             	mov    %eax,-0x2c(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103cba:	eb d9                	jmp    103c95 <pic_init+0x1f5>
  103cbc:	48 8d 05 45 19 00 00 	lea    0x1945(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103cc3:	48 89 c7             	mov    %rax,%rdi
  103cc6:	e8 d5 04 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
        port_io::outb(PIC_SLAVE_DATA, 2); //inform SLAVE it is a cascade identity
        port_io::wait();
  103ccb:	eb 00                	jmp    103ccd <pic_init+0x22d>
  103ccd:	66 c7 45 d8 21 00    	movw   $0x21,-0x28(%rbp)
  103cd3:	c6 45 db 01          	movb   $0x1,-0x25(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103cd7:	66 8b 45 d8          	mov    -0x28(%rbp),%ax
  103cdb:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  103cdf:	8a 4d db             	mov    -0x25(%rbp),%cl
  103ce2:	88 4d df             	mov    %cl,-0x21(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103ce5:	66 8b 55 dc          	mov    -0x24(%rbp),%dx
  103ce9:	8a 45 df             	mov    -0x21(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103cec:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103ced:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

    while i < 150 {
  103cf4:	81 7d e0 96 00 00 00 	cmpl   $0x96,-0x20(%rbp)
  103cfb:	7d 2d                	jge    103d2a <pic_init+0x28a>
        i = i + 1;
  103cfd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  103d00:	ff c0                	inc    %eax
  103d02:	0f 90 c1             	seto   %cl
  103d05:	f6 c1 01             	test   $0x1,%cl
  103d08:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  103d0e:	75 0b                	jne    103d1b <pic_init+0x27b>
  103d10:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  103d16:	89 45 e0             	mov    %eax,-0x20(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103d19:	eb d9                	jmp    103cf4 <pic_init+0x254>
  103d1b:	48 8d 05 e6 18 00 00 	lea    0x18e6(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103d22:	48 89 c7             	mov    %rax,%rdi
  103d25:	e8 76 04 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

        //provide additional environment information
        port_io::outb(PIC_MASTER_DATA, ICW4_8086); //operate in 8086 mode
        port_io::wait();
  103d2a:	eb 00                	jmp    103d2c <pic_init+0x28c>
  103d2c:	66 c7 45 e4 a1 00    	movw   $0xa1,-0x1c(%rbp)
  103d32:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103d36:	66 8b 45 e4          	mov    -0x1c(%rbp),%ax
  103d3a:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  103d3e:	8a 4d e7             	mov    -0x19(%rbp),%cl
  103d41:	88 4d eb             	mov    %cl,-0x15(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103d44:	66 8b 55 e8          	mov    -0x18(%rbp),%dx
  103d48:	8a 45 eb             	mov    -0x15(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103d4b:	ee                   	out    %al,(%dx)
     val
}

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;
  103d4c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    while i < 150 {
  103d53:	81 7d ec 96 00 00 00 	cmpl   $0x96,-0x14(%rbp)
  103d5a:	7d 2d                	jge    103d89 <pic_init+0x2e9>
        i = i + 1;
  103d5c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  103d5f:	ff c0                	inc    %eax
  103d61:	0f 90 c1             	seto   %cl
  103d64:	f6 c1 01             	test   $0x1,%cl
  103d67:	89 85 70 ff ff ff    	mov    %eax,-0x90(%rbp)
  103d6d:	75 0b                	jne    103d7a <pic_init+0x2da>
  103d6f:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
  103d75:	89 45 ec             	mov    %eax,-0x14(%rbp)

#[inline(always)]
pub unsafe fn wait() {
    let mut i = 0;

    while i < 150 {
  103d78:	eb d9                	jmp    103d53 <pic_init+0x2b3>
  103d7a:	48 8d 05 87 18 00 00 	lea    0x1887(%rip),%rax        # 105608 <panic_loc.u>
        i = i + 1;
  103d81:	48 89 c7             	mov    %rax,%rdi
  103d84:	e8 17 04 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
        port_io::outb(PIC_SLAVE_DATA, ICW4_8086); //operate in 8086 mode
        port_io::wait();
  103d89:	eb 00                	jmp    103d8b <pic_init+0x2eb>
  103d8b:	66 c7 45 f0 21 00    	movw   $0x21,-0x10(%rbp)
  103d91:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103d95:	66 8b 45 f0          	mov    -0x10(%rbp),%ax
  103d99:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  103d9d:	8a 4d f3             	mov    -0xd(%rbp),%cl
  103da0:	88 4d f7             	mov    %cl,-0x9(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103da3:	66 8b 55 f4          	mov    -0xc(%rbp),%dx
  103da7:	8a 45 f7             	mov    -0x9(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103daa:	ee                   	out    %al,(%dx)
  103dab:	66 c7 45 f8 a1 00    	movw   $0xa1,-0x8(%rbp)
  103db1:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103db5:	66 8b 45 f8          	mov    -0x8(%rbp),%ax
  103db9:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  103dbd:	8a 4d fb             	mov    -0x5(%rbp),%cl
  103dc0:	88 4d ff             	mov    %cl,-0x1(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103dc3:	66 8b 55 fc          	mov    -0x4(%rbp),%dx
  103dc7:	8a 45 ff             	mov    -0x1(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103dca:	ee                   	out    %al,(%dx)
  103dcb:	bf 01 00 00 00       	mov    $0x1,%edi
  103dd0:	31 f6                	xor    %esi,%esi

        //mask all interrupts, since none are currently initialised
        port_io::outb(PIC_MASTER_DATA, 0xFF);
        port_io::outb(PIC_SLAVE_DATA, 0xFF);

        irq_set_mask(1, false);
  103dd2:	e8 29 00 00 00       	callq  103e00 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE>
  103dd7:	48 8d 3d 42 c4 ff ff 	lea    -0x3bbe(%rip),%rdi        # 100220 <str.v>
  103dde:	b8 29 00 00 00       	mov    $0x29,%eax
  103de3:	89 c6                	mov    %eax,%esi
    }

    vga::println("Initialised the PIC, at an offset of 0x20");
  103de5:	e8 06 f0 ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>
}
  103dea:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
  103df1:	5d                   	pop    %rbp
  103df2:	c3                   	retq   

Disassembly of section .text._ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE:

0000000000103e00 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE>:
        port_io::outb(PIC_MASTER_COMMAND, EOI);
    }
}

//mask or unmask a specific irq in the PIC
pub fn irq_set_mask(mut irq: u8, enable: bool) {
  103e00:	55                   	push   %rbp
  103e01:	48 89 e5             	mov    %rsp,%rbp
  103e04:	48 83 ec 30          	sub    $0x30,%rsp
  103e08:	40 88 f0             	mov    %sil,%al
  103e0b:	40 88 f9             	mov    %dil,%cl
  103e0e:	88 4d d6             	mov    %cl,-0x2a(%rbp)
  103e11:	24 01                	and    $0x1,%al
  103e13:	88 45 d7             	mov    %al,-0x29(%rbp)
  103e16:	8a 45 d6             	mov    -0x2a(%rbp),%al
  103e19:	88 45 da             	mov    %al,-0x26(%rbp)
  103e1c:	8a 45 d7             	mov    -0x29(%rbp),%al
  103e1f:	24 01                	and    $0x1,%al
  103e21:	88 45 db             	mov    %al,-0x25(%rbp)
    unsafe {
        let mut port: u16 = 0;
  103e24:	66 c7 45 dc 00 00    	movw   $0x0,-0x24(%rbp)
        let mut value: u8 = 0;
  103e2a:	c6 45 df 00          	movb   $0x0,-0x21(%rbp)

        //determine port (PIC) to alter masks at
        if irq < 8 {
  103e2e:	80 7d da 08          	cmpb   $0x8,-0x26(%rbp)
  103e32:	73 08                	jae    103e3c <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x3c>
            port = PIC_MASTER_DATA;
  103e34:	66 c7 45 dc 21 00    	movw   $0x21,-0x24(%rbp)
    unsafe {
        let mut port: u16 = 0;
        let mut value: u8 = 0;

        //determine port (PIC) to alter masks at
        if irq < 8 {
  103e3a:	eb 32                	jmp    103e6e <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x6e>
            port = PIC_MASTER_DATA;
        } else if irq < 16 {
  103e3c:	80 7d da 10          	cmpb   $0x10,-0x26(%rbp)
  103e40:	73 1c                	jae    103e5e <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x5e>
            port = PIC_SLAVE_DATA;
  103e42:	66 c7 45 dc a1 00    	movw   $0xa1,-0x24(%rbp)
            irq -= 8;
  103e48:	8a 45 da             	mov    -0x26(%rbp),%al
  103e4b:	2c 08                	sub    $0x8,%al
  103e4d:	0f 92 c1             	setb   %cl
  103e50:	f6 c1 01             	test   $0x1,%cl
  103e53:	88 45 d5             	mov    %al,-0x2b(%rbp)
  103e56:	0f 85 04 01 00 00    	jne    103f60 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x160>
  103e5c:	eb 02                	jmp    103e60 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x60>
        } else {
            return; //not a valid irq
  103e5e:	eb 08                	jmp    103e68 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x68>
        //determine port (PIC) to alter masks at
        if irq < 8 {
            port = PIC_MASTER_DATA;
        } else if irq < 16 {
            port = PIC_SLAVE_DATA;
            irq -= 8;
  103e60:	8a 45 d5             	mov    -0x2b(%rbp),%al
  103e63:	88 45 da             	mov    %al,-0x26(%rbp)
    unsafe {
        let mut port: u16 = 0;
        let mut value: u8 = 0;

        //determine port (PIC) to alter masks at
        if irq < 8 {
  103e66:	eb 06                	jmp    103e6e <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x6e>
        } else {
            value = port_io::inb(port) | (1 << irq);
            port_io::outb(port,  value);
        }
    }
}
  103e68:	48 83 c4 30          	add    $0x30,%rsp
  103e6c:	5d                   	pop    %rbp
  103e6d:	c3                   	retq   
        } else {
            return; //not a valid irq
        }

        //alter masks accordingly and send to correct PIC
        if !enable {
  103e6e:	8a 45 db             	mov    -0x25(%rbp),%al
  103e71:	34 ff                	xor    $0xff,%al
  103e73:	a8 01                	test   $0x1,%al
  103e75:	75 02                	jne    103e79 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x79>
  103e77:	eb 20                	jmp    103e99 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x99>
            value = port_io::inb(port) & !(1 << irq);
  103e79:	66 8b 45 dc          	mov    -0x24(%rbp),%ax
  103e7d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
     "{dx}"(port), "{eax}"(val) ::
     "volatile");
}

#[inline(always)]
pub unsafe fn inb(port: u16) -> u8 {
  103e81:	66 8b 45 e4          	mov    -0x1c(%rbp),%ax
  103e85:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
    let val;

    asm!("inb %dx, %al" :
     "={al}"(val) : "{dx}"(port) :
  103e89:	66 8b 55 e6          	mov    -0x1a(%rbp),%dx

#[inline(always)]
pub unsafe fn inb(port: u16) -> u8 {
    let val;

    asm!("inb %dx, %al" :
  103e8d:	ec                   	in     (%dx),%al
  103e8e:	88 45 e9             	mov    %al,-0x17(%rbp)
     "={al}"(val) : "{dx}"(port) :
     "al" :
     "volatile");

     val
  103e91:	8a 45 e9             	mov    -0x17(%rbp),%al
  103e94:	88 45 d4             	mov    %al,-0x2c(%rbp)
  103e97:	eb 20                	jmp    103eb9 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0xb9>
            port_io::outb(port, value);
        } else {
            value = port_io::inb(port) | (1 << irq);
  103e99:	66 8b 45 dc          	mov    -0x24(%rbp),%ax
  103e9d:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
     "{dx}"(port), "{eax}"(val) ::
     "volatile");
}

#[inline(always)]
pub unsafe fn inb(port: u16) -> u8 {
  103ea1:	66 8b 45 ea          	mov    -0x16(%rbp),%ax
  103ea5:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    let val;

    asm!("inb %dx, %al" :
     "={al}"(val) : "{dx}"(port) :
  103ea9:	66 8b 55 ec          	mov    -0x14(%rbp),%dx

#[inline(always)]
pub unsafe fn inb(port: u16) -> u8 {
    let val;

    asm!("inb %dx, %al" :
  103ead:	ec                   	in     (%dx),%al
  103eae:	88 45 ef             	mov    %al,-0x11(%rbp)
     "={al}"(val) : "{dx}"(port) :
     "al" :
     "volatile");

     val
  103eb1:	8a 45 ef             	mov    -0x11(%rbp),%al
  103eb4:	88 45 d3             	mov    %al,-0x2d(%rbp)
  103eb7:	eb 54                	jmp    103f0d <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x10d>
  103eb9:	b0 01                	mov    $0x1,%al
            return; //not a valid irq
        }

        //alter masks accordingly and send to correct PIC
        if !enable {
            value = port_io::inb(port) & !(1 << irq);
  103ebb:	8a 4d da             	mov    -0x26(%rbp),%cl
  103ebe:	88 ca                	mov    %cl,%dl
  103ec0:	80 e2 f8             	and    $0xf8,%dl
  103ec3:	80 fa 00             	cmp    $0x0,%dl
  103ec6:	0f 95 c2             	setne  %dl
  103ec9:	80 e1 07             	and    $0x7,%cl
  103ecc:	d2 e0                	shl    %cl,%al
  103ece:	f6 c2 01             	test   $0x1,%dl
  103ed1:	88 45 d2             	mov    %al,-0x2e(%rbp)
  103ed4:	0f 85 95 00 00 00    	jne    103f6f <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x16f>
  103eda:	8a 45 d2             	mov    -0x2e(%rbp),%al
  103edd:	34 ff                	xor    $0xff,%al
  103edf:	8a 4d d4             	mov    -0x2c(%rbp),%cl
  103ee2:	20 c1                	and    %al,%cl
  103ee4:	88 4d df             	mov    %cl,-0x21(%rbp)
            port_io::outb(port, value);
  103ee7:	66 8b 55 dc          	mov    -0x24(%rbp),%dx
  103eeb:	8a 45 df             	mov    -0x21(%rbp),%al
  103eee:	66 89 55 f0          	mov    %dx,-0x10(%rbp)
  103ef2:	88 45 f3             	mov    %al,-0xd(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103ef5:	66 8b 55 f0          	mov    -0x10(%rbp),%dx
  103ef9:	66 89 55 f4          	mov    %dx,-0xc(%rbp)
  103efd:	8a 45 f3             	mov    -0xd(%rbp),%al
  103f00:	88 45 f7             	mov    %al,-0x9(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103f03:	66 8b 55 f4          	mov    -0xc(%rbp),%dx
  103f07:	8a 45 f7             	mov    -0x9(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103f0a:	ee                   	out    %al,(%dx)
        } else {
            return; //not a valid irq
        }

        //alter masks accordingly and send to correct PIC
        if !enable {
  103f0b:	eb 4e                	jmp    103f5b <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x15b>
  103f0d:	b0 01                	mov    $0x1,%al
            value = port_io::inb(port) & !(1 << irq);
            port_io::outb(port, value);
        } else {
            value = port_io::inb(port) | (1 << irq);
  103f0f:	8a 4d da             	mov    -0x26(%rbp),%cl
  103f12:	88 ca                	mov    %cl,%dl
  103f14:	80 e2 f8             	and    $0xf8,%dl
  103f17:	80 fa 00             	cmp    $0x0,%dl
  103f1a:	0f 95 c2             	setne  %dl
  103f1d:	80 e1 07             	and    $0x7,%cl
  103f20:	d2 e0                	shl    %cl,%al
  103f22:	f6 c2 01             	test   $0x1,%dl
  103f25:	88 45 d1             	mov    %al,-0x2f(%rbp)
  103f28:	75 54                	jne    103f7e <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x17e>
  103f2a:	8a 45 d3             	mov    -0x2d(%rbp),%al
  103f2d:	8a 4d d1             	mov    -0x2f(%rbp),%cl
  103f30:	08 c8                	or     %cl,%al
  103f32:	88 45 df             	mov    %al,-0x21(%rbp)
            port_io::outb(port,  value);
  103f35:	66 8b 55 dc          	mov    -0x24(%rbp),%dx
  103f39:	8a 45 df             	mov    -0x21(%rbp),%al
  103f3c:	66 89 55 f8          	mov    %dx,-0x8(%rbp)
  103f40:	88 45 fb             	mov    %al,-0x5(%rbp)
//port_io.rs

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
  103f43:	66 8b 55 f8          	mov    -0x8(%rbp),%dx
  103f47:	66 89 55 fc          	mov    %dx,-0x4(%rbp)
  103f4b:	8a 45 fb             	mov    -0x5(%rbp),%al
  103f4e:	88 45 ff             	mov    %al,-0x1(%rbp)
    asm!("outb %al, %dx" ::
     "{dx}"(port), "{al}"(val) ::
  103f51:	66 8b 55 fc          	mov    -0x4(%rbp),%dx
  103f55:	8a 45 ff             	mov    -0x1(%rbp),%al

//describes methods required to send and receive information from system io ports

#[inline(always)]
pub unsafe fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx" ::
  103f58:	ee                   	out    %al,(%dx)
        } else {
            return; //not a valid irq
        }

        //alter masks accordingly and send to correct PIC
        if !enable {
  103f59:	eb 00                	jmp    103f5b <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x15b>
        } else {
            value = port_io::inb(port) | (1 << irq);
            port_io::outb(port,  value);
        }
    }
}
  103f5b:	e9 08 ff ff ff       	jmpq   103e68 <_ZN13rustbucket_os4arch3pic12irq_set_mask17h2c85c15c86f515bfE+0x68>
  103f60:	48 8d 05 c9 16 00 00 	lea    0x16c9(%rip),%rax        # 105630 <panic_loc.x>
        //determine port (PIC) to alter masks at
        if irq < 8 {
            port = PIC_MASTER_DATA;
        } else if irq < 16 {
            port = PIC_SLAVE_DATA;
            irq -= 8;
  103f67:	48 89 c7             	mov    %rax,%rdi
  103f6a:	e8 31 02 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103f6f:	48 8d 05 e2 16 00 00 	lea    0x16e2(%rip),%rax        # 105658 <panic_loc.z>
            return; //not a valid irq
        }

        //alter masks accordingly and send to correct PIC
        if !enable {
            value = port_io::inb(port) & !(1 << irq);
  103f76:	48 89 c7             	mov    %rax,%rdi
  103f79:	e8 22 02 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  103f7e:	48 8d 05 fb 16 00 00 	lea    0x16fb(%rip),%rax        # 105680 <panic_loc.A>
            port_io::outb(port, value);
        } else {
            value = port_io::inb(port) | (1 << irq);
  103f85:	48 89 c7             	mov    %rax,%rdi
  103f88:	e8 13 02 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text.rust_begin_unwind:

0000000000103f90 <rust_begin_unwind>:

// system panic -- not implemented yet
#[lang = "panic_fmt"]
#[no_mangle]
// ensure the function does not return
pub extern fn panic_fmt() -> ! {
  103f90:	55                   	push   %rbp
  103f91:	48 89 e5             	mov    %rsp,%rbp
  103f94:	48 8d 3d f5 c2 ff ff 	lea    -0x3d0b(%rip),%rdi        # 100290 <str.B>
  103f9b:	b8 22 00 00 00       	mov    $0x22,%eax
  103fa0:	89 c6                	mov    %eax,%esi
	println("Unhandled interrupt! System panic!");
  103fa2:	e8 49 ee ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>
    loop{}
  103fa7:	eb 00                	jmp    103fa9 <rust_begin_unwind+0x19>
  103fa9:	eb fe                	jmp    103fa9 <rust_begin_unwind+0x19>

Disassembly of section .text.kernel_main:

0000000000103fb0 <kernel_main>:
}

// main kernel function
#[no_mangle] //disbale name mangling (func can be accessed from asm files)
pub extern fn kernel_main() {
  103fb0:	55                   	push   %rbp
  103fb1:	48 89 e5             	mov    %rsp,%rbp
	clear_term();
  103fb4:	e8 87 ee ff ff       	callq  102e40 <_ZN13rustbucket_os6driver3vga10clear_term17h5b0029741f6a66cfE>
  103fb9:	48 8d 3d 00 c3 ff ff 	lea    -0x3d00(%rip),%rdi        # 1002c0 <str.C>
  103fc0:	b8 21 00 00 00       	mov    $0x21,%eax
  103fc5:	89 c6                	mov    %eax,%esi

  	println("Welcome to the Rustbucket kernel!");
  103fc7:	e8 24 ee ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>
  103fcc:	48 8d 3d 1d c3 ff ff 	lea    -0x3ce3(%rip),%rdi        # 1002f0 <str.D>
  103fd3:	b8 1a 00 00 00       	mov    $0x1a,%eax
  103fd8:	89 c6                	mov    %eax,%esi
	println("Starting boot procedure...");
  103fda:	e8 11 ee ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>

	//initialise system
	gdt_init(); //set up GDT (global descriptor table)
  103fdf:	e8 4c f5 ff ff       	callq  103530 <_ZN13rustbucket_os4arch6x86_643gdt8gdt_init17ha467834baa059034E>
// Bochs breakpoint
#[naked]
#[inline(always)]
pub fn bochs_break() {
	unsafe {
		asm!("xchg bx, bx" :::: "intel");
  103fe4:	66 87 db             	xchg   %bx,%bx

	//initialise system
	gdt_init(); //set up GDT (global descriptor table)
	bochs_break();

	idt_init(); //set up IDT (interrupt descriptor table)
  103fe7:	e8 54 fa ff ff       	callq  103a40 <_ZN13rustbucket_os4arch6x86_643idt8idt_init17h0d2bd7a98c3018deE>
// Bochs breakpoint
#[naked]
#[inline(always)]
pub fn bochs_break() {
	unsafe {
		asm!("xchg bx, bx" :::: "intel");
  103fec:	66 87 db             	xchg   %bx,%bx
	bochs_break();

	idt_init(); //set up IDT (interrupt descriptor table)
	bochs_break();

	pic_init(); //set up PIC (programmable interrupt controller)
  103fef:	e8 ac fa ff ff       	callq  103aa0 <pic_init>
// Bochs breakpoint
#[naked]
#[inline(always)]
pub fn bochs_break() {
	unsafe {
		asm!("xchg bx, bx" :::: "intel");
  103ff4:	66 87 db             	xchg   %bx,%bx

#[naked]
#[inline(always)]
pub fn enable() {
    unsafe {
        asm!("sti");
  103ff7:	fb                   	sti    
  103ff8:	48 8d 3d 11 c3 ff ff 	lea    -0x3cef(%rip),%rdi        # 100310 <str.E>
  103fff:	b8 12 00 00 00       	mov    $0x12,%eax
  104004:	89 c6                	mov    %eax,%esi

	pic_init(); //set up PIC (programmable interrupt controller)
	bochs_break();
	
	isr::enable();
	println("Enabled interrupts");
  104006:	e8 e5 ed ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>
// Bochs breakpoint
#[naked]
#[inline(always)]
pub fn bochs_break() {
	unsafe {
		asm!("xchg bx, bx" :::: "intel");
  10400b:	66 87 db             	xchg   %bx,%bx
	isr::enable();
	println("Enabled interrupts");

	bochs_break();

	try_exception();
  10400e:	e8 0d 00 00 00       	callq  104020 <try_exception>
	// -----
	// Create dynamic memory allocator
	// Add a keyboard IRQ handler
	// Create a mini kernel-space command-line
	// Begin writing filesystem implementation (filesystems, inodes, file descriptors, etc.)
}
  104013:	5d                   	pop    %rbp
  104014:	c3                   	retq   

Disassembly of section .text.try_exception:

0000000000104020 <try_exception>:
		asm!("xchg bx, bx" :::: "intel");
	}
}

#[no_mangle]
pub fn try_exception() {
  104020:	55                   	push   %rbp
  104021:	48 89 e5             	mov    %rsp,%rbp
  104024:	48 83 ec 10          	sub    $0x10,%rsp
  104028:	48 8d 3d 01 c3 ff ff 	lea    -0x3cff(%rip),%rdi        # 100330 <str.F>
  10402f:	b8 24 00 00 00       	mov    $0x24,%eax
  104034:	89 c6                	mov    %eax,%esi
	println("\nTesting divide by zero exception...");
  104036:	e8 b5 ed ff ff       	callq  102df0 <_ZN13rustbucket_os6driver3vga7println17hf9720e8785bc0cedE>
  10403b:	b0 01                	mov    $0x1,%al
	let mut x: u8 = 1;
  10403d:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
	x = x / 0;
  104041:	8a 4d ff             	mov    -0x1(%rbp),%cl
  104044:	a8 01                	test   $0x1,%al
  104046:	88 4d fe             	mov    %cl,-0x2(%rbp)
  104049:	75 16                	jne    104061 <try_exception+0x41>
  10404b:	31 c0                	xor    %eax,%eax
  10404d:	88 c1                	mov    %al,%cl
  10404f:	8a 55 fe             	mov    -0x2(%rbp),%dl
  104052:	66 0f b6 c2          	movzbw %dl,%ax
  104056:	f6 f1                	div    %cl
  104058:	88 45 ff             	mov    %al,-0x1(%rbp)
}
  10405b:	48 83 c4 10          	add    $0x10,%rsp
  10405f:	5d                   	pop    %rbp
  104060:	c3                   	retq   
  104061:	48 8d 05 40 16 00 00 	lea    0x1640(%rip),%rax        # 1056a8 <panic_loc.I>

#[no_mangle]
pub fn try_exception() {
	println("\nTesting divide by zero exception...");
	let mut x: u8 = 1;
	x = x / 0;
  104068:	48 89 c7             	mov    %rax,%rdi
  10406b:	e8 30 01 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text._ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17h9243157c088ccc8fE:

0000000000104070 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17h9243157c088ccc8fE>:
    ///     println!("{}", *ptr.offset(2));
    /// }
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[inline]
    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized {
  104070:	55                   	push   %rbp
  104071:	48 89 e5             	mov    %rsp,%rbp
  104074:	48 83 ec 30          	sub    $0x30,%rsp
  104078:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  10407c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  104080:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  104084:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  104088:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  10408c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
        intrinsics::offset(self, count) as *mut T
  104090:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  104094:	48 03 75 f0          	add    -0x10(%rbp),%rsi
  104098:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  10409c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1040a0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }
  1040a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1040a8:	48 83 c4 30          	add    $0x30,%rsp
  1040ac:	5d                   	pop    %rbp
  1040ad:	c3                   	retq   

Disassembly of section .text._ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h95284d35d8c8ffb1E:

00000000001040b0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h95284d35d8c8ffb1E>:
    ///     println!("{}", *ptr.offset(2) as char);
    /// }
    /// ```
    #[stable(feature = "rust1", since = "1.0.0")]
    #[inline]
    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized {
  1040b0:	55                   	push   %rbp
  1040b1:	48 89 e5             	mov    %rsp,%rbp
  1040b4:	48 83 ec 30          	sub    $0x30,%rsp
  1040b8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  1040bc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  1040c0:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  1040c4:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  1040c8:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  1040cc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
        intrinsics::offset(self, count)
  1040d0:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  1040d4:	48 03 75 f0          	add    -0x10(%rbp),%rsi
  1040d8:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
  1040dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1040e0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }
  1040e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  1040e8:	48 83 c4 30          	add    $0x30,%rsp
  1040ec:	5d                   	pop    %rbp
  1040ed:	c3                   	retq   

Disassembly of section .text.memcpy:

00000000001040f0 <memcpy>:
// This library defines the builtin functions, so it would be a shame for
// LLVM to optimize these function calls to themselves!
#![no_builtins]

#[no_mangle]
pub unsafe extern fn memcpy(dest: *mut u8, src: *const u8,
  1040f0:	55                   	push   %rbp
  1040f1:	48 89 e5             	mov    %rsp,%rbp
  1040f4:	48 83 ec 60          	sub    $0x60,%rsp
  1040f8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  1040fc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  104100:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  104104:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  104108:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  10410c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  104110:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
                            n: usize) -> *mut u8 {
  104114:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  104118:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
    let mut i = 0;
  10411c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  104123:	00 
    while i < n {
  104124:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  104128:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  10412c:	72 0a                	jb     104138 <memcpy+0x48>
        *dest.offset(i as isize) = *src.offset(i as isize);
        i += 1;
    }
    return dest;
  10412e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  104132:	48 83 c4 60          	add    $0x60,%rsp
  104136:	5d                   	pop    %rbp
  104137:	c3                   	retq   
#[no_mangle]
pub unsafe extern fn memcpy(dest: *mut u8, src: *const u8,
                            n: usize) -> *mut u8 {
    let mut i = 0;
    while i < n {
        *dest.offset(i as isize) = *src.offset(i as isize);
  104138:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  10413c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  104140:	e8 6b ff ff ff       	callq  1040b0 <_ZN4core3ptr33_$LT$impl$u20$$BP$const$u20$T$GT$6offset17h95284d35d8c8ffb1E>
  104145:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  104149:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  10414d:	8a 08                	mov    (%rax),%cl
  10414f:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  104153:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  104157:	88 4d bf             	mov    %cl,-0x41(%rbp)
  10415a:	e8 11 ff ff ff       	callq  104070 <_ZN4core3ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$6offset17h9243157c088ccc8fE>
  10415f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  104163:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  104167:	8a 4d bf             	mov    -0x41(%rbp),%cl
  10416a:	88 08                	mov    %cl,(%rax)
        i += 1;
  10416c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  104170:	48 83 c2 01          	add    $0x1,%rdx
  104174:	40 0f 92 c6          	setb   %sil
  104178:	40 f6 c6 01          	test   $0x1,%sil
  10417c:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  104180:	75 0a                	jne    10418c <memcpy+0x9c>
  104182:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  104186:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

#[no_mangle]
pub unsafe extern fn memcpy(dest: *mut u8, src: *const u8,
                            n: usize) -> *mut u8 {
    let mut i = 0;
    while i < n {
  10418a:	eb 98                	jmp    104124 <memcpy+0x34>
  10418c:	48 8d 05 1d 11 00 00 	lea    0x111d(%rip),%rax        # 1052b0 <panic_loc.2>
        *dest.offset(i as isize) = *src.offset(i as isize);
        i += 1;
  104193:	48 89 c7             	mov    %rax,%rdi
  104196:	e8 05 00 00 00       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>

Disassembly of section .text.cold._ZN4core9panicking5panic17h72efe58c7cbe617bE:

00000000001041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>:
  1041a0:	48 83 ec 58          	sub    $0x58,%rsp
  1041a4:	48 8b 07             	mov    (%rdi),%rax
  1041a7:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
  1041ab:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  1041af:	48 8b 77 18          	mov    0x18(%rdi),%rsi
  1041b3:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
  1041b7:	48 89 04 24          	mov    %rax,(%rsp)
  1041bb:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  1041c0:	48 89 e0             	mov    %rsp,%rax
  1041c3:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  1041c8:	48 c7 44 24 30 01 00 	movq   $0x1,0x30(%rsp)
  1041cf:	00 00 
  1041d1:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  1041d8:	00 00 
  1041da:	48 8d 05 ff c1 ff ff 	lea    -0x3e01(%rip),%rax        # 1003e0 <str.2d>
  1041e1:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
  1041e6:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  1041ed:	00 00 
  1041ef:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  1041f4:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  1041f9:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  1041fe:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
  104203:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  104208:	e8 83 00 00 00       	callq  104290 <_ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E>

Disassembly of section .text.cold._ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE:

0000000000104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>:
  104210:	48 83 ec 68          	sub    $0x68,%rsp
  104214:	48 89 f8             	mov    %rdi,%rax
  104217:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  10421c:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  104221:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
  104226:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  10422b:	48 8d 0d ee 0e 00 00 	lea    0xeee(%rip),%rcx        # 105120 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E>
  104232:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  104237:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  10423c:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
  104241:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  104246:	48 8d 0d 4b 15 00 00 	lea    0x154b(%rip),%rcx        # 105798 <ref.6X>
  10424d:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  104252:	48 c7 44 24 40 02 00 	movq   $0x2,0x40(%rsp)
  104259:	00 00 
  10425b:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  104262:	00 00 
  104264:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
  104269:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
  10426e:	48 c7 44 24 60 02 00 	movq   $0x2,0x60(%rsp)
  104275:	00 00 
  104277:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
  10427c:	48 89 c6             	mov    %rax,%rsi
  10427f:	e8 0c 00 00 00       	callq  104290 <_ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E>

Disassembly of section .text.cold._ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E:

0000000000104290 <_ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E>:
  104290:	48 83 ec 68          	sub    $0x68,%rsp
  104294:	48 8b 06             	mov    (%rsi),%rax
  104297:	4c 8b 46 08          	mov    0x8(%rsi),%r8
  10429b:	8b 56 10             	mov    0x10(%rsi),%edx
  10429e:	8b 4e 14             	mov    0x14(%rsi),%ecx
  1042a1:	48 8b 77 28          	mov    0x28(%rdi),%rsi
  1042a5:	48 89 74 24 60       	mov    %rsi,0x60(%rsp)
  1042aa:	48 8b 77 20          	mov    0x20(%rdi),%rsi
  1042ae:	48 89 74 24 58       	mov    %rsi,0x58(%rsp)
  1042b3:	48 8b 77 18          	mov    0x18(%rdi),%rsi
  1042b7:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
  1042bc:	48 8b 77 10          	mov    0x10(%rdi),%rsi
  1042c0:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
  1042c5:	48 8b 37             	mov    (%rdi),%rsi
  1042c8:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  1042cc:	48 89 7c 24 40       	mov    %rdi,0x40(%rsp)
  1042d1:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
  1042d6:	48 8b 74 24 60       	mov    0x60(%rsp),%rsi
  1042db:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  1042e0:	48 8b 74 24 58       	mov    0x58(%rsp),%rsi
  1042e5:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  1042ea:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
  1042ef:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  1042f4:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
  1042f9:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  1042fe:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  104303:	48 8b 7c 24 40       	mov    0x40(%rsp),%rdi
  104308:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  10430d:	48 89 34 24          	mov    %rsi,(%rsp)
  104311:	48 89 c7             	mov    %rax,%rdi
  104314:	4c 89 c6             	mov    %r8,%rsi
  104317:	e8 74 fc ff ff       	callq  103f90 <rust_begin_unwind>
  10431c:	48 83 ec 30          	sub    $0x30,%rsp

Disassembly of section .text.cold._ZN4core5slice22slice_index_order_fail17h53bf70f83f93d32dE:

0000000000104320 <_ZN4core5slice22slice_index_order_fail17h53bf70f83f93d32dE>:
  104320:	48 83 ec 68          	sub    $0x68,%rsp
  104324:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  104329:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  10432e:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
  104333:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  104338:	48 8d 05 e1 0d 00 00 	lea    0xde1(%rip),%rax        # 105120 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E>
  10433f:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  104344:	48 8d 4c 24 10       	lea    0x10(%rsp),%rcx
  104349:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  10434e:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  104353:	48 8d 05 9e 14 00 00 	lea    0x149e(%rip),%rax        # 1057f8 <ref.7u>
  10435a:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  10435f:	48 c7 44 24 40 02 00 	movq   $0x2,0x40(%rsp)
  104366:	00 00 
  104368:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  10436f:	00 00 
  104371:	48 8d 44 24 18       	lea    0x18(%rsp),%rax
  104376:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  10437b:	48 c7 44 24 60 02 00 	movq   $0x2,0x60(%rsp)
  104382:	00 00 
  104384:	48 8d 35 55 14 00 00 	lea    0x1455(%rip),%rsi        # 1057e0 <_ZN4core5slice22slice_index_order_fail18_MSG_FILE_LINE_COL17h9314141577ca7010E>
  10438b:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
  104390:	e8 fb fe ff ff       	callq  104290 <_ZN4core9panicking9panic_fmt17h30e3fef79d9e8b96E>

Disassembly of section .text._ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E:

00000000001043a0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E>:
  1043a0:	53                   	push   %rbx
  1043a1:	48 83 ec 30          	sub    $0x30,%rsp
  1043a5:	49 89 f2             	mov    %rsi,%r10
  1043a8:	48 8b 0f             	mov    (%rdi),%rcx
  1043ab:	bf 27 00 00 00       	mov    $0x27,%edi
  1043b0:	48 81 f9 10 27 00 00 	cmp    $0x2710,%rcx
  1043b7:	72 7a                	jb     104433 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E+0x93>
  1043b9:	49 b8 4b 59 86 38 d6 	movabs $0x346dc5d63886594b,%r8
  1043c0:	c5 6d 34 
  1043c3:	49 b9 c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%r9
  1043ca:	c2 f5 28 
  1043cd:	4c 8d 1d c1 c2 ff ff 	lea    -0x3d3f(%rip),%r11        # 100695 <byte_str.9e>
  1043d4:	48 89 ce             	mov    %rcx,%rsi
  1043d7:	90                   	nop
  1043d8:	90                   	nop
  1043d9:	90                   	nop
  1043da:	90                   	nop
  1043db:	90                   	nop
  1043dc:	90                   	nop
  1043dd:	90                   	nop
  1043de:	90                   	nop
  1043df:	90                   	nop
  1043e0:	48 89 f0             	mov    %rsi,%rax
  1043e3:	49 f7 e0             	mul    %r8
  1043e6:	48 89 d1             	mov    %rdx,%rcx
  1043e9:	48 c1 e9 0b          	shr    $0xb,%rcx
  1043ed:	48 69 c1 10 27 00 00 	imul   $0x2710,%rcx,%rax
  1043f4:	48 89 f3             	mov    %rsi,%rbx
  1043f7:	48 29 c3             	sub    %rax,%rbx
  1043fa:	48 89 d8             	mov    %rbx,%rax
  1043fd:	48 c1 e8 02          	shr    $0x2,%rax
  104401:	49 f7 e1             	mul    %r9
  104404:	48 c1 ea 02          	shr    $0x2,%rdx
  104408:	48 6b c2 64          	imul   $0x64,%rdx,%rax
  10440c:	48 29 c3             	sub    %rax,%rbx
  10440f:	41 0f b7 04 53       	movzwl (%r11,%rdx,2),%eax
  104414:	66 89 44 3c 05       	mov    %ax,0x5(%rsp,%rdi,1)
  104419:	41 0f b7 04 5b       	movzwl (%r11,%rbx,2),%eax
  10441e:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  104423:	48 8d 7f fc          	lea    -0x4(%rdi),%rdi
  104427:	48 81 fe ff e0 f5 05 	cmp    $0x5f5e0ff,%rsi
  10442e:	48 89 ce             	mov    %rcx,%rsi
  104431:	77 ad                	ja     1043e0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E+0x40>
  104433:	48 83 f9 64          	cmp    $0x64,%rcx
  104437:	7c 36                	jl     10446f <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E+0xcf>
  104439:	48 89 c8             	mov    %rcx,%rax
  10443c:	48 c1 e8 02          	shr    $0x2,%rax
  104440:	48 ba c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rdx
  104447:	c2 f5 28 
  10444a:	48 f7 e2             	mul    %rdx
  10444d:	48 c1 ea 02          	shr    $0x2,%rdx
  104451:	48 6b c2 64          	imul   $0x64,%rdx,%rax
  104455:	48 29 c1             	sub    %rax,%rcx
  104458:	48 8d 05 36 c2 ff ff 	lea    -0x3dca(%rip),%rax        # 100695 <byte_str.9e>
  10445f:	0f b7 04 48          	movzwl (%rax,%rcx,2),%eax
  104463:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  104468:	48 83 c7 fe          	add    $0xfffffffffffffffe,%rdi
  10446c:	48 89 d1             	mov    %rdx,%rcx
  10446f:	48 83 f9 09          	cmp    $0x9,%rcx
  104473:	7f 0c                	jg     104481 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E+0xe1>
  104475:	80 c1 30             	add    $0x30,%cl
  104478:	88 4c 3c 08          	mov    %cl,0x8(%rsp,%rdi,1)
  10447c:	48 ff cf             	dec    %rdi
  10447f:	eb 14                	jmp    104495 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E+0xf5>
  104481:	48 8d 05 0d c2 ff ff 	lea    -0x3df3(%rip),%rax        # 100695 <byte_str.9e>
  104488:	0f b7 04 48          	movzwl (%rax,%rcx,2),%eax
  10448c:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  104491:	48 83 c7 fe          	add    $0xfffffffffffffffe,%rdi
  104495:	4c 8d 44 3c 09       	lea    0x9(%rsp,%rdi,1),%r8
  10449a:	41 b9 27 00 00 00    	mov    $0x27,%r9d
  1044a0:	49 29 f9             	sub    %rdi,%r9
  1044a3:	48 8d 15 2f bf ff ff 	lea    -0x40d1(%rip),%rdx        # 1003d9 <str.11+0x29>
  1044aa:	be 01 00 00 00       	mov    $0x1,%esi
  1044af:	31 c9                	xor    %ecx,%ecx
  1044b1:	4c 89 d7             	mov    %r10,%rdi
  1044b4:	e8 67 03 00 00       	callq  104820 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E>
  1044b9:	48 83 c4 30          	add    $0x30,%rsp
  1044bd:	5b                   	pop    %rbx
  1044be:	c3                   	retq   

Disassembly of section .text._ZN4core3fmt5write17ha9482bb577c609d2E:

00000000001044c0 <_ZN4core3fmt5write17ha9482bb577c609d2E>:
  1044c0:	55                   	push   %rbp
  1044c1:	41 57                	push   %r15
  1044c3:	41 56                	push   %r14
  1044c5:	41 55                	push   %r13
  1044c7:	41 54                	push   %r12
  1044c9:	53                   	push   %rbx
  1044ca:	48 83 ec 68          	sub    $0x68,%rsp
  1044ce:	4c 8b 22             	mov    (%rdx),%r12
  1044d1:	4c 8b 7a 08          	mov    0x8(%rdx),%r15
  1044d5:	48 8b 5a 10          	mov    0x10(%rdx),%rbx
  1044d9:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  1044dd:	48 8b 6a 20          	mov    0x20(%rdx),%rbp
  1044e1:	48 8b 42 28          	mov    0x28(%rdx),%rax
  1044e5:	49 89 c5             	mov    %rax,%r13
  1044e8:	49 c1 e5 04          	shl    $0x4,%r13
  1044ec:	4a 8d 54 2d 00       	lea    0x0(%rbp,%r13,1),%rdx
  1044f1:	c7 44 24 58 00 00 00 	movl   $0x0,0x58(%rsp)
  1044f8:	00 
  1044f9:	c7 44 24 5c 20 00 00 	movl   $0x20,0x5c(%rsp)
  104500:	00 
  104501:	c6 44 24 60 03       	movb   $0x3,0x60(%rsp)
  104506:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  10450d:	00 00 
  10450f:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
  104516:	00 00 
  104518:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  10451d:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  104522:	48 89 6c 24 38       	mov    %rbp,0x38(%rsp)
  104527:	48 89 54 24 40       	mov    %rdx,0x40(%rsp)
  10452c:	48 89 6c 24 48       	mov    %rbp,0x48(%rsp)
  104531:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  104536:	4d 89 fe             	mov    %r15,%r14
  104539:	49 c1 e6 04          	shl    $0x4,%r14
  10453d:	4b 8d 04 34          	lea    (%r12,%r14,1),%rax
  104541:	48 89 04 24          	mov    %rax,(%rsp)
  104545:	48 85 db             	test   %rbx,%rbx
  104548:	0f 84 f1 01 00 00    	je     10473f <_ZN4core3fmt5write17ha9482bb577c609d2E+0x27f>
  10454e:	48 c1 e1 06          	shl    $0x6,%rcx
  104552:	48 01 d9             	add    %rbx,%rcx
  104555:	4c 8d 7b 08          	lea    0x8(%rbx),%r15
  104559:	4c 8d 6c 24 08       	lea    0x8(%rsp),%r13
  10455e:	48 89 cd             	mov    %rcx,%rbp
  104561:	90                   	nop
  104562:	90                   	nop
  104563:	90                   	nop
  104564:	90                   	nop
  104565:	90                   	nop
  104566:	90                   	nop
  104567:	90                   	nop
  104568:	90                   	nop
  104569:	90                   	nop
  10456a:	90                   	nop
  10456b:	90                   	nop
  10456c:	90                   	nop
  10456d:	90                   	nop
  10456e:	90                   	nop
  10456f:	90                   	nop
  104570:	48 39 eb             	cmp    %rbp,%rbx
  104573:	0f 84 1b 02 00 00    	je     104794 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x2d4>
  104579:	4d 85 f6             	test   %r14,%r14
  10457c:	0f 84 1d 02 00 00    	je     10479f <_ZN4core3fmt5write17ha9482bb577c609d2E+0x2df>
  104582:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  104587:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  10458c:	49 8b 34 24          	mov    (%r12),%rsi
  104590:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  104595:	ff 50 18             	callq  *0x18(%rax)
  104598:	84 c0                	test   %al,%al
  10459a:	0f 85 2a 02 00 00    	jne    1047ca <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30a>
  1045a0:	8b 43 30             	mov    0x30(%rbx),%eax
  1045a3:	89 44 24 5c          	mov    %eax,0x5c(%rsp)
  1045a7:	0f b6 43 38          	movzbl 0x38(%rbx),%eax
  1045ab:	88 44 24 60          	mov    %al,0x60(%rsp)
  1045af:	8b 43 34             	mov    0x34(%rbx),%eax
  1045b2:	89 44 24 58          	mov    %eax,0x58(%rsp)
  1045b6:	0f b6 43 20          	movzbl 0x20(%rbx),%eax
  1045ba:	48 8b 73 28          	mov    0x28(%rbx),%rsi
  1045be:	24 03                	and    $0x3,%al
  1045c0:	74 6a                	je     10462c <_ZN4core3fmt5write17ha9482bb577c609d2E+0x16c>
  1045c2:	3c 01                	cmp    $0x1,%al
  1045c4:	74 3a                	je     104600 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x140>
  1045c6:	3c 02                	cmp    $0x2,%al
  1045c8:	75 76                	jne    104640 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x180>
  1045ca:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  1045cf:	48 3b 44 24 40       	cmp    0x40(%rsp),%rax
  1045d4:	74 6a                	je     104640 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x180>
  1045d6:	48 8d 48 10          	lea    0x10(%rax),%rcx
  1045da:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  1045df:	48 8d 0d ba fd ff ff 	lea    -0x246(%rip),%rcx        # 1043a0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E>
  1045e6:	48 39 48 08          	cmp    %rcx,0x8(%rax)
  1045ea:	75 54                	jne    104640 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x180>
  1045ec:	48 8b 00             	mov    (%rax),%rax
  1045ef:	eb 38                	jmp    104629 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x169>
  1045f1:	90                   	nop
  1045f2:	90                   	nop
  1045f3:	90                   	nop
  1045f4:	90                   	nop
  1045f5:	90                   	nop
  1045f6:	90                   	nop
  1045f7:	90                   	nop
  1045f8:	90                   	nop
  1045f9:	90                   	nop
  1045fa:	90                   	nop
  1045fb:	90                   	nop
  1045fc:	90                   	nop
  1045fd:	90                   	nop
  1045fe:	90                   	nop
  1045ff:	90                   	nop
  104600:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  104605:	48 39 f2             	cmp    %rsi,%rdx
  104608:	0f 86 ec 01 00 00    	jbe    1047fa <_ZN4core3fmt5write17ha9482bb577c609d2E+0x33a>
  10460e:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
  104613:	48 c1 e6 04          	shl    $0x4,%rsi
  104617:	48 8d 0d 82 fd ff ff 	lea    -0x27e(%rip),%rcx        # 1043a0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E>
  10461e:	48 39 4c 30 08       	cmp    %rcx,0x8(%rax,%rsi,1)
  104623:	75 1b                	jne    104640 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x180>
  104625:	48 8b 04 30          	mov    (%rax,%rsi,1),%rax
  104629:	48 8b 30             	mov    (%rax),%rsi
  10462c:	b8 01 00 00 00       	mov    $0x1,%eax
  104631:	eb 0f                	jmp    104642 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x182>
  104633:	90                   	nop
  104634:	90                   	nop
  104635:	90                   	nop
  104636:	90                   	nop
  104637:	90                   	nop
  104638:	90                   	nop
  104639:	90                   	nop
  10463a:	90                   	nop
  10463b:	90                   	nop
  10463c:	90                   	nop
  10463d:	90                   	nop
  10463e:	90                   	nop
  10463f:	90                   	nop
  104640:	31 c0                	xor    %eax,%eax
  104642:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  104647:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  10464c:	0f b6 43 10          	movzbl 0x10(%rbx),%eax
  104650:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  104654:	24 03                	and    $0x3,%al
  104656:	74 64                	je     1046bc <_ZN4core3fmt5write17ha9482bb577c609d2E+0x1fc>
  104658:	3c 01                	cmp    $0x1,%al
  10465a:	74 34                	je     104690 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x1d0>
  10465c:	3c 02                	cmp    $0x2,%al
  10465e:	75 70                	jne    1046d0 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x210>
  104660:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  104665:	48 3b 44 24 40       	cmp    0x40(%rsp),%rax
  10466a:	74 64                	je     1046d0 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x210>
  10466c:	48 8d 48 10          	lea    0x10(%rax),%rcx
  104670:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  104675:	48 8d 0d 24 fd ff ff 	lea    -0x2dc(%rip),%rcx        # 1043a0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E>
  10467c:	48 39 48 08          	cmp    %rcx,0x8(%rax)
  104680:	75 4e                	jne    1046d0 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x210>
  104682:	48 8b 00             	mov    (%rax),%rax
  104685:	eb 32                	jmp    1046b9 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x1f9>
  104687:	90                   	nop
  104688:	90                   	nop
  104689:	90                   	nop
  10468a:	90                   	nop
  10468b:	90                   	nop
  10468c:	90                   	nop
  10468d:	90                   	nop
  10468e:	90                   	nop
  10468f:	90                   	nop
  104690:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  104695:	48 39 f2             	cmp    %rsi,%rdx
  104698:	0f 86 68 01 00 00    	jbe    104806 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x346>
  10469e:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
  1046a3:	48 c1 e6 04          	shl    $0x4,%rsi
  1046a7:	48 8d 0d f2 fc ff ff 	lea    -0x30e(%rip),%rcx        # 1043a0 <_ZN4core3fmt10ArgumentV110show_usize17h7078e419ee02d5e9E>
  1046ae:	48 39 4c 30 08       	cmp    %rcx,0x8(%rax,%rsi,1)
  1046b3:	75 1b                	jne    1046d0 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x210>
  1046b5:	48 8b 04 30          	mov    (%rax,%rsi,1),%rax
  1046b9:	48 8b 30             	mov    (%rax),%rsi
  1046bc:	b8 01 00 00 00       	mov    $0x1,%eax
  1046c1:	eb 0f                	jmp    1046d2 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x212>
  1046c3:	90                   	nop
  1046c4:	90                   	nop
  1046c5:	90                   	nop
  1046c6:	90                   	nop
  1046c7:	90                   	nop
  1046c8:	90                   	nop
  1046c9:	90                   	nop
  1046ca:	90                   	nop
  1046cb:	90                   	nop
  1046cc:	90                   	nop
  1046cd:	90                   	nop
  1046ce:	90                   	nop
  1046cf:	90                   	nop
  1046d0:	31 c0                	xor    %eax,%eax
  1046d2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  1046d7:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  1046dc:	48 83 3b 00          	cmpq   $0x0,(%rbx)
  1046e0:	74 1e                	je     104700 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x240>
  1046e2:	49 8b 0f             	mov    (%r15),%rcx
  1046e5:	48 8b 54 24 50       	mov    0x50(%rsp),%rdx
  1046ea:	48 39 d1             	cmp    %rdx,%rcx
  1046ed:	0f 83 ec 00 00 00    	jae    1047df <_ZN4core3fmt5write17ha9482bb577c609d2E+0x31f>
  1046f3:	48 c1 e1 04          	shl    $0x4,%rcx
  1046f7:	48 03 4c 24 48       	add    0x48(%rsp),%rcx
  1046fc:	eb 1b                	jmp    104719 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x259>
  1046fe:	90                   	nop
  1046ff:	90                   	nop
  104700:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
  104705:	48 3b 4c 24 40       	cmp    0x40(%rsp),%rcx
  10470a:	0f 84 de 00 00 00    	je     1047ee <_ZN4core3fmt5write17ha9482bb577c609d2E+0x32e>
  104710:	48 8d 41 10          	lea    0x10(%rcx),%rax
  104714:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  104719:	48 83 c3 40          	add    $0x40,%rbx
  10471d:	49 83 c4 10          	add    $0x10,%r12
  104721:	48 8b 39             	mov    (%rcx),%rdi
  104724:	4c 89 ee             	mov    %r13,%rsi
  104727:	ff 51 08             	callq  *0x8(%rcx)
  10472a:	49 83 c6 f0          	add    $0xfffffffffffffff0,%r14
  10472e:	49 83 c7 40          	add    $0x40,%r15
  104732:	84 c0                	test   %al,%al
  104734:	0f 84 36 fe ff ff    	je     104570 <_ZN4core3fmt5write17ha9482bb577c609d2E+0xb0>
  10473a:	e9 8b 00 00 00       	jmpq   1047ca <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30a>
  10473f:	49 c1 e7 04          	shl    $0x4,%r15
  104743:	4c 8d 74 24 08       	lea    0x8(%rsp),%r14
  104748:	90                   	nop
  104749:	90                   	nop
  10474a:	90                   	nop
  10474b:	90                   	nop
  10474c:	90                   	nop
  10474d:	90                   	nop
  10474e:	90                   	nop
  10474f:	90                   	nop
  104750:	4d 85 ed             	test   %r13,%r13
  104753:	74 3f                	je     104794 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x2d4>
  104755:	4d 85 ff             	test   %r15,%r15
  104758:	74 45                	je     10479f <_ZN4core3fmt5write17ha9482bb577c609d2E+0x2df>
  10475a:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  10475f:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  104764:	49 8b 34 24          	mov    (%r12),%rsi
  104768:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  10476d:	ff 50 18             	callq  *0x18(%rax)
  104770:	84 c0                	test   %al,%al
  104772:	75 56                	jne    1047ca <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30a>
  104774:	49 83 c4 10          	add    $0x10,%r12
  104778:	48 8b 7d 00          	mov    0x0(%rbp),%rdi
  10477c:	4c 89 f6             	mov    %r14,%rsi
  10477f:	ff 55 08             	callq  *0x8(%rbp)
  104782:	48 8d 6d 10          	lea    0x10(%rbp),%rbp
  104786:	49 83 c7 f0          	add    $0xfffffffffffffff0,%r15
  10478a:	49 83 c5 f0          	add    $0xfffffffffffffff0,%r13
  10478e:	84 c0                	test   %al,%al
  104790:	74 be                	je     104750 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x290>
  104792:	eb 36                	jmp    1047ca <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30a>
  104794:	48 8b 04 24          	mov    (%rsp),%rax
  104798:	49 39 c4             	cmp    %rax,%r12
  10479b:	75 0e                	jne    1047ab <_ZN4core3fmt5write17ha9482bb577c609d2E+0x2eb>
  10479d:	eb 2f                	jmp    1047ce <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30e>
  10479f:	48 8b 04 24          	mov    (%rsp),%rax
  1047a3:	49 89 c4             	mov    %rax,%r12
  1047a6:	49 39 c4             	cmp    %rax,%r12
  1047a9:	74 23                	je     1047ce <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30e>
  1047ab:	4d 85 e4             	test   %r12,%r12
  1047ae:	74 1e                	je     1047ce <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30e>
  1047b0:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  1047b5:	48 8b 44 24 30       	mov    0x30(%rsp),%rax
  1047ba:	49 8b 34 24          	mov    (%r12),%rsi
  1047be:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
  1047c3:	ff 50 18             	callq  *0x18(%rax)
  1047c6:	84 c0                	test   %al,%al
  1047c8:	74 04                	je     1047ce <_ZN4core3fmt5write17ha9482bb577c609d2E+0x30e>
  1047ca:	b0 01                	mov    $0x1,%al
  1047cc:	eb 02                	jmp    1047d0 <_ZN4core3fmt5write17ha9482bb577c609d2E+0x310>
  1047ce:	31 c0                	xor    %eax,%eax
  1047d0:	48 83 c4 68          	add    $0x68,%rsp
  1047d4:	5b                   	pop    %rbx
  1047d5:	41 5c                	pop    %r12
  1047d7:	41 5d                	pop    %r13
  1047d9:	41 5e                	pop    %r14
  1047db:	41 5f                	pop    %r15
  1047dd:	5d                   	pop    %rbp
  1047de:	c3                   	retq   
  1047df:	48 8d 3d 3a 0f 00 00 	lea    0xf3a(%rip),%rdi        # 105720 <panic_bounds_check_loc.2R>
  1047e6:	48 89 ce             	mov    %rcx,%rsi
  1047e9:	e8 22 fa ff ff       	callq  104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>
  1047ee:	48 8d 3d c3 0f 00 00 	lea    0xfc3(%rip),%rdi        # 1057b8 <_ZN38_$LT$core..option..Option$LT$T$GT$$GT$6unwrap18_MSG_FILE_LINE_COL17hdabacd05a922ec4aE>
  1047f5:	e8 a6 f9 ff ff       	callq  1041a0 <_ZN4core9panicking5panic17h72efe58c7cbe617bE>
  1047fa:	48 8d 3d 37 0f 00 00 	lea    0xf37(%rip),%rdi        # 105738 <panic_bounds_check_loc.2S>
  104801:	e8 0a fa ff ff       	callq  104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>
  104806:	48 8d 3d 2b 0f 00 00 	lea    0xf2b(%rip),%rdi        # 105738 <panic_bounds_check_loc.2S>
  10480d:	e8 fe f9 ff ff       	callq  104210 <_ZN4core9panicking18panic_bounds_check17h64cae15079a8b5eeE>

Disassembly of section .text._ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E:

0000000000104820 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E>:
  104820:	55                   	push   %rbp
  104821:	41 57                	push   %r15
  104823:	41 56                	push   %r14
  104825:	41 55                	push   %r13
  104827:	41 54                	push   %r12
  104829:	53                   	push   %rbx
  10482a:	48 83 ec 48          	sub    $0x48,%rsp
  10482e:	4d 89 c7             	mov    %r8,%r15
  104831:	49 89 d2             	mov    %rdx,%r10
  104834:	49 89 fd             	mov    %rdi,%r13
  104837:	45 8b 5d 50          	mov    0x50(%r13),%r11d
  10483b:	b8 2d 00 00 00       	mov    $0x2d,%eax
  104840:	40 84 f6             	test   %sil,%sil
  104843:	74 17                	je     10485c <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x3c>
  104845:	b8 2b 00 00 00       	mov    $0x2b,%eax
  10484a:	41 f6 c3 01          	test   $0x1,%r11b
  10484e:	75 0c                	jne    10485c <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x3c>
  104850:	45 31 e4             	xor    %r12d,%r12d
  104853:	89 44 24 14          	mov    %eax,0x14(%rsp)
  104857:	4c 89 c8             	mov    %r9,%rax
  10485a:	eb 0e                	jmp    10486a <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x4a>
  10485c:	89 44 24 14          	mov    %eax,0x14(%rsp)
  104860:	49 8d 41 01          	lea    0x1(%r9),%rax
  104864:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  10486a:	41 f6 c3 04          	test   $0x4,%r11b
  10486e:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
  104873:	75 0b                	jne    104880 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x60>
  104875:	31 f6                	xor    %esi,%esi
  104877:	49 83 7d 00 00       	cmpq   $0x0,0x0(%r13)
  10487c:	75 3c                	jne    1048ba <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x9a>
  10487e:	eb 7b                	jmp    1048fb <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0xdb>
  104880:	31 d2                	xor    %edx,%edx
  104882:	48 85 c9             	test   %rcx,%rcx
  104885:	74 23                	je     1048aa <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x8a>
  104887:	48 89 ce             	mov    %rcx,%rsi
  10488a:	4c 89 d7             	mov    %r10,%rdi
  10488d:	90                   	nop
  10488e:	90                   	nop
  10488f:	90                   	nop
  104890:	0f b6 1f             	movzbl (%rdi),%ebx
  104893:	48 ff c7             	inc    %rdi
  104896:	80 e3 c0             	and    $0xc0,%bl
  104899:	31 ed                	xor    %ebp,%ebp
  10489b:	80 fb 80             	cmp    $0x80,%bl
  10489e:	40 0f 94 c5          	sete   %bpl
  1048a2:	48 01 ea             	add    %rbp,%rdx
  1048a5:	48 ff ce             	dec    %rsi
  1048a8:	75 e6                	jne    104890 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x70>
  1048aa:	48 01 c8             	add    %rcx,%rax
  1048ad:	48 29 d0             	sub    %rdx,%rax
  1048b0:	40 b6 01             	mov    $0x1,%sil
  1048b3:	49 83 7d 00 00       	cmpq   $0x0,0x0(%r13)
  1048b8:	74 41                	je     1048fb <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0xdb>
  1048ba:	49 8b 55 08          	mov    0x8(%r13),%rdx
  1048be:	49 89 d6             	mov    %rdx,%r14
  1048c1:	49 29 c6             	sub    %rax,%r14
  1048c4:	76 35                	jbe    1048fb <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0xdb>
  1048c6:	41 f6 c3 08          	test   $0x8,%r11b
  1048ca:	0f 85 82 00 00 00    	jne    104952 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x132>
  1048d0:	48 89 d7             	mov    %rdx,%rdi
  1048d3:	41 8a 5d 58          	mov    0x58(%r13),%bl
  1048d7:	80 fb 03             	cmp    $0x3,%bl
  1048da:	b2 01                	mov    $0x1,%dl
  1048dc:	74 02                	je     1048e0 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0xc0>
  1048de:	89 da                	mov    %ebx,%edx
  1048e0:	48 29 c7             	sub    %rax,%rdi
  1048e3:	80 fa 02             	cmp    $0x2,%dl
  1048e6:	0f 84 d7 00 00 00    	je     1049c3 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x1a3>
  1048ec:	84 d2                	test   %dl,%dl
  1048ee:	0f 85 dd 00 00 00    	jne    1049d1 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x1b1>
  1048f4:	31 ed                	xor    %ebp,%ebp
  1048f6:	e9 db 00 00 00       	jmpq   1049d6 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x1b6>
  1048fb:	45 85 e4             	test   %r12d,%r12d
  1048fe:	0f 84 84 01 00 00    	je     104a88 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x268>
  104904:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104908:	4d 8b 5d 28          	mov    0x28(%r13),%r11
  10490c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
  104913:	00 
  104914:	8b 44 24 14          	mov    0x14(%rsp),%eax
  104918:	41 89 f6             	mov    %esi,%r14d
  10491b:	83 f8 7f             	cmp    $0x7f,%eax
  10491e:	77 14                	ja     104934 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x114>
  104920:	4c 89 d5             	mov    %r10,%rbp
  104923:	48 89 cb             	mov    %rcx,%rbx
  104926:	88 44 24 0c          	mov    %al,0xc(%rsp)
  10492a:	ba 01 00 00 00       	mov    $0x1,%edx
  10492f:	e9 36 01 00 00       	jmpq   104a6a <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x24a>
  104934:	3d 00 08 00 00       	cmp    $0x800,%eax
  104939:	73 61                	jae    10499c <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x17c>
  10493b:	4c 8d 4c 24 0c       	lea    0xc(%rsp),%r9
  104940:	41 b0 c0             	mov    $0xc0,%r8b
  104943:	ba 02 00 00 00       	mov    $0x2,%edx
  104948:	be 01 00 00 00       	mov    $0x1,%esi
  10494d:	e9 07 01 00 00       	jmpq   104a59 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x239>
  104952:	41 c7 45 54 30 00 00 	movl   $0x30,0x54(%r13)
  104959:	00 
  10495a:	41 c6 45 58 01       	movb   $0x1,0x58(%r13)
  10495f:	45 85 e4             	test   %r12d,%r12d
  104962:	0f 84 ec 02 00 00    	je     104c54 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x434>
  104968:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  10496c:	49 8b 45 28          	mov    0x28(%r13),%rax
  104970:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
  104977:	00 
  104978:	8b 54 24 14          	mov    0x14(%rsp),%edx
  10497c:	41 89 f4             	mov    %esi,%r12d
  10497f:	83 fa 7f             	cmp    $0x7f,%edx
  104982:	0f 87 3a 01 00 00    	ja     104ac2 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x2a2>
  104988:	4c 89 d5             	mov    %r10,%rbp
  10498b:	48 89 cb             	mov    %rcx,%rbx
  10498e:	88 54 24 0c          	mov    %dl,0xc(%rsp)
  104992:	ba 01 00 00 00       	mov    $0x1,%edx
  104997:	e9 9b 02 00 00       	jmpq   104c37 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x417>
  10499c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  1049a1:	0f 87 99 00 00 00    	ja     104a40 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x220>
  1049a7:	c6 44 24 0c e0       	movb   $0xe0,0xc(%rsp)
  1049ac:	41 b0 80             	mov    $0x80,%r8b
  1049af:	4c 8d 4c 24 0d       	lea    0xd(%rsp),%r9
  1049b4:	ba 03 00 00 00       	mov    $0x3,%edx
  1049b9:	be 02 00 00 00       	mov    $0x2,%esi
  1049be:	e9 96 00 00 00       	jmpq   104a59 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x239>
  1049c3:	48 89 fd             	mov    %rdi,%rbp
  1049c6:	48 d1 ed             	shr    %rbp
  1049c9:	48 ff c7             	inc    %rdi
  1049cc:	48 d1 ef             	shr    %rdi
  1049cf:	eb 05                	jmp    1049d6 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x1b6>
  1049d1:	48 89 fd             	mov    %rdi,%rbp
  1049d4:	31 ff                	xor    %edi,%edi
  1049d6:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
  1049db:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%rsp)
  1049e2:	00 
  1049e3:	41 8b 45 54          	mov    0x54(%r13),%eax
  1049e7:	3d 80 00 00 00       	cmp    $0x80,%eax
  1049ec:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
  1049f1:	48 89 4c 24 40       	mov    %rcx,0x40(%rsp)
  1049f6:	4c 89 54 24 38       	mov    %r10,0x38(%rsp)
  1049fb:	89 74 24 2c          	mov    %esi,0x2c(%rsp)
  1049ff:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  104a04:	73 0f                	jae    104a15 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x1f5>
  104a06:	88 44 24 10          	mov    %al,0x10(%rsp)
  104a0a:	41 be 01 00 00 00    	mov    $0x1,%r14d
  104a10:	e9 65 01 00 00       	jmpq   104b7a <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x35a>
  104a15:	3d ff 07 00 00       	cmp    $0x7ff,%eax
  104a1a:	0f 87 c1 00 00 00    	ja     104ae1 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x2c1>
  104a20:	48 8d 54 24 10       	lea    0x10(%rsp),%rdx
  104a25:	89 c1                	mov    %eax,%ecx
  104a27:	c1 e9 06             	shr    $0x6,%ecx
  104a2a:	80 e1 1f             	and    $0x1f,%cl
  104a2d:	80 c9 c0             	or     $0xc0,%cl
  104a30:	41 be 02 00 00 00    	mov    $0x2,%r14d
  104a36:	be 01 00 00 00       	mov    $0x1,%esi
  104a3b:	e9 30 01 00 00       	jmpq   104b70 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x350>
  104a40:	66 c7 44 24 0c f0 80 	movw   $0x80f0,0xc(%rsp)
  104a47:	41 b0 80             	mov    $0x80,%r8b
  104a4a:	4c 8d 4c 24 0e       	lea    0xe(%rsp),%r9
  104a4f:	ba 04 00 00 00       	mov    $0x4,%edx
  104a54:	be 03 00 00 00       	mov    $0x3,%esi
  104a59:	4c 89 d5             	mov    %r10,%rbp
  104a5c:	48 89 cb             	mov    %rcx,%rbx
  104a5f:	45 88 01             	mov    %r8b,(%r9)
  104a62:	24 3f                	and    $0x3f,%al
  104a64:	0c 80                	or     $0x80,%al
  104a66:	88 44 34 0c          	mov    %al,0xc(%rsp,%rsi,1)
  104a6a:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
  104a6f:	41 ff 53 18          	callq  *0x18(%r11)
  104a73:	89 c1                	mov    %eax,%ecx
  104a75:	b0 01                	mov    $0x1,%al
  104a77:	84 c9                	test   %cl,%cl
  104a79:	48 89 d9             	mov    %rbx,%rcx
  104a7c:	49 89 ea             	mov    %rbp,%r10
  104a7f:	44 89 f6             	mov    %r14d,%esi
  104a82:	0f 85 37 04 00 00    	jne    104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104a88:	40 84 f6             	test   %sil,%sil
  104a8b:	74 1d                	je     104aaa <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x28a>
  104a8d:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104a91:	49 8b 45 28          	mov    0x28(%r13),%rax
  104a95:	4c 89 d6             	mov    %r10,%rsi
  104a98:	48 89 ca             	mov    %rcx,%rdx
  104a9b:	ff 50 18             	callq  *0x18(%rax)
  104a9e:	89 c1                	mov    %eax,%ecx
  104aa0:	b0 01                	mov    $0x1,%al
  104aa2:	84 c9                	test   %cl,%cl
  104aa4:	0f 85 15 04 00 00    	jne    104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104aaa:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104aae:	49 8b 45 28          	mov    0x28(%r13),%rax
  104ab2:	4c 89 fe             	mov    %r15,%rsi
  104ab5:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  104aba:	ff 50 18             	callq  *0x18(%rax)
  104abd:	e9 fd 03 00 00       	jmpq   104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104ac2:	81 fa 00 08 00 00    	cmp    $0x800,%edx
  104ac8:	73 4a                	jae    104b14 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x2f4>
  104aca:	4c 8d 4c 24 0c       	lea    0xc(%rsp),%r9
  104acf:	41 b0 c0             	mov    $0xc0,%r8b
  104ad2:	ba 02 00 00 00       	mov    $0x2,%edx
  104ad7:	be 01 00 00 00       	mov    $0x1,%esi
  104adc:	e9 3f 01 00 00       	jmpq   104c20 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x400>
  104ae1:	89 c1                	mov    %eax,%ecx
  104ae3:	3d ff ff 00 00       	cmp    $0xffff,%eax
  104ae8:	77 52                	ja     104b3c <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x31c>
  104aea:	c1 e9 0c             	shr    $0xc,%ecx
  104aed:	80 e1 0f             	and    $0xf,%cl
  104af0:	80 c9 e0             	or     $0xe0,%cl
  104af3:	88 4c 24 10          	mov    %cl,0x10(%rsp)
  104af7:	89 c1                	mov    %eax,%ecx
  104af9:	c1 e9 06             	shr    $0x6,%ecx
  104afc:	80 e1 3f             	and    $0x3f,%cl
  104aff:	48 8d 54 24 11       	lea    0x11(%rsp),%rdx
  104b04:	80 c9 80             	or     $0x80,%cl
  104b07:	41 be 03 00 00 00    	mov    $0x3,%r14d
  104b0d:	be 02 00 00 00       	mov    $0x2,%esi
  104b12:	eb 5c                	jmp    104b70 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x350>
  104b14:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  104b1a:	0f 87 e7 00 00 00    	ja     104c07 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x3e7>
  104b20:	c6 44 24 0c e0       	movb   $0xe0,0xc(%rsp)
  104b25:	41 b0 80             	mov    $0x80,%r8b
  104b28:	4c 8d 4c 24 0d       	lea    0xd(%rsp),%r9
  104b2d:	ba 03 00 00 00       	mov    $0x3,%edx
  104b32:	be 02 00 00 00       	mov    $0x2,%esi
  104b37:	e9 e4 00 00 00       	jmpq   104c20 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x400>
  104b3c:	c1 e9 12             	shr    $0x12,%ecx
  104b3f:	80 c9 f0             	or     $0xf0,%cl
  104b42:	88 4c 24 10          	mov    %cl,0x10(%rsp)
  104b46:	89 c1                	mov    %eax,%ecx
  104b48:	c1 e9 0c             	shr    $0xc,%ecx
  104b4b:	80 e1 3f             	and    $0x3f,%cl
  104b4e:	80 c9 80             	or     $0x80,%cl
  104b51:	88 4c 24 11          	mov    %cl,0x11(%rsp)
  104b55:	89 c1                	mov    %eax,%ecx
  104b57:	c1 e9 06             	shr    $0x6,%ecx
  104b5a:	80 e1 3f             	and    $0x3f,%cl
  104b5d:	48 8d 54 24 12       	lea    0x12(%rsp),%rdx
  104b62:	80 c9 80             	or     $0x80,%cl
  104b65:	41 be 04 00 00 00    	mov    $0x4,%r14d
  104b6b:	be 03 00 00 00       	mov    $0x3,%esi
  104b70:	88 0a                	mov    %cl,(%rdx)
  104b72:	24 3f                	and    $0x3f,%al
  104b74:	0c 80                	or     $0x80,%al
  104b76:	88 44 34 10          	mov    %al,0x10(%rsp,%rsi,1)
  104b7a:	49 c7 c7 ff ff ff ff 	mov    $0xffffffffffffffff,%r15
  104b81:	90                   	nop
  104b82:	90                   	nop
  104b83:	90                   	nop
  104b84:	90                   	nop
  104b85:	90                   	nop
  104b86:	90                   	nop
  104b87:	90                   	nop
  104b88:	90                   	nop
  104b89:	90                   	nop
  104b8a:	90                   	nop
  104b8b:	90                   	nop
  104b8c:	90                   	nop
  104b8d:	90                   	nop
  104b8e:	90                   	nop
  104b8f:	90                   	nop
  104b90:	49 ff c7             	inc    %r15
  104b93:	49 39 ef             	cmp    %rbp,%r15
  104b96:	73 1c                	jae    104bb4 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x394>
  104b98:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104b9c:	49 8b 45 28          	mov    0x28(%r13),%rax
  104ba0:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
  104ba5:	4c 89 f2             	mov    %r14,%rdx
  104ba8:	ff 50 18             	callq  *0x18(%rax)
  104bab:	84 c0                	test   %al,%al
  104bad:	74 e1                	je     104b90 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x370>
  104baf:	e9 09 03 00 00       	jmpq   104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104bb4:	45 85 e4             	test   %r12d,%r12d
  104bb7:	0f 84 8e 02 00 00    	je     104e4b <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x62b>
  104bbd:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104bc1:	49 8b 45 28          	mov    0x28(%r13),%rax
  104bc5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
  104bcc:	00 
  104bcd:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
  104bd1:	83 f9 7f             	cmp    $0x7f,%ecx
  104bd4:	77 0e                	ja     104be4 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x3c4>
  104bd6:	88 4c 24 0c          	mov    %cl,0xc(%rsp)
  104bda:	ba 01 00 00 00       	mov    $0x1,%edx
  104bdf:	e9 5b 02 00 00       	jmpq   104e3f <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x61f>
  104be4:	81 f9 00 08 00 00    	cmp    $0x800,%ecx
  104bea:	0f 83 3a 01 00 00    	jae    104d2a <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x50a>
  104bf0:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
  104bf5:	41 b0 c0             	mov    $0xc0,%r8b
  104bf8:	ba 02 00 00 00       	mov    $0x2,%edx
  104bfd:	bd 01 00 00 00       	mov    $0x1,%ebp
  104c02:	e9 2b 02 00 00       	jmpq   104e32 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x612>
  104c07:	66 c7 44 24 0c f0 80 	movw   $0x80f0,0xc(%rsp)
  104c0e:	41 b0 80             	mov    $0x80,%r8b
  104c11:	4c 8d 4c 24 0e       	lea    0xe(%rsp),%r9
  104c16:	ba 04 00 00 00       	mov    $0x4,%edx
  104c1b:	be 03 00 00 00       	mov    $0x3,%esi
  104c20:	4c 89 d5             	mov    %r10,%rbp
  104c23:	48 89 cb             	mov    %rcx,%rbx
  104c26:	45 88 01             	mov    %r8b,(%r9)
  104c29:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
  104c2d:	80 e1 3f             	and    $0x3f,%cl
  104c30:	80 c9 80             	or     $0x80,%cl
  104c33:	88 4c 34 0c          	mov    %cl,0xc(%rsp,%rsi,1)
  104c37:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
  104c3c:	ff 50 18             	callq  *0x18(%rax)
  104c3f:	89 c1                	mov    %eax,%ecx
  104c41:	b0 01                	mov    $0x1,%al
  104c43:	84 c9                	test   %cl,%cl
  104c45:	48 89 d9             	mov    %rbx,%rcx
  104c48:	49 89 ea             	mov    %rbp,%r10
  104c4b:	44 89 e6             	mov    %r12d,%esi
  104c4e:	0f 85 6b 02 00 00    	jne    104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104c54:	40 84 f6             	test   %sil,%sil
  104c57:	74 1d                	je     104c76 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x456>
  104c59:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104c5d:	49 8b 45 28          	mov    0x28(%r13),%rax
  104c61:	4c 89 d6             	mov    %r10,%rsi
  104c64:	48 89 ca             	mov    %rcx,%rdx
  104c67:	ff 50 18             	callq  *0x18(%rax)
  104c6a:	89 c1                	mov    %eax,%ecx
  104c6c:	b0 01                	mov    $0x1,%al
  104c6e:	84 c9                	test   %cl,%cl
  104c70:	0f 85 49 02 00 00    	jne    104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104c76:	41 8a 4d 58          	mov    0x58(%r13),%cl
  104c7a:	80 f9 03             	cmp    $0x3,%cl
  104c7d:	b0 01                	mov    $0x1,%al
  104c7f:	74 02                	je     104c83 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x463>
  104c81:	89 c8                	mov    %ecx,%eax
  104c83:	4c 89 7c 24 20       	mov    %r15,0x20(%rsp)
  104c88:	3c 02                	cmp    $0x2,%al
  104c8a:	48 8b 5c 24 18       	mov    0x18(%rsp),%rbx
  104c8f:	74 09                	je     104c9a <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x47a>
  104c91:	84 c0                	test   %al,%al
  104c93:	75 13                	jne    104ca8 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x488>
  104c95:	45 31 ff             	xor    %r15d,%r15d
  104c98:	eb 14                	jmp    104cae <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x48e>
  104c9a:	4d 89 f7             	mov    %r14,%r15
  104c9d:	49 d1 ef             	shr    %r15
  104ca0:	49 ff c6             	inc    %r14
  104ca3:	49 d1 ee             	shr    %r14
  104ca6:	eb 06                	jmp    104cae <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x48e>
  104ca8:	4d 89 f7             	mov    %r14,%r15
  104cab:	45 31 f6             	xor    %r14d,%r14d
  104cae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
  104cb5:	00 
  104cb6:	41 8b 45 54          	mov    0x54(%r13),%eax
  104cba:	3d 80 00 00 00       	cmp    $0x80,%eax
  104cbf:	73 0f                	jae    104cd0 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x4b0>
  104cc1:	88 44 24 0c          	mov    %al,0xc(%rsp)
  104cc5:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  104ccb:	e9 c0 00 00 00       	jmpq   104d90 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x570>
  104cd0:	3d ff 07 00 00       	cmp    $0x7ff,%eax
  104cd5:	77 20                	ja     104cf7 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x4d7>
  104cd7:	48 8d 54 24 0c       	lea    0xc(%rsp),%rdx
  104cdc:	89 c1                	mov    %eax,%ecx
  104cde:	c1 e9 06             	shr    $0x6,%ecx
  104ce1:	80 e1 1f             	and    $0x1f,%cl
  104ce4:	80 c9 c0             	or     $0xc0,%cl
  104ce7:	41 bc 02 00 00 00    	mov    $0x2,%r12d
  104ced:	be 01 00 00 00       	mov    $0x1,%esi
  104cf2:	e9 8f 00 00 00       	jmpq   104d86 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x566>
  104cf7:	89 c1                	mov    %eax,%ecx
  104cf9:	3d ff ff 00 00       	cmp    $0xffff,%eax
  104cfe:	77 52                	ja     104d52 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x532>
  104d00:	c1 e9 0c             	shr    $0xc,%ecx
  104d03:	80 e1 0f             	and    $0xf,%cl
  104d06:	80 c9 e0             	or     $0xe0,%cl
  104d09:	88 4c 24 0c          	mov    %cl,0xc(%rsp)
  104d0d:	89 c1                	mov    %eax,%ecx
  104d0f:	c1 e9 06             	shr    $0x6,%ecx
  104d12:	80 e1 3f             	and    $0x3f,%cl
  104d15:	48 8d 54 24 0d       	lea    0xd(%rsp),%rdx
  104d1a:	80 c9 80             	or     $0x80,%cl
  104d1d:	41 bc 03 00 00 00    	mov    $0x3,%r12d
  104d23:	be 02 00 00 00       	mov    $0x2,%esi
  104d28:	eb 5c                	jmp    104d86 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x566>
  104d2a:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  104d30:	0f 87 e3 00 00 00    	ja     104e19 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x5f9>
  104d36:	c6 44 24 0c e0       	movb   $0xe0,0xc(%rsp)
  104d3b:	41 b0 80             	mov    $0x80,%r8b
  104d3e:	48 8d 74 24 0d       	lea    0xd(%rsp),%rsi
  104d43:	ba 03 00 00 00       	mov    $0x3,%edx
  104d48:	bd 02 00 00 00       	mov    $0x2,%ebp
  104d4d:	e9 e0 00 00 00       	jmpq   104e32 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x612>
  104d52:	c1 e9 12             	shr    $0x12,%ecx
  104d55:	80 c9 f0             	or     $0xf0,%cl
  104d58:	88 4c 24 0c          	mov    %cl,0xc(%rsp)
  104d5c:	89 c1                	mov    %eax,%ecx
  104d5e:	c1 e9 0c             	shr    $0xc,%ecx
  104d61:	80 e1 3f             	and    $0x3f,%cl
  104d64:	80 c9 80             	or     $0x80,%cl
  104d67:	88 4c 24 0d          	mov    %cl,0xd(%rsp)
  104d6b:	89 c1                	mov    %eax,%ecx
  104d6d:	c1 e9 06             	shr    $0x6,%ecx
  104d70:	80 e1 3f             	and    $0x3f,%cl
  104d73:	48 8d 54 24 0e       	lea    0xe(%rsp),%rdx
  104d78:	80 c9 80             	or     $0x80,%cl
  104d7b:	41 bc 04 00 00 00    	mov    $0x4,%r12d
  104d81:	be 03 00 00 00       	mov    $0x3,%esi
  104d86:	88 0a                	mov    %cl,(%rdx)
  104d88:	24 3f                	and    $0x3f,%al
  104d8a:	0c 80                	or     $0x80,%al
  104d8c:	88 44 34 0c          	mov    %al,0xc(%rsp,%rsi,1)
  104d90:	48 c7 c5 ff ff ff ff 	mov    $0xffffffffffffffff,%rbp
  104d97:	90                   	nop
  104d98:	90                   	nop
  104d99:	90                   	nop
  104d9a:	90                   	nop
  104d9b:	90                   	nop
  104d9c:	90                   	nop
  104d9d:	90                   	nop
  104d9e:	90                   	nop
  104d9f:	90                   	nop
  104da0:	48 ff c5             	inc    %rbp
  104da3:	4c 39 fd             	cmp    %r15,%rbp
  104da6:	73 1c                	jae    104dc4 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x5a4>
  104da8:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104dac:	49 8b 45 28          	mov    0x28(%r13),%rax
  104db0:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
  104db5:	4c 89 e2             	mov    %r12,%rdx
  104db8:	ff 50 18             	callq  *0x18(%rax)
  104dbb:	84 c0                	test   %al,%al
  104dbd:	74 e1                	je     104da0 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x580>
  104dbf:	e9 f9 00 00 00       	jmpq   104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104dc4:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104dc8:	49 8b 45 28          	mov    0x28(%r13),%rax
  104dcc:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  104dd1:	48 89 da             	mov    %rbx,%rdx
  104dd4:	ff 50 18             	callq  *0x18(%rax)
  104dd7:	84 c0                	test   %al,%al
  104dd9:	0f 85 de 00 00 00    	jne    104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104ddf:	48 c7 c5 ff ff ff ff 	mov    $0xffffffffffffffff,%rbp
  104de6:	4c 8d 7c 24 0c       	lea    0xc(%rsp),%r15
  104deb:	90                   	nop
  104dec:	90                   	nop
  104ded:	90                   	nop
  104dee:	90                   	nop
  104def:	90                   	nop
  104df0:	48 ff c5             	inc    %rbp
  104df3:	4c 39 f5             	cmp    %r14,%rbp
  104df6:	73 1a                	jae    104e12 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x5f2>
  104df8:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104dfc:	49 8b 45 28          	mov    0x28(%r13),%rax
  104e00:	4c 89 fe             	mov    %r15,%rsi
  104e03:	4c 89 e2             	mov    %r12,%rdx
  104e06:	ff 50 18             	callq  *0x18(%rax)
  104e09:	84 c0                	test   %al,%al
  104e0b:	74 e3                	je     104df0 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x5d0>
  104e0d:	e9 ab 00 00 00       	jmpq   104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104e12:	31 c0                	xor    %eax,%eax
  104e14:	e9 a6 00 00 00       	jmpq   104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>
  104e19:	66 c7 44 24 0c f0 80 	movw   $0x80f0,0xc(%rsp)
  104e20:	41 b0 80             	mov    $0x80,%r8b
  104e23:	48 8d 74 24 0e       	lea    0xe(%rsp),%rsi
  104e28:	ba 04 00 00 00       	mov    $0x4,%edx
  104e2d:	bd 03 00 00 00       	mov    $0x3,%ebp
  104e32:	44 88 06             	mov    %r8b,(%rsi)
  104e35:	80 e1 3f             	and    $0x3f,%cl
  104e38:	80 c9 80             	or     $0x80,%cl
  104e3b:	88 4c 2c 0c          	mov    %cl,0xc(%rsp,%rbp,1)
  104e3f:	48 8d 74 24 0c       	lea    0xc(%rsp),%rsi
  104e44:	ff 50 18             	callq  *0x18(%rax)
  104e47:	84 c0                	test   %al,%al
  104e49:	75 72                	jne    104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104e4b:	80 7c 24 2c 00       	cmpb   $0x0,0x2c(%rsp)
  104e50:	74 19                	je     104e6b <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x64b>
  104e52:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104e56:	49 8b 45 28          	mov    0x28(%r13),%rax
  104e5a:	48 8b 74 24 38       	mov    0x38(%rsp),%rsi
  104e5f:	48 8b 54 24 40       	mov    0x40(%rsp),%rdx
  104e64:	ff 50 18             	callq  *0x18(%rax)
  104e67:	84 c0                	test   %al,%al
  104e69:	75 52                	jne    104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104e6b:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104e6f:	49 8b 45 28          	mov    0x28(%r13),%rax
  104e73:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  104e78:	48 89 da             	mov    %rbx,%rdx
  104e7b:	ff 50 18             	callq  *0x18(%rax)
  104e7e:	84 c0                	test   %al,%al
  104e80:	75 3b                	jne    104ebd <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69d>
  104e82:	48 c7 c5 ff ff ff ff 	mov    $0xffffffffffffffff,%rbp
  104e89:	4c 8d 7c 24 10       	lea    0x10(%rsp),%r15
  104e8e:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  104e93:	90                   	nop
  104e94:	90                   	nop
  104e95:	90                   	nop
  104e96:	90                   	nop
  104e97:	90                   	nop
  104e98:	90                   	nop
  104e99:	90                   	nop
  104e9a:	90                   	nop
  104e9b:	90                   	nop
  104e9c:	90                   	nop
  104e9d:	90                   	nop
  104e9e:	90                   	nop
  104e9f:	90                   	nop
  104ea0:	48 ff c5             	inc    %rbp
  104ea3:	48 39 dd             	cmp    %rbx,%rbp
  104ea6:	73 26                	jae    104ece <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x6ae>
  104ea8:	49 8b 7d 20          	mov    0x20(%r13),%rdi
  104eac:	49 8b 45 28          	mov    0x28(%r13),%rax
  104eb0:	4c 89 fe             	mov    %r15,%rsi
  104eb3:	4c 89 f2             	mov    %r14,%rdx
  104eb6:	ff 50 18             	callq  *0x18(%rax)
  104eb9:	84 c0                	test   %al,%al
  104ebb:	74 e3                	je     104ea0 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x680>
  104ebd:	b0 01                	mov    $0x1,%al
  104ebf:	48 83 c4 48          	add    $0x48,%rsp
  104ec3:	5b                   	pop    %rbx
  104ec4:	41 5c                	pop    %r12
  104ec6:	41 5d                	pop    %r13
  104ec8:	41 5e                	pop    %r14
  104eca:	41 5f                	pop    %r15
  104ecc:	5d                   	pop    %rbp
  104ecd:	c3                   	retq   
  104ece:	31 c0                	xor    %eax,%eax
  104ed0:	eb ed                	jmp    104ebf <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E+0x69f>

Disassembly of section .text._ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE:

0000000000104ee0 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE>:
  104ee0:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  104ee7:	49 89 f2             	mov    %rsi,%r10
  104eea:	8b 0f                	mov    (%rdi),%ecx
  104eec:	48 c7 84 24 80 00 00 	movq   $0x0,0x80(%rsp)
  104ef3:	00 00 00 00 00 
  104ef8:	48 c7 44 24 78 00 00 	movq   $0x0,0x78(%rsp)
  104eff:	00 00 
  104f01:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
  104f08:	00 00 
  104f0a:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
  104f11:	00 00 
  104f13:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  104f1a:	00 00 
  104f1c:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  104f23:	00 00 
  104f25:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  104f2c:	00 00 
  104f2e:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  104f35:	00 00 
  104f37:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  104f3e:	00 00 
  104f40:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  104f47:	00 00 
  104f49:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  104f50:	00 00 
  104f52:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
  104f59:	00 00 
  104f5b:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  104f62:	00 00 
  104f64:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
  104f6b:	00 00 
  104f6d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  104f74:	00 00 
  104f76:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  104f7d:	00 00 
  104f7f:	45 31 c9             	xor    %r9d,%r9d
  104f82:	90                   	nop
  104f83:	90                   	nop
  104f84:	90                   	nop
  104f85:	90                   	nop
  104f86:	90                   	nop
  104f87:	90                   	nop
  104f88:	90                   	nop
  104f89:	90                   	nop
  104f8a:	90                   	nop
  104f8b:	90                   	nop
  104f8c:	90                   	nop
  104f8d:	90                   	nop
  104f8e:	90                   	nop
  104f8f:	90                   	nop
  104f90:	89 ca                	mov    %ecx,%edx
  104f92:	c1 e9 04             	shr    $0x4,%ecx
  104f95:	80 e2 0f             	and    $0xf,%dl
  104f98:	80 fa 0a             	cmp    $0xa,%dl
  104f9b:	b0 30                	mov    $0x30,%al
  104f9d:	72 02                	jb     104fa1 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE+0xc1>
  104f9f:	b0 37                	mov    $0x37,%al
  104fa1:	00 d0                	add    %dl,%al
  104fa3:	42 88 84 0c 87 00 00 	mov    %al,0x87(%rsp,%r9,1)
  104faa:	00 
  104fab:	49 ff c9             	dec    %r9
  104fae:	85 c9                	test   %ecx,%ecx
  104fb0:	75 de                	jne    104f90 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE+0xb0>
  104fb2:	4c 89 cf             	mov    %r9,%rdi
  104fb5:	48 83 ef 80          	sub    $0xffffffffffffff80,%rdi
  104fb9:	48 81 ff 81 00 00 00 	cmp    $0x81,%rdi
  104fc0:	73 2c                	jae    104fee <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u32$GT$3fmt17h84e3dd0a920fe80fE+0x10e>
  104fc2:	4e 8d 84 0c 88 00 00 	lea    0x88(%rsp,%r9,1),%r8
  104fc9:	00 
  104fca:	49 f7 d9             	neg    %r9
  104fcd:	48 8d 15 bf b6 ff ff 	lea    -0x4941(%rip),%rdx        # 100693 <str.9d>
  104fd4:	be 01 00 00 00       	mov    $0x1,%esi
  104fd9:	b9 02 00 00 00       	mov    $0x2,%ecx
  104fde:	4c 89 d7             	mov    %r10,%rdi
  104fe1:	e8 3a f8 ff ff       	callq  104820 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E>
  104fe6:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  104fed:	c3                   	retq   
  104fee:	be 80 00 00 00       	mov    $0x80,%esi
  104ff3:	e8 28 f3 ff ff       	callq  104320 <_ZN4core5slice22slice_index_order_fail17h53bf70f83f93d32dE>

Disassembly of section .text._ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E:

0000000000105000 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E>:
  105000:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  105007:	49 89 f2             	mov    %rsi,%r10
  10500a:	48 8b 0f             	mov    (%rdi),%rcx
  10500d:	48 c7 84 24 80 00 00 	movq   $0x0,0x80(%rsp)
  105014:	00 00 00 00 00 
  105019:	48 c7 44 24 78 00 00 	movq   $0x0,0x78(%rsp)
  105020:	00 00 
  105022:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
  105029:	00 00 
  10502b:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
  105032:	00 00 
  105034:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
  10503b:	00 00 
  10503d:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
  105044:	00 00 
  105046:	48 c7 44 24 50 00 00 	movq   $0x0,0x50(%rsp)
  10504d:	00 00 
  10504f:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  105056:	00 00 
  105058:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
  10505f:	00 00 
  105061:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
  105068:	00 00 
  10506a:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  105071:	00 00 
  105073:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
  10507a:	00 00 
  10507c:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
  105083:	00 00 
  105085:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
  10508c:	00 00 
  10508e:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
  105095:	00 00 
  105097:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
  10509e:	00 00 
  1050a0:	45 31 c9             	xor    %r9d,%r9d
  1050a3:	90                   	nop
  1050a4:	90                   	nop
  1050a5:	90                   	nop
  1050a6:	90                   	nop
  1050a7:	90                   	nop
  1050a8:	90                   	nop
  1050a9:	90                   	nop
  1050aa:	90                   	nop
  1050ab:	90                   	nop
  1050ac:	90                   	nop
  1050ad:	90                   	nop
  1050ae:	90                   	nop
  1050af:	90                   	nop
  1050b0:	48 89 ca             	mov    %rcx,%rdx
  1050b3:	48 c1 e9 04          	shr    $0x4,%rcx
  1050b7:	80 e2 0f             	and    $0xf,%dl
  1050ba:	80 fa 0a             	cmp    $0xa,%dl
  1050bd:	b0 30                	mov    $0x30,%al
  1050bf:	72 02                	jb     1050c3 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E+0xc3>
  1050c1:	b0 37                	mov    $0x37,%al
  1050c3:	00 d0                	add    %dl,%al
  1050c5:	42 88 84 0c 87 00 00 	mov    %al,0x87(%rsp,%r9,1)
  1050cc:	00 
  1050cd:	49 ff c9             	dec    %r9
  1050d0:	48 85 c9             	test   %rcx,%rcx
  1050d3:	75 db                	jne    1050b0 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E+0xb0>
  1050d5:	4c 89 cf             	mov    %r9,%rdi
  1050d8:	48 83 ef 80          	sub    $0xffffffffffffff80,%rdi
  1050dc:	48 81 ff 81 00 00 00 	cmp    $0x81,%rdi
  1050e3:	73 2c                	jae    105111 <_ZN4core3fmt3num53_$LT$impl$u20$core..fmt..UpperHex$u20$for$u20$u64$GT$3fmt17h611b48e4f31739a0E+0x111>
  1050e5:	4e 8d 84 0c 88 00 00 	lea    0x88(%rsp,%r9,1),%r8
  1050ec:	00 
  1050ed:	49 f7 d9             	neg    %r9
  1050f0:	48 8d 15 9c b5 ff ff 	lea    -0x4a64(%rip),%rdx        # 100693 <str.9d>
  1050f7:	be 01 00 00 00       	mov    $0x1,%esi
  1050fc:	b9 02 00 00 00       	mov    $0x2,%ecx
  105101:	4c 89 d7             	mov    %r10,%rdi
  105104:	e8 17 f7 ff ff       	callq  104820 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E>
  105109:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  105110:	c3                   	retq   
  105111:	be 80 00 00 00       	mov    $0x80,%esi
  105116:	e8 05 f2 ff ff       	callq  104320 <_ZN4core5slice22slice_index_order_fail17h53bf70f83f93d32dE>

Disassembly of section .text._ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E:

0000000000105120 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E>:
  105120:	53                   	push   %rbx
  105121:	48 83 ec 30          	sub    $0x30,%rsp
  105125:	49 89 f2             	mov    %rsi,%r10
  105128:	48 8b 0f             	mov    (%rdi),%rcx
  10512b:	bf 27 00 00 00       	mov    $0x27,%edi
  105130:	48 81 f9 10 27 00 00 	cmp    $0x2710,%rcx
  105137:	72 7a                	jb     1051b3 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0x93>
  105139:	49 b8 4b 59 86 38 d6 	movabs $0x346dc5d63886594b,%r8
  105140:	c5 6d 34 
  105143:	49 b9 c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%r9
  10514a:	c2 f5 28 
  10514d:	4c 8d 1d 41 b5 ff ff 	lea    -0x4abf(%rip),%r11        # 100695 <byte_str.9e>
  105154:	48 89 ce             	mov    %rcx,%rsi
  105157:	90                   	nop
  105158:	90                   	nop
  105159:	90                   	nop
  10515a:	90                   	nop
  10515b:	90                   	nop
  10515c:	90                   	nop
  10515d:	90                   	nop
  10515e:	90                   	nop
  10515f:	90                   	nop
  105160:	48 89 f0             	mov    %rsi,%rax
  105163:	49 f7 e0             	mul    %r8
  105166:	48 89 d1             	mov    %rdx,%rcx
  105169:	48 c1 e9 0b          	shr    $0xb,%rcx
  10516d:	48 69 c1 10 27 00 00 	imul   $0x2710,%rcx,%rax
  105174:	48 89 f3             	mov    %rsi,%rbx
  105177:	48 29 c3             	sub    %rax,%rbx
  10517a:	48 89 d8             	mov    %rbx,%rax
  10517d:	48 c1 e8 02          	shr    $0x2,%rax
  105181:	49 f7 e1             	mul    %r9
  105184:	48 c1 ea 02          	shr    $0x2,%rdx
  105188:	48 6b c2 64          	imul   $0x64,%rdx,%rax
  10518c:	48 29 c3             	sub    %rax,%rbx
  10518f:	41 0f b7 04 53       	movzwl (%r11,%rdx,2),%eax
  105194:	66 89 44 3c 05       	mov    %ax,0x5(%rsp,%rdi,1)
  105199:	41 0f b7 04 5b       	movzwl (%r11,%rbx,2),%eax
  10519e:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  1051a3:	48 8d 7f fc          	lea    -0x4(%rdi),%rdi
  1051a7:	48 81 fe ff e0 f5 05 	cmp    $0x5f5e0ff,%rsi
  1051ae:	48 89 ce             	mov    %rcx,%rsi
  1051b1:	77 ad                	ja     105160 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0x40>
  1051b3:	48 83 f9 64          	cmp    $0x64,%rcx
  1051b7:	7c 36                	jl     1051ef <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0xcf>
  1051b9:	48 89 c8             	mov    %rcx,%rax
  1051bc:	48 c1 e8 02          	shr    $0x2,%rax
  1051c0:	48 ba c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rdx
  1051c7:	c2 f5 28 
  1051ca:	48 f7 e2             	mul    %rdx
  1051cd:	48 c1 ea 02          	shr    $0x2,%rdx
  1051d1:	48 6b c2 64          	imul   $0x64,%rdx,%rax
  1051d5:	48 29 c1             	sub    %rax,%rcx
  1051d8:	48 8d 05 b6 b4 ff ff 	lea    -0x4b4a(%rip),%rax        # 100695 <byte_str.9e>
  1051df:	0f b7 04 48          	movzwl (%rax,%rcx,2),%eax
  1051e3:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  1051e8:	48 83 c7 fe          	add    $0xfffffffffffffffe,%rdi
  1051ec:	48 89 d1             	mov    %rdx,%rcx
  1051ef:	48 83 f9 09          	cmp    $0x9,%rcx
  1051f3:	7f 0c                	jg     105201 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0xe1>
  1051f5:	80 c1 30             	add    $0x30,%cl
  1051f8:	88 4c 3c 08          	mov    %cl,0x8(%rsp,%rdi,1)
  1051fc:	48 ff cf             	dec    %rdi
  1051ff:	eb 14                	jmp    105215 <_ZN4core3fmt3num54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h006fb505fdcf9104E+0xf5>
  105201:	48 8d 05 8d b4 ff ff 	lea    -0x4b73(%rip),%rax        # 100695 <byte_str.9e>
  105208:	0f b7 04 48          	movzwl (%rax,%rcx,2),%eax
  10520c:	66 89 44 3c 07       	mov    %ax,0x7(%rsp,%rdi,1)
  105211:	48 83 c7 fe          	add    $0xfffffffffffffffe,%rdi
  105215:	4c 8d 44 3c 09       	lea    0x9(%rsp,%rdi,1),%r8
  10521a:	41 b9 27 00 00 00    	mov    $0x27,%r9d
  105220:	49 29 f9             	sub    %rdi,%r9
  105223:	48 8d 15 af b1 ff ff 	lea    -0x4e51(%rip),%rdx        # 1003d9 <str.11+0x29>
  10522a:	be 01 00 00 00       	mov    $0x1,%esi
  10522f:	31 c9                	xor    %ecx,%ecx
  105231:	4c 89 d7             	mov    %r10,%rdi
  105234:	e8 e7 f5 ff ff       	callq  104820 <_ZN4core3fmt9Formatter12pad_integral17hc90605bfdc820c82E>
  105239:	48 83 c4 30          	add    $0x30,%rsp
  10523d:	5b                   	pop    %rbx
  10523e:	c3                   	retq   
